{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment HarvesterHarvester  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
00.00.00 \par
}}HarvesterHarvester}
{\comment Generated by doxygen 1.11.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt HarvesterHarvester}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 00.00.00\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
HarvesterHarvester\par \pard\plain 
{\tc\tcl1 \v HarvesterHarvester}
{\xe \v HarvesterHarvester}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
A tool for harvesting data out of {\f2 {\i Harvester} 's (DigiFX Interactive, 1996)} dat files.\par
This program is the first piece of a toolchain that I'm developing as I work to reverse engineering {\i Harvester} . The ultimate goal of this project is to eventually port the game to a more modern graphics framework (Raylib or OpenGL) just for fun/to teach myself the basics of reverse engineering.\par
The program works in two steps:{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab It reconstructs the original disk images that Harvester would've shipped with in 1996{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\i Note} : if you own the original game disks, this step is not needed.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
See USAGE.md for more details.\par}
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab It extracts the dat files contained within those new directories in order to give you full access to all of the game's files.\par}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Future Projects
\par}
{\tc\tcl3 \v Future Projects}
The next step for me in this project will be creating an asset viewer.\par
This will require me to reverse engineer all of the various, non-standardized file formats that DigiFX used when making the game, which will be essential for porting the game in the future.\par
So far, I've already been able to reverse engineer the {\f2 *.BM}  files, which are used for all the static backgrounds in the games, for character portraits, the map, and more. Unfortunately, I likely can't to share these files, at least not in bulk (see below). I will, however, be sharing a small handful of these images as I show this project off online and I'll make sure to add a link here in the future if you wish to view those!\par}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Easiest Way
\par}
{\tc\tcl3 \v Easiest Way}
Navigate to the {\f2 releases} page and download the latest zip file.\par
Once downloaded, extract the zip file wherever you'd like and you're done! See USAGE.md for more details on how to run the program.\par
{\b NOTE} : {\i if you're reading this in the present, you'll notice that there currently aren't any available releases. I'm writing this README in advance \'96 this project isn't quite done yet, sorry!} \par}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Building from source (Linux/MacOS/Unix)
\par}
{\tc\tcl3 \v Building from source (Linux/MacOS/Unix)}
1) Install the following dependencies: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gcc make mingw32-gcc clang-tools-extra valgrind doxygen\par
}
 2) Clone the repo: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ git clone https://github.com/IcePanorama/HarvesterHarvester/ && cd HarvesterHarvester\par
}
 3) Build using make: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ make release # for *nix, x86_64, and i686 executables\par
# ... or, alternatively ...\par
$ make full    # for just the *nix executable\par
}
 Running {\f2 make release}  is strongly recommended as the build process for the release target makes use of every single dependency listed above, thus ensuring that you have all the correct packages installed on your machine.\par
Congrats! You're now all set to use the program or start contributing.\par}
\par}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A note on piracy
\par}
{\tc\tcl2 \v A note on piracy}
This program requires that you legally own a copy of {\i Harvester}  in order to source the necessary dat files.\par
The GOG version (which this project was built around) {\f2 is available here for $5.99}, although it's worth noting that it does go on sale rather often.\par
{\f2 Alternatively, visit any of the retailers on this link if you'd rather shop elsewhere}.\par
This project in no way intends to encourage the piracy of DigiFX' software. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/{\b data_reader.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b datetime.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b directory.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b errors.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b extractor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_flags.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b hh.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b index_file.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b options.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b output.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b path_table.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b volume_descriptor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/data_reader.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint32} (FILE *fptr, uint32_t *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint16} (FILE *fptr, uint16_t *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_string} (FILE *fptr, char *output, uint8_t length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_array_uint8} (FILE *fptr, uint8_t *arr, uint8_t length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dec_datetime} (FILE *fptr, dec_datetime *dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_single_uint8} (FILE *fptr, uint8_t *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dir_datetime} (FILE *fptr, dir_datetime *dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_file_flags} (FILE *fptr, file_flags *ff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build_path_string_from_file} (FILE *fptr, char *output)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v build_path_string_from_file\:data_reader.c}
{\xe \v data_reader.c\:build_path_string_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void build_path_string_from_file (FILE * fptr, char * output)}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 255} of file {\b data_reader.c}.}\par
}
{\xe \v read_array_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_array_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_array_uint8 (FILE * fptr, uint8_t * arr, uint8_t length)}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint16_t (FILE * fptr, uint16_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 130} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint32_t (FILE * fptr, uint32_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 99} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint16\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint16 (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint32\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint32 (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b data_reader.c}.}\par
}
{\xe \v read_dec_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dec_datetime (FILE * fptr, dec_datetime * dt)}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b data_reader.c}.}\par
}
{\xe \v read_dir_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dir_datetime (FILE * fptr, dir_datetime * dt)}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b data_reader.c}.}\par
}
{\xe \v read_file_flags\:data_reader.c}
{\xe \v data_reader.c\:read_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_file_flags (FILE * fptr, file_flags * ff)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 222} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint16_t (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint32_t (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b data_reader.c}.}\par
}
{\xe \v read_single_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_single_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_single_uint8 (FILE * fptr, uint8_t * value)}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 192} of file {\b data_reader.c}.}\par
}
{\xe \v read_string\:data_reader.c}
{\xe \v data_reader.c\:read_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_string (FILE * fptr, char * output, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b data_reader.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_reader.c\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "data_reader.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "file_flags.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 \par
00020 {\cf21 #include <stdbool.h>}\par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 \par
00028 {\cf17 static} int8_t read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output);\par
00029 \par
00034 {\cf17 static} int8_t read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output);\par
00035 \par
00036 int8_t\par
00037 read_both_endian_data_uint32 (FILE *fptr, uint32_t *output)\par
00038 \{\par
00039   uint32_t value;\par
00040   {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00041     {\cf19 return} HH_FREAD_ERROR;\par
00042 \par
00043   uint32_t expected_value;\par
00044   read_big_endian_data_uint32_t (fptr, &expected_value);\par
00045 \par
00046   {\cf19 if} (value != expected_value)\par
00047     \{\par
00048       hh_log (HH_LOG_ERROR,\par
00049               {\cf22 "ERROR: Incorrect endian conversion (uint32_t). Expected "}\par
00050               {\cf22 "0x%08X, got 0x%08X."},\par
00051               expected_value, value);\par
00052     \}\par
00053 \par
00054   *output = value;\par
00055   {\cf19 return} 0;\par
00056 \}\par
00057 \par
00058 int8_t\par
00059 read_both_endian_data_uint16 (FILE *fptr, uint16_t *output)\par
00060 \{\par
00061   {\cf19 if} (read_little_endian_data_uint16_t (fptr, output) != 0)\par
00062     {\cf19 return} HH_FREAD_ERROR;\par
00063 \par
00064   uint16_t expected_value;\par
00065   {\cf19 if} (read_big_endian_data_uint16_t (fptr, &expected_value) != 0)\par
00066     {\cf19 return} HH_FREAD_ERROR;\par
00067 \par
00068   {\cf19 if} (*output != expected_value)\par
00069     \{\par
00070       hh_log (HH_LOG_ERROR,\par
00071               {\cf22 "Incorrect endian conversion (uint16_t). Expected 0x%04X, got "}\par
00072               {\cf22 "0x%04X."},\par
00073               expected_value, *output);\par
00074       {\cf19 return} -1;\par
00075     \}\par
00076 \par
00077   {\cf19 return} 0;\par
00078 \}\par
00079 \par
00080 int8_t\par
00081 read_little_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00082 \{\par
00083   uint8_t bytes[4];\par
00084   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00085   {\cf19 if} (bytes_read != 4)\par
00086     \{\par
00087       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00088 \par
00089       {\cf19 return} HH_FREAD_ERROR;\par
00090     \}\par
00091 \par
00092   *output = ((uint32_t)bytes[3] << 24) | ((uint32_t)bytes[2] << 16)\par
00093             | ((uint32_t)bytes[1] << 8) | (uint32_t)bytes[0];\par
00094 \par
00095   {\cf19 return} 0;\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00100 \{\par
00101   uint8_t bytes[4];\par
00102   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00103   {\cf19 if} (bytes_read != 4)\par
00104     \{\par
00105       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00106       {\cf19 return} HH_FREAD_ERROR;\par
00107     \}\par
00108 \par
00109   *output = ((uint32_t)bytes[0] << 24) | ((uint32_t)bytes[1] << 16)\par
00110             | ((uint32_t)bytes[2] << 8) | (uint32_t)bytes[3];\par
00111   {\cf19 return} 0;\par
00112 \}\par
00113 \par
00114 int8_t\par
00115 read_little_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00116 \{\par
00117   uint8_t bytes[2];\par
00118   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00119   {\cf19 if} (bytes_read != 2)\par
00120     \{\par
00121       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00122       {\cf19 return} HH_FREAD_ERROR;\par
00123     \}\par
00124 \par
00125   *output = ((uint16_t)bytes[0] << 8) | (uint16_t)bytes[1];\par
00126   {\cf19 return} 0;\par
00127 \}\par
00128 \par
00129 int8_t\par
00130 read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00131 \{\par
00132   uint8_t bytes[2];\par
00133   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00134   {\cf19 if} (bytes_read != 2)\par
00135     \{\par
00136       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00137       {\cf19 return} HH_FREAD_ERROR;\par
00138     \}\par
00139 \par
00140   *output = ((uint16_t)bytes[1] << 8) | (uint16_t)bytes[0];\par
00141   {\cf19 return} 0;\par
00142 \}\par
00143 \par
00144 int8_t\par
00145 read_string (FILE *fptr, {\cf18 char} *output, uint8_t length)\par
00146 \{\par
00147   {\cf18 size_t} bytes_read = fread (output, {\cf17 sizeof} ({\cf18 char}), length - 1, fptr);\par
00148   output[length - 1] = {\cf23 '\\0'};\par
00149   {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * length - 1)\par
00150     \{\par
00151       handle_fread_error (bytes_read, {\cf17 sizeof} ({\cf18 char}) * length - 1);\par
00152       {\cf19 return} HH_FREAD_ERROR;\par
00153     \}\par
00154 \par
00155   {\cf19 return} 0;\par
00156 \}\par
00157 \par
00158 int8_t\par
00159 read_array_uint8 (FILE *fptr, uint8_t *arr, uint8_t length)\par
00160 \{\par
00161   {\cf18 size_t} bytes_read = fread (arr, {\cf17 sizeof} (uint8_t), length, fptr);\par
00162   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t) * length)\par
00163     \{\par
00164       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t) * length);\par
00165       {\cf19 return} HH_FREAD_ERROR;\par
00166     \}\par
00167 \par
00168   {\cf19 return} 0;\par
00169 \}\par
00170 \par
00171 int8_t\par
00172 read_dec_datetime (FILE *fptr, dec_datetime *dt)\par
00173 \{\par
00174   {\cf19 if} ((read_string (fptr, dt->year, YEAR_FIELD_LEN) != 0)\par
00175       || (read_string (fptr, dt->month, MONTH_FIELD_LEN) != 0)\par
00176       || (read_string (fptr, dt->day, DAY_FIELD_LEN) != 0)\par
00177       || (read_string (fptr, dt->hour, HOUR_FIELD_LEN) != 0)\par
00178       || (read_string (fptr, dt->minute, MINUTE_FIELD_LEN) != 0)\par
00179       || (read_string (fptr, dt->second, SECOND_FIELD_LEN) != 0)\par
00180       || (read_string (fptr, dt->hundredths_of_a_second,\par
00181                        HUNDREDTHS_OF_A_SECOND_FIELD_LEN)\par
00182           != 0)\par
00183       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00184     \{\par
00185       {\cf19 return} HH_FREAD_ERROR;\par
00186     \}\par
00187 \par
00188   {\cf19 return} 0;\par
00189 \}\par
00190 \par
00191 int8_t\par
00192 read_single_uint8 (FILE *fptr, uint8_t *value)\par
00193 \{\par
00194   {\cf18 size_t} bytes_read = fread (value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00195   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t))\par
00196     \{\par
00197       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t));\par
00198       {\cf19 return} HH_FREAD_ERROR;\par
00199     \}\par
00200 \par
00201   {\cf19 return} 0;\par
00202 \}\par
00203 \par
00204 int8_t\par
00205 read_dir_datetime (FILE *fptr, dir_datetime *dt)\par
00206 \{\par
00207   {\cf19 if} ((read_single_uint8 (fptr, &dt->year) != 0)\par
00208       || (read_single_uint8 (fptr, &dt->month) != 0)\par
00209       || (read_single_uint8 (fptr, &dt->day) != 0)\par
00210       || (read_single_uint8 (fptr, &dt->hour) != 0)\par
00211       || (read_single_uint8 (fptr, &dt->minute) != 0)\par
00212       || (read_single_uint8 (fptr, &dt->second) != 0)\par
00213       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00214     \{\par
00215       {\cf19 return} HH_FREAD_ERROR;\par
00216     \}\par
00217 \par
00218   {\cf19 return} 0;\par
00219 \}\par
00220 \par
00221 int8_t\par
00222 read_file_flags (FILE *fptr, file_flags *ff)\par
00223 \{\par
00224   uint8_t byte;\par
00225   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00226     {\cf19 return} HH_FREAD_ERROR;\par
00227 \par
00228   {\cf19 if} ({\cf18 byte} & 0x1)\par
00229     \{\par
00230       ff->hidden = {\cf17 true};\par
00231     \}\par
00232   {\cf19 if} ({\cf18 byte} & 0x2)\par
00233     \{\par
00234       ff->subdirectory = {\cf17 true};\par
00235     \}\par
00236   {\cf19 if} ({\cf18 byte} & 0x4)\par
00237     \{\par
00238       ff->associated_file = {\cf17 true};\par
00239     \}\par
00240   {\cf19 if} ({\cf18 byte} & 0x8)\par
00241     \{\par
00242       ff->extended_attribute_record_contains_owner_and_group_permissions\par
00243           = {\cf17 true};\par
00244     \}\par
00245   {\cf19 if} ({\cf18 byte} & 0x10)\par
00246     \{\par
00247       ff->final_directory_record = {\cf17 true};\par
00248     \}\par
00249 \par
00250   {\cf19 return} 0;\par
00251 \}\par
00252 \par
00253 {\cf20 // this system could probably be replaced with a macro}\par
00254 {\cf18 void}\par
00255 build_path_string_from_file (FILE *fptr, {\cf18 char} *output)\par
00256 \{\par
00257   {\cf18 char} format[32] = \{ 0 \};\par
00258   fgets (format, {\cf17 sizeof} (format), fptr);\par
00259   {\cf18 size_t} len = strlen (format);\par
00260   format[len - 1] = {\cf23 '\\0'};\par
00261 \par
00262   sprintf (output, format, OP_OUTPUT_DIR, OP_PATH_SEPARATOR,\par
00263            OP_PATH_SEPARATOR);\par
00264 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/datetime.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dec_datetime} (dec_datetime dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dir_datetime} (dir_datetime dt)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_dec_datetime\:datetime.c}
{\xe \v datetime.c\:print_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dec_datetime (dec_datetime dt)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b datetime.c}.}\par
}
{\xe \v print_dir_datetime\:datetime.c}
{\xe \v datetime.c\:print_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dir_datetime (dir_datetime dt)}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b datetime.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.c\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "datetime.h"}\par
00002 \par
00003 {\cf21 #include <stdio.h>}\par
00004 \par
00005 {\cf18 void}\par
00006 print_dec_datetime (dec_datetime dt)\par
00007 \{\par
00008   printf ({\cf22 "%s-%s-%s @ %s:%s:%s.%s (%02X)\\n"}, dt.year, dt.month, dt.day,\par
00009           dt.hour, dt.minute, dt.second, dt.hundredths_of_a_second,\par
00010           dt.time_zone_offset);\par
00011 \}\par
00012 \par
00013 {\cf18 void}\par
00014 print_dir_datetime (dir_datetime dt)\par
00015 \{\par
00016   printf ({\cf22 "%02X-%02X-%02X @ %02X:%02X:%02X (%02X)\\n"}, dt.year, dt.month,\par
00017           dt.day, dt.hour, dt.minute, dt.second, dt.time_zone_offset);\par
00018 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/directory.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "directory.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_directory_records} (directory *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directory} (directory *d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_directory} (directory *d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_record_to_directory} (directory *d, directory_record *r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory_record} (directory_record *r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory} (directory *d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_directory} (FILE *fptr, directory *d)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_STARTING_NUM_RECORDS} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_record_to_directory\:directory.c}
{\xe \v directory.c\:add_record_to_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_record_to_directory (directory * d, directory_record * r)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b directory.c}.}\par
}
{\xe \v create_directory\:directory.c}
{\xe \v directory.c\:create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directory (directory * d)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b directory.c}.}\par
}
{\xe \v destroy_directory\:directory.c}
{\xe \v directory.c\:destroy_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_directory (directory * d)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b directory.c}.}\par
}
{\xe \v print_directory\:directory.c}
{\xe \v directory.c\:print_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory (directory * d)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b directory.c}.}\par
}
{\xe \v print_directory_record\:directory.c}
{\xe \v directory.c\:print_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory_record (directory_record * r)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b directory.c}.}\par
}
{\xe \v process_directory\:directory.c}
{\xe \v directory.c\:process_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_directory (FILE * fptr, directory * d)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b directory.c}.}\par
}
{\xe \v resize_directory_records\:directory.c}
{\xe \v directory.c\:resize_directory_records}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_directory_records (directory * d){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 99} of file {\b directory.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v DIR_RECORDS_GROWTH_RATE\:directory.c}
{\xe \v directory.c\:DIR_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b directory.c}.}\par
}
{\xe \v DIR_STARTING_NUM_RECORDS\:directory.c}
{\xe \v directory.c\:DIR_STARTING_NUM_RECORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_STARTING_NUM_RECORDS = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b directory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory.c\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "directory.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <stdio.h>}\par
00020 {\cf21 #include <stdlib.h>}\par
00021 \par
00022 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_STARTING_NUM_RECORDS = 10;\par
00023 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_RECORDS_GROWTH_RATE = 2;\par
00024 \par
00029 {\cf17 static} int8_t resize_directory_records (directory *d);\par
00030 \par
00031 int8_t\par
00032 create_directory (directory *d)\par
00033 \{\par
00034   d->records = malloc ({\cf17 sizeof} (directory_record) * DIR_STARTING_NUM_RECORDS);\par
00035   {\cf19 if} (d->records == NULL)\par
00036     \{\par
00037       {\cf19 return} handle_malloc_error ({\cf22 "directory records."});\par
00038     \}\par
00039 \par
00040   d->size = DIR_STARTING_NUM_RECORDS;\par
00041   d->current_record = 0;\par
00042 \par
00043   {\cf19 for} ({\cf18 size_t} i = 0; i < DIR_STARTING_NUM_RECORDS; i++)\par
00044     \{\par
00045       d->records[i].file_identifier = NULL;\par
00046     \}\par
00047 \par
00048   {\cf19 return} 0;\par
00049 \}\par
00050 \par
00051 {\cf18 void}\par
00052 destroy_directory (directory *d)\par
00053 \{\par
00054   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00055     \{\par
00056       {\cf19 if} (d->records[i].file_identifier == NULL)\par
00057         {\cf19 continue};\par
00058 \par
00059       free (d->records[i].file_identifier);\par
00060       d->records[i].file_identifier = NULL;\par
00061     \}\par
00062 \par
00063   free (d->records);\par
00064   d->records = NULL;\par
00065 \}\par
00066 \par
00067 int8_t\par
00068 add_record_to_directory (directory *d, directory_record *r)\par
00069 \{\par
00070   {\cf19 if} (d->current_record >= d->size)\par
00071     \{\par
00072       {\cf19 if} (resize_directory_records (d) != 0)\par
00073         {\cf19 return} -1;\par
00074     \}\par
00075 \par
00076   d->records[d->current_record] = *r;\par
00077   d->current_record++;\par
00078   {\cf19 return} 0;\par
00079 \}\par
00080 \par
00081 {\cf18 void}\par
00082 print_directory_record (directory_record *r)\par
00083 \{\par
00084   printf ({\cf22 "Record length: %02X\\n"}, r->record_length);\par
00085   printf ({\cf22 "Extended attribute record length: %02X\\n"},\par
00086           r->extended_attribute_record_length);\par
00087   printf ({\cf22 "Location of extent: %08X\\n"}, r->location_of_extent);\par
00088   printf ({\cf22 "Data length: %08X\\n"}, r->data_length);\par
00089   print_dir_datetime (r->recording_datetime);\par
00090   print_file_flags (&r->file_flags);\par
00091   printf ({\cf22 "File unit size: %02X\\n"}, r->file_unit_size);\par
00092   printf ({\cf22 "Interleave gap size: %02X\\n"}, r->interleave_gap_size);\par
00093   printf ({\cf22 "Volume sequence number: %04X\\n"}, r->volume_sequence_number);\par
00094   printf ({\cf22 "File identifier length: %02X\\n"}, r->file_identifier_length);\par
00095   printf ({\cf22 "File identifier: %s\\n"}, r->file_identifier);\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 resize_directory_records (directory *d)\par
00100 \{\par
00101   {\cf18 size_t} new_size = d->size * DIR_RECORDS_GROWTH_RATE;\par
00102   directory_record *new_records = (directory_record *)realloc (\par
00103       d->records, sizeof (directory_record) * new_size);\par
00104   {\cf19 if} (new_records == NULL)\par
00105     \{\par
00106       destroy_directory (d);\par
00107       {\cf19 return} handle_realloc_error ({\cf22 "records"}, d->size, new_size);\par
00108     \}\par
00109 \par
00110   d->records = new_records;\par
00111   {\cf19 for} ({\cf18 size_t} i = d->size; i < new_size; i++)\par
00112     \{\par
00113       d->records[i].file_identifier = NULL;\par
00114     \}\par
00115 \par
00116   d->size = new_size;\par
00117   {\cf19 return} 0;\par
00118 \}\par
00119 \par
00120 {\cf18 void}\par
00121 print_directory (directory *d)\par
00122 \{\par
00123   printf ({\cf22 "Number of records: %zu\\n"}, d->current_record + 1);\par
00124   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00125     \{\par
00126       printf ({\cf22 "!!! Record #%zu\\n"}, i + 1);\par
00127       print_directory_record (&d->records[i]);\par
00128       puts ({\cf22 "-------------------------------"});\par
00129     \}\par
00130 \}\par
00131 \par
00132 int8_t\par
00133 process_directory (FILE *fptr, directory *d)\par
00134 \{\par
00135   uint8_t single_byte;\par
00136   {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00137     {\cf19 return} HH_FREAD_ERROR;\par
00138 \par
00139   {\cf19 do}\par
00140     \{\par
00141       directory_record dr;\par
00142       dr.record_length = single_byte;\par
00143 \par
00144       {\cf19 if} ((read_single_uint8 (fptr, &dr.extended_attribute_record_length) != 0)\par
00145           || (read_both_endian_data_uint32 (fptr, &dr.location_of_extent) != 0)\par
00146           || (read_both_endian_data_uint32 (fptr, &dr.data_length) != 0)\par
00147           || (read_dir_datetime (fptr, &dr.recording_datetime) != 0))\par
00148         \{\par
00149           {\cf19 return} HH_FREAD_ERROR;\par
00150         \}\par
00151 \par
00152       dr.file_flags = create_file_flags ();\par
00153       read_file_flags (fptr, &dr.file_flags);\par
00154 \par
00155       {\cf19 if} (read_single_uint8 (fptr, &dr.file_unit_size) != 0\par
00156           || read_single_uint8 (fptr, &dr.interleave_gap_size) != 0)\par
00157         \{\par
00158           {\cf19 return} HH_FREAD_ERROR;\par
00159         \}\par
00160 \par
00161       {\cf19 if} (read_both_endian_data_uint16 (fptr, &dr.volume_sequence_number) != 0)\par
00162         {\cf19 return} HH_FREAD_ERROR;\par
00163 \par
00164       {\cf19 if} (read_single_uint8 (fptr, &dr.file_identifier_length) != 0)\par
00165         \{\par
00166           {\cf19 return} HH_FREAD_ERROR;\par
00167         \}\par
00168       dr.file_identifier_length++;\par
00169 \par
00170       dr.file_identifier\par
00171           = ({\cf18 char} *)calloc (dr.file_identifier_length, sizeof ({\cf18 char}));\par
00172       {\cf18 size_t} bytes_read = fread (dr.file_identifier, sizeof ({\cf18 char}),\par
00173                                  dr.file_identifier_length - 1, fptr);\par
00174       dr.file_identifier[dr.file_identifier_length - 1] = {\cf23 '\\0'};\par
00175       {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1))\par
00176         \{\par
00177           handle_fread_error (bytes_read,\par
00178                               {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1));\par
00179           {\cf19 return} HH_FREAD_ERROR;\par
00180         \}\par
00181 \par
00182       {\cf19 if} (add_record_to_directory (d, &dr) != 0)\par
00183         \{\par
00184           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00185         \}\par
00186 \par
00187       {\cf19 if} (dr.file_identifier_length % 2 != 0) {\cf20 // handle padding field}\par
00188         fseek (fptr, 1, SEEK_CUR);\par
00189 \par
00190       {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00191         {\cf19 return} HH_FREAD_ERROR;\par
00192     \}\par
00193   {\cf19 while} (single_byte != 0);\par
00194 \par
00195   {\cf19 return} 0;\par
00196 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/errors.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HH_ERRORS {\b handle_fopen_error} (char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HH_ERRORS {\b handle_fread_error} (size_t actual, size_t expected_bytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_unknown_command_line_argument_error} (char *arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HH_ERRORS {\b handle_calloc_error} (size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HH_ERRORS {\b handle_realloc_error} (const char *arr_name, size_t old_size, size_t new_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HH_ERRORS {\b handle_malloc_error} (const char *obj_name)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CALLOC_FAILED_ERR_MSG_FMT} = "Unable to calloc string of size %zu."\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b FOPEN_FAILED_ERR_MSG_FMT} = "Unable to open output file, %s."\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_calloc_error\:errors.c}
{\xe \v errors.c\:handle_calloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HH_ERRORS handle_calloc_error (size_t size)}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b errors.c}.}\par
}
{\xe \v handle_fopen_error\:errors.c}
{\xe \v errors.c\:handle_fopen_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HH_ERRORS handle_fopen_error (char * filename)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b errors.c}.}\par
}
{\xe \v handle_fread_error\:errors.c}
{\xe \v errors.c\:handle_fread_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HH_ERRORS handle_fread_error (size_t actual, size_t expected_bytes)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b errors.c}.}\par
}
{\xe \v handle_malloc_error\:errors.c}
{\xe \v errors.c\:handle_malloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HH_ERRORS handle_malloc_error (const char * obj_name)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b errors.c}.}\par
}
{\xe \v handle_realloc_error\:errors.c}
{\xe \v errors.c\:handle_realloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HH_ERRORS handle_realloc_error (const char * arr_name, size_t old_size, size_t new_size)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b errors.c}.}\par
}
{\xe \v handle_unknown_command_line_argument_error\:errors.c}
{\xe \v errors.c\:handle_unknown_command_line_argument_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_unknown_command_line_argument_error (char * arg)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b errors.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CALLOC_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:CALLOC_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CALLOC_FAILED_ERR_MSG_FMT = "Unable to calloc string of size %zu."}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b errors.c}.}\par
}
{\xe \v FOPEN_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:FOPEN_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* FOPEN_FAILED_ERR_MSG_FMT = "Unable to open output file, %s."}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b errors.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
errors.c\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "errors.h"}\par
00002 {\cf21 #include "log.h"}\par
00003 \par
00004 {\cf21 #include <stdbool.h>}\par
00005 {\cf21 #include <stdlib.h>}\par
00006 \par
00007 {\cf17 const} {\cf18 char} *CALLOC_FAILED_ERR_MSG_FMT = {\cf22 "Unable to calloc string of size %zu."};\par
00008 {\cf17 const} {\cf18 char} *FOPEN_FAILED_ERR_MSG_FMT = {\cf22 "Unable to open output file, %s."};\par
00009 \par
00010 HH_ERRORS\par
00011 handle_fopen_error ({\cf18 char} *filename)\par
00012 \{\par
00013   hh_log (HH_LOG_ERROR, {\cf22 "Unable to open file, %s."}, filename);\par
00014   {\cf19 return} HH_FOPEN_ERROR;\par
00015 \}\par
00016 \par
00017 HH_ERRORS\par
00018 handle_fread_error ({\cf18 size_t} actual, {\cf18 size_t} expected_bytes)\par
00019 \{\par
00020   hh_log (HH_LOG_ERROR, {\cf22 "Only read %zu byte(s), expected %zu."}, actual,\par
00021           expected_bytes);\par
00022   {\cf19 return} HH_FREAD_ERROR;\par
00023 \}\par
00024 \par
00025 {\cf18 void}\par
00026 handle_unknown_command_line_argument_error ({\cf18 char} *arg)\par
00027 \{\par
00028   {\cf18 bool} windows;\par
00029 {\cf21 #ifdef _WIN32}\par
00030   windows = {\cf17 true};\par
00031 {\cf21 #else}\par
00032   windows = {\cf17 false};\par
00033 {\cf21 #endif}\par
00034   hh_log (HH_LOG_ERROR,\par
00035           {\cf22 "Unknown command-line argument, %s. Run %s --help for a list of "}\par
00036           {\cf22 "command-line arguments."},\par
00037           arg, !windows ? {\cf22 "./HarvesterHarvester"} : {\cf22 "HarvesterHarvester.exe"});\par
00038   exit (1);\par
00039 \}\par
00040 \par
00041 HH_ERRORS\par
00042 handle_calloc_error ({\cf18 size_t} size)\par
00043 \{\par
00044   hh_log (HH_LOG_ERROR, CALLOC_FAILED_ERR_MSG_FMT, size);\par
00045   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00046 \}\par
00047 \par
00048 HH_ERRORS\par
00049 handle_realloc_error ({\cf17 const} {\cf18 char} *arr_name, {\cf18 size_t} old_size, {\cf18 size_t} new_size)\par
00050 \{\par
00051   hh_log (HH_LOG_ERROR,\par
00052           {\cf22 "Failed to reallocate array, %s, from size %zu to %zu."}, arr_name,\par
00053           old_size, new_size);\par
00054   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00055 \}\par
00056 \par
00057 HH_ERRORS\par
00058 handle_malloc_error ({\cf17 const} {\cf18 char} *obj_name)\par
00059 \{\par
00060   hh_log (HH_LOG_ERROR, {\cf22 "Failed to allocate memory for %s."}, obj_name);\par
00061   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/extractor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "extractor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "output.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_dir_record} (FILE *fptr, struct directory_record *dr, const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_directory} (FILE *fptr, const uint16_t block_size, const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directories_and_extract_data_from_path_file} (FILE *fptr, uint16_t block_size, path_table *pt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_idx_entry} (FILE *fptr, index_entry *idx, const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_index_file} (index_file *idx, const char *idx_path, const char *dat_path)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_directories_and_extract_data_from_path_file\:extractor.c}
{\xe \v extractor.c\:create_directories_and_extract_data_from_path_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directories_and_extract_data_from_path_file (FILE * fptr, uint16_t block_size, path_table * pt)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b extractor.c}.}\par
}
{\xe \v extract_directory\:extractor.c}
{\xe \v extractor.c\:extract_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_directory (FILE * fptr, const uint16_t block_size, const char * path)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_dir_record\:extractor.c}
{\xe \v extractor.c\:extract_file_using_dir_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_dir_record (FILE * fptr, struct directory_record * dr, const char * path)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 file_identifier}  terminates with a {\f2 ;}  character followed by the file ID number in ASCII coded decimal ({\f2 1} ). See: {\f2 https://wiki.osdev.org/ISO_9660#Directories}\par
Just use the default/existing filename. It'll be incorrect, but probably not worth stoping execution over. Users could just manually remove the {\f2 ;1}  part; the data itself should be fine.\par
}{
Definition at line {\b 27} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_idx_entry\:extractor.c}
{\xe \v extractor.c\:extract_file_using_idx_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_idx_entry (FILE * fptr, index_entry * idx, const char * path)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b extractor.c}.}\par
}
{\xe \v extract_index_file\:extractor.c}
{\xe \v extractor.c\:extract_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_index_file (index_file * idx, const char * idx_path, const char * dat_path)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gives you the {\f2 OP_OUTPUT_DIR/DISK#/}  part of the path. 10 = len("INDEX.001")\par
}{
Definition at line {\b 223} of file {\b extractor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
extractor.c\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "extractor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 {\cf21 #include "output.h"}\par
00020 {\cf21 #include "utils.h"}\par
00021 \par
00022 {\cf21 #include <stdint.h>}\par
00023 {\cf21 #include <stdio.h>}\par
00024 {\cf21 #include <string.h>}\par
00025 \par
00026 int8_t\par
00027 extract_file_using_dir_record (FILE *fptr, {\cf17 struct} directory_record *dr,\par
00028                                {\cf17 const} {\cf18 char} *path)\par
00029 \{\par
00035   {\cf18 char} *actual_filename = strtok (dr->file_identifier, ({\cf17 const} {\cf18 char} *){\cf22 ";"});\par
00036   {\cf19 if} (actual_filename == NULL)\par
00037     \{\par
00044       actual_filename = dr->file_identifier;\par
00045     \}\par
00046 \par
00047   hh_log (HH_LOG_INFO, {\cf22 "Extracting file: %s"}, actual_filename);\par
00048 \par
00049   {\cf20 // +1 for the null terminator, +1 for `/` between dir and filename}\par
00050   {\cf18 size_t} filename_length = strlen (path) + strlen (actual_filename) + 2;\par
00051 \par
00052   {\cf18 char} *output_filename = ({\cf18 char} *)calloc (filename_length, {\cf17 sizeof} ({\cf18 char}));\par
00053   {\cf19 if} (output_filename == NULL)\par
00054     \{\par
00055       {\cf19 return} handle_calloc_error (filename_length);\par
00056     \}\par
00057 \par
00058   strcpy (output_filename, path);\par
00059   strcat (output_filename, &OP_PATH_SEPARATOR);\par
00060   strcat (output_filename, actual_filename);\par
00061 \par
00062   FILE *output_file = fopen (output_filename, {\cf22 "wb"});\par
00063   {\cf19 if} (output_file == NULL)\par
00064     \{\par
00065       handle_fopen_error (output_filename);\par
00066       free (output_filename);\par
00067       {\cf19 return} HH_FOPEN_ERROR;\par
00068     \}\par
00069 \par
00070   {\cf20 // `j` must be in hex, otherwise `data_length` can be treated as an int value}\par
00071   {\cf19 for} (uint32_t j = 0x0; j < dr->data_length; j++)\par
00072     \{\par
00073       uint8_t byte;\par
00074       {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00075         \{\par
00076           fclose (output_file);\par
00077           free (output_filename);\par
00078           {\cf19 return} HH_FREAD_ERROR;\par
00079         \}\par
00080 \par
00081       fwrite (&{\cf18 byte}, {\cf17 sizeof} (uint8_t), 1, output_file);\par
00082     \}\par
00083 \par
00084   fclose (output_file);\par
00085   free (output_filename);\par
00086   {\cf19 return} 0;\par
00087 \}\par
00088 \par
00089 int8_t\par
00090 extract_directory (FILE *fptr, {\cf17 const} uint16_t block_size, {\cf17 const} {\cf18 char} *path)\par
00091 \{\par
00092   directory dir;\par
00093   create_directory (&dir);\par
00094   process_directory (fptr, &dir);\par
00095 \par
00096   hh_log (HH_LOG_INFO, {\cf22 "Extracting directory: %s"}, path);\par
00097 \par
00098   {\cf19 for} ({\cf18 size_t} i = 0x0; i < dir.current_record; i++)\par
00099     \{\par
00100       directory_record curr_file = dir.records[i];\par
00101 \par
00102       {\cf19 if} (curr_file.file_flags.subdirectory)\par
00103         \{\par
00104           {\cf19 continue};\par
00105         \}\par
00106       {\cf19 else} {\cf19 if} (OP_DEBUG_MODE\par
00107                && curr_file.data_length > OP_DEBUG_FILE_SIZE_LIMIT)\par
00108         \{\par
00109           hh_log (HH_LOG_INFO, {\cf22 "[DEBUG_MODE]Skipping file, %s."},\par
00110                   curr_file.file_identifier);\par
00111           {\cf19 continue};\par
00112         \}\par
00113 \par
00114       fseek (fptr, curr_file.location_of_extent * block_size, SEEK_SET);\par
00115 \par
00116       {\cf19 if} (extract_file_using_dir_record (fptr, &curr_file, path) != 0)\par
00117         \{\par
00118           destroy_directory (&dir);\par
00119           {\cf19 return} -1;\par
00120         \}\par
00121     \}\par
00122 \par
00123   destroy_directory (&dir);\par
00124   {\cf19 return} 0;\par
00125 \}\par
00126 \par
00127 int8_t\par
00128 create_directories_and_extract_data_from_path_file (FILE *fptr,\par
00129                                                     uint16_t block_size,\par
00130                                                     path_table *pt)\par
00131 \{\par
00132   {\cf19 for} ({\cf18 size_t} i = pt->current_entry - 1; i > 0; --i)\par
00133     \{\par
00134       path_table_entry curr_dir = pt->entries[i];\par
00135       path_table_entry target_dir = curr_dir;\par
00136 \par
00137       {\cf20 // supports 10 levels of directories which is probably overkill.}\par
00138       {\cf17 const} uint32_t PATH_MAX_LEN\par
00139           = ((curr_dir.directory_identifier_length + 1) * 10)\par
00140             + (strlen (OP_OUTPUT_DIR) + 1) + (strlen (CURRENT_DISK_NAME) + 1)\par
00141             + 1;\par
00142       {\cf18 char} *path = calloc (PATH_MAX_LEN, {\cf17 sizeof} ({\cf18 char}));\par
00143       {\cf19 if} (path == NULL)\par
00144         \{\par
00145           {\cf19 return} handle_calloc_error (PATH_MAX_LEN);\par
00146         \}\par
00147 \par
00148       strcat (path, curr_dir.directory_identifier);\par
00149 \par
00150       {\cf19 do}\par
00151         \{\par
00152           uint16_t index\par
00153               = change_endianness_uint16 (curr_dir.parent_directory_number);\par
00154 \par
00155           {\cf20 // parent_directory_number is 1-based}\par
00156           curr_dir = pt->entries[index - 1];\par
00157 \par
00158           {\cf19 if} (prepend_path_string (path,\par
00159                                    ({\cf17 const} {\cf18 char} *)curr_dir.directory_identifier)\par
00160               != 0)\par
00161             \{\par
00162               free (path);\par
00163               {\cf19 return} -1;\par
00164             \}\par
00165         \}\par
00166       {\cf19 while} (curr_dir.parent_directory_number > 0x0100);\par
00167 \par
00168       {\cf19 if} (create_output_directory (path) != 0)\par
00169         {\cf19 return} -1;\par
00170 \par
00171       fseek (fptr, block_size * target_dir.location_of_extent, SEEK_SET);\par
00172 \par
00173       {\cf19 if} (extract_directory (fptr, block_size, path) != 0)\par
00174         {\cf19 return} -1;\par
00175 \par
00176       free (path);\par
00177     \}\par
00178 \par
00179   {\cf19 return} 0;\par
00180 \}\par
00181 \par
00182 int8_t\par
00183 extract_file_using_idx_entry (FILE *fptr, index_entry *idx, {\cf17 const} {\cf18 char} *path)\par
00184 \{\par
00185   hh_log (HH_LOG_INFO, {\cf22 "Extracting file: %s"}, path);\par
00186 \par
00187   FILE *output_file = fopen (path, {\cf22 "wb"});\par
00188   {\cf19 if} (output_file == NULL)\par
00189     \{\par
00190       {\cf18 char} tmp[256] = \{ 0 \};\par
00191       strncpy (tmp, path, strlen (path) - strlen (idx->filename));\par
00192 \par
00193       {\cf19 if} (create_new_output_directory (tmp) != 0)\par
00194         {\cf19 return} -1;\par
00195 \par
00196       output_file = fopen (path, {\cf22 "wb"});\par
00197       {\cf19 if} (output_file == NULL)\par
00198         \{\par
00199           hh_log (HH_LOG_ERROR, {\cf22 "Error opening output file, %s."}, path);\par
00200           {\cf19 return} HH_FOPEN_ERROR;\par
00201         \}\par
00202     \}\par
00203 \par
00204   fseek (fptr, idx->start, SEEK_SET);\par
00205 \par
00206   {\cf19 for} (uint32_t i = 0x0; i < idx->size; i++)\par
00207     \{\par
00208       uint8_t byte;\par
00209       {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00210         \{\par
00211           fclose (output_file);\par
00212           {\cf19 return} -1;\par
00213         \}\par
00214 \par
00215       fwrite (&{\cf18 byte}, {\cf17 sizeof} (uint8_t), 1, output_file);\par
00216     \}\par
00217 \par
00218   fclose (output_file);\par
00219   {\cf19 return} 0;\par
00220 \}\par
00221 \par
00222 int8_t\par
00223 extract_index_file (index_file *idx, {\cf17 const} {\cf18 char} *idx_path,\par
00224                     {\cf17 const} {\cf18 char} *dat_path)\par
00225 \{\par
00226   FILE *dat_file = fopen (dat_path, {\cf22 "rb"});\par
00227   {\cf19 if} (dat_file == NULL)\par
00228     \{\par
00229       {\cf19 return} handle_fopen_error (({\cf18 char} *)dat_path);\par
00230     \}\par
00231 \par
00232   {\cf19 for} ({\cf18 size_t} i = 0; i < idx->current_index; i++)\par
00233     \{\par
00234       {\cf18 char} output_path[256] = \{ 0 \};\par
00235 \par
00240       strncpy (output_path, idx_path, strlen (idx_path) - 10);\par
00241       strcat (output_path, idx->indicies[i].full_path);\par
00242 \par
00243       {\cf19 if} (extract_file_using_idx_entry (dat_file, &idx->indicies[i],\par
00244                                         output_path)\par
00245           != 0)\par
00246         \{\par
00247           fclose (dat_file);\par
00248           {\cf19 return} -1;\par
00249         \}\par
00250     \}\par
00251 \par
00252   fclose (dat_file);\par
00253   {\cf19 return} 0;\par
00254 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_flags.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "file_flags.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file_flags {\b create_file_flags} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_file_flags} (file_flags *ff)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_file_flags\:file_flags.c}
{\xe \v file_flags.c\:create_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
file_flags create_file_flags (void )}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b file_flags.c}.}\par
}
{\xe \v print_file_flags\:file_flags.c}
{\xe \v file_flags.c\:print_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_file_flags (file_flags * ff)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b file_flags.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags.c\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "file_flags.h"}\par
00015 \par
00016 {\cf21 #include <stdio.h>}\par
00017 \par
00018 file_flags\par
00019 create_file_flags ({\cf18 void})\par
00020 \{\par
00021   file_flags ff;\par
00022   ff.hidden = {\cf17 false};\par
00023   ff.subdirectory = {\cf17 false};\par
00024   ff.associated_file = {\cf17 false};\par
00025   ff.extended_attribute_record_contains_owner_and_group_permissions = {\cf17 false};\par
00026   ff.final_directory_record = {\cf17 false};\par
00027   {\cf19 return} ff;\par
00028 \}\par
00029 \par
00030 {\cf18 void}\par
00031 print_file_flags (file_flags *ff)\par
00032 \{\par
00033   printf ({\cf22 "\\tHidden: %d\\n"}, ff->hidden);\par
00034   printf ({\cf22 "\\tSubdirectory: %d\\n"}, ff->subdirectory);\par
00035   printf ({\cf22 "\\tAssociated file: %d\\n"}, ff->associated_file);\par
00036   printf (\par
00037       {\cf22 "\\tExtended attrib. record contains owner and group permissions: %d\\n"},\par
00038       ff->extended_attribute_record_contains_owner_and_group_permissions);\par
00039   printf ({\cf22 "\\tFinal directory record: %d\\n"}, ff->final_directory_record);\par
00040 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/hh.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "hh.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "extractor.h"}\par
{\f2 #include "index_file.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "path_table.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include "volume_descriptor.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b hh_setup_extractor} (FILE **fptr, char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b hh_process_DAT_file} (FILE *fptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b hh_batch_process_DAT_files} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b hh_process_internal_dat_files} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v hh_batch_process_DAT_files\:hh.c}
{\xe \v hh.c\:hh_batch_process_DAT_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t hh_batch_process_DAT_files (void )}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b hh.c}.}\par
}
{\xe \v hh_process_DAT_file\:hh.c}
{\xe \v hh.c\:hh_process_DAT_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t hh_process_DAT_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b hh.c}.}\par
}
{\xe \v hh_process_internal_dat_files\:hh.c}
{\xe \v hh.c\:hh_process_internal_dat_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t hh_process_internal_dat_files (void )}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b hh.c}.}\par
}
{\xe \v hh_setup_extractor\:hh.c}
{\xe \v hh.c\:hh_setup_extractor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t hh_setup_extractor (FILE ** fptr, char * filename)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b hh.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hh.c\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "hh.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "extractor.h"}\par
00018 {\cf21 #include "index_file.h"}\par
00019 {\cf21 #include "log.h"}\par
00020 {\cf21 #include "options.h"}\par
00021 {\cf21 #include "path_table.h"}\par
00022 {\cf21 #include "utils.h"}\par
00023 {\cf21 #include "volume_descriptor.h"}\par
00024 \par
00025 {\cf21 #include <stdbool.h>}\par
00026 {\cf21 #include <stdint.h>}\par
00027 {\cf21 #include <stdio.h>}\par
00028 {\cf21 #include <stdlib.h>}\par
00029 {\cf21 #include <string.h>}\par
00030 {\cf21 #include <time.h>}\par
00031 \par
00032 {\cf21 #ifdef _WIN32}\par
00033 {\cf21 #include <windows.h>}\par
00034 {\cf21 #else}\par
00035 {\cf21 #include <dirent.h>}\par
00036 {\cf21 #endif}\par
00037 \par
00038 int8_t\par
00039 hh_setup_extractor (FILE **fptr, {\cf18 char} *filename)\par
00040 \{\par
00041   *fptr = fopen (filename, {\cf22 "rb"});\par
00042   {\cf19 if} (*fptr == NULL)\par
00043     \{\par
00044       handle_fopen_error (filename);\par
00045       {\cf20 /*}\par
00046 {\cf20        * Need to explicitly return `HH_FOPEN_ERROR` here otherwise gcc}\par
00047 {\cf20        * complains}\par
00048 {\cf20        */}\par
00049       {\cf19 return} HH_FOPEN_ERROR;\par
00050     \}\par
00051 \par
00052 {\cf21 #ifdef _WIN32}\par
00053   OP_PATH_SEPARATOR = {\cf23 '\\\\'};\par
00054 {\cf21 #else}\par
00055   OP_PATH_SEPARATOR = {\cf23 '/'};\par
00056 {\cf21 #endif}\par
00057 \par
00058   {\cf19 return} 0;\par
00059 \}\par
00060 \par
00061 int8_t\par
00062 hh_process_DAT_file (FILE *fptr)\par
00063 \{\par
00064   {\cf20 /*}\par
00065 {\cf20    * First 32k (up to 0x8000) stores the `system area` of the disk.}\par
00066 {\cf20    * Unused by HARVEST.DAT, HARVEST3.DAT, HARVEST4.DAT.}\par
00067 {\cf20    * See: https://wiki.osdev.org/ISO_9660#System_Area}\par
00068 {\cf20    */}\par
00069   fseek (fptr, 0x8000, SEEK_SET);\par
00070 \par
00071   volume_descriptor vd;\par
00072   {\cf19 if} (process_volume_descriptor_header (fptr, &vd) != 0)\par
00073     {\cf19 return} -1;\par
00074 \par
00075   {\cf20 // Verify that this is a primary volume descriptor}\par
00076   {\cf19 if} (vd.type_code != 0x01)\par
00077     \{\par
00078       hh_log (HH_LOG_ERROR,\par
00079               {\cf22 "Unexpected volume descriptor type code. Expected 0x%02X, got "}\par
00080               {\cf22 "0x%02X."},\par
00081               0x01, vd.type_code);\par
00082       {\cf19 return} -1;\par
00083     \}\par
00084 \par
00085   {\cf19 if} (process_volume_descriptor_data (fptr, &vd.data) != 0)\par
00086     {\cf19 return} -1;\par
00087 \par
00088   {\cf18 size_t} current_disk_name_length = strcspn (vd.data.volume_identifier, {\cf22 " "});\par
00089   CURRENT_DISK_NAME = vd.data.volume_identifier;\par
00090   CURRENT_DISK_NAME[current_disk_name_length] = {\cf23 '\\0'};\par
00091 \par
00092   {\cf20 // TODO: print the volume descriptor header/data to some file/log.}\par
00093 \par
00094   {\cf20 // logical block size, in big endian form}\par
00095   {\cf17 const} uint16_t block_size_be\par
00096       = change_endianness_uint16 (vd.data.logical_block_size);\par
00097 \par
00098   {\cf20 // move to beginning of type-l path table}\par
00099   fseek (fptr, block_size_be * vd.data.type_l_path_table_location, SEEK_SET);\par
00100 \par
00101   path_table pt;\par
00102   {\cf19 if} (create_path_table (&pt) != 0)\par
00103     {\cf19 return} -1;\par
00104 \par
00105   {\cf19 if} (process_type_l_path_table (fptr, &pt) != 0)\par
00106     \{\par
00107       destroy_path_table (&pt);\par
00108       {\cf19 return} -1;\par
00109     \}\par
00110 \par
00111   {\cf19 if} (create_directories_and_extract_data_from_path_file (fptr, block_size_be,\par
00112                                                           &pt)\par
00113       != 0)\par
00114     \{\par
00115       destroy_path_table (&pt);\par
00116       {\cf19 return} -1;\par
00117     \}\par
00118 \par
00119   {\cf20 // handle root directory}\par
00120   fseek (fptr, block_size_be * pt.entries[0].location_of_extent, SEEK_SET);\par
00121 \par
00122   {\cf18 char} *path = calloc (strlen (OP_OUTPUT_DIR) + current_disk_name_length + 2,\par
00123                        {\cf17 sizeof} ({\cf18 char}));\par
00124   {\cf19 if} (path == NULL)\par
00125     \{\par
00126       destroy_path_table (&pt);\par
00127       {\cf19 return} handle_calloc_error (strlen (OP_OUTPUT_DIR)\par
00128                                   + current_disk_name_length + 2);\par
00129     \}\par
00130 \par
00131   strcpy (path, OP_OUTPUT_DIR);\par
00132   strcat (path, &OP_PATH_SEPARATOR);\par
00133   strcat (path, CURRENT_DISK_NAME);\par
00134 \par
00135   {\cf19 if} (extract_directory (fptr, block_size_be, path) != 0)\par
00136     \{\par
00137       free (path);\par
00138       destroy_path_table (&pt);\par
00139       {\cf19 return} -1;\par
00140     \}\par
00141 \par
00142   free (path);\par
00143   destroy_path_table (&pt);\par
00144   {\cf19 return} 0;\par
00145 \}\par
00146 \par
00147 int8_t\par
00148 hh_batch_process_DAT_files ({\cf18 void})\par
00149 \{\par
00150   {\cf17 const} {\cf18 char} *OPEN_INPUT_DIR_ERR_MSG_FMT\par
00151       = {\cf22 "ERROR: Error opening input directory, %s."};\par
00152   {\cf17 const} uint8_t DAT_FILENAME_LEN = strlen ({\cf22 "HARVESTX.DAT"});\par
00153   {\cf18 char} *filename;\par
00154   int8_t file_count = 0;\par
00155 \par
00156 {\cf21 #ifdef _WIN32}\par
00157   WIN32_FIND_DATAA file_data;\par
00158   HANDLE hFind;\par
00159   {\cf18 char} search_path[256];\par
00160   strcpy (search_path, OP_INPUT_DIR);\par
00161   strcat (search_path, {\cf22 "\\\\*"});\par
00162 \par
00163   hFind = FindFirstFileA (search_path, &file_data);\par
00164   {\cf19 if} (hFind == INVALID_HANDLE_VALUE)\par
00165     \{\par
00166       hh_log (HH_LOG_ERROR, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00167       {\cf19 return} -1;\par
00168     \}\par
00169 \par
00170   {\cf19 do}\par
00171     \{\par
00172       file_count++;\par
00173       {\cf19 if} (strcmp (file_data.cFileName, {\cf22 "."}) == 0\par
00174           || strcmp (file_data.cFileName, {\cf22 ".."}) == 0\par
00175           || !is_string_dat_file (file_data.cFileName))\par
00176         \{\par
00177           {\cf19 continue};\par
00178         \}\par
00179 \par
00180       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00181                          {\cf17 sizeof} ({\cf18 char}));\par
00182       {\cf19 if} (filename == NULL)\par
00183         \{\par
00184           {\cf19 return} handle_calloc_error (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN\par
00185                                       + 2);\par
00186         \}\par
00187 \par
00188       strcpy (filename, OP_INPUT_DIR);\par
00189       strcat (filename, &OP_PATH_SEPARATOR);\par
00190       strcat (filename, file_data.cFileName);\par
00191 \par
00192       FILE *fptr = NULL;\par
00193       {\cf19 if} (hh_setup_extractor (&fptr, filename) != 0)\par
00194         \{\par
00195           free (filename);\par
00196           FindClose (hFind);\par
00197           {\cf19 return} HH_FOPEN_ERROR;\par
00198         \}\par
00199 \par
00200       {\cf19 if} (hh_process_DAT_file (fptr) != 0)\par
00201         \{\par
00202           fclose (fptr);\par
00203           free (filename);\par
00204           FindClose (hFind);\par
00205           {\cf19 return} -1;\par
00206         \}\par
00207 \par
00208       fclose (fptr);\par
00209       free (filename);\par
00210     \}\par
00211   {\cf19 while} (FindNextFileA (hFind, &file_data) != 0);\par
00212 \par
00213   FindClose (hFind);\par
00214 {\cf21 #else}\par
00215   {\cf17 struct }dirent *entry;\par
00216   DIR *dir;\par
00217   dir = opendir (OP_INPUT_DIR);\par
00218   {\cf19 if} (dir == NULL)\par
00219     \{\par
00220       hh_log (HH_LOG_ERROR, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00221       {\cf19 return} -1;\par
00222     \}\par
00223 \par
00224   {\cf19 while} ((entry = readdir (dir)) != NULL)\par
00225     \{\par
00226       file_count++;\par
00227       {\cf19 if} (strcmp (entry->d_name, {\cf22 "."}) == 0 || strcmp (entry->d_name, {\cf22 ".."}) == 0\par
00228           || !is_string_dat_file (entry->d_name))\par
00229         \{\par
00230           {\cf19 continue};\par
00231         \}\par
00232 \par
00233       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00234                          {\cf17 sizeof} ({\cf18 char}));\par
00235       {\cf19 if} (filename == NULL)\par
00236         \{\par
00237           {\cf19 return} handle_calloc_error (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN\par
00238                                       + 2);\par
00239         \}\par
00240 \par
00241       strcpy (filename, OP_INPUT_DIR);\par
00242       strcat (filename, &OP_PATH_SEPARATOR);\par
00243       strcat (filename, entry->d_name);\par
00244 \par
00245       FILE *fptr = NULL;\par
00246       {\cf19 if} (hh_setup_extractor (&fptr, filename) != 0)\par
00247         \{\par
00248           free (filename);\par
00249           closedir (dir);\par
00250           {\cf19 return} HH_FOPEN_ERROR;\par
00251         \}\par
00252 \par
00253       {\cf19 if} (hh_process_DAT_file (fptr) != 0)\par
00254         \{\par
00255           fclose (fptr);\par
00256           free (filename);\par
00257           closedir (dir);\par
00258           {\cf19 return} -1;\par
00259         \}\par
00260 \par
00261       fclose (fptr);\par
00262       free (filename);\par
00263     \}\par
00264 \par
00265   closedir (dir);\par
00266 \par
00267 {\cf21 #endif}\par
00268   {\cf19 if} (file_count == 2) {\cf20 // 2 for `.` & `..`}\par
00269     {\cf19 return} -1;\par
00270 \par
00271   {\cf19 return} 0;\par
00272 \}\par
00273 \par
00274 int8_t\par
00275 hh_process_internal_dat_files ({\cf18 void})\par
00276 \{\par
00277   {\cf17 const} {\cf18 char} *interal_paths = {\cf22 "internal-dat-file-paths.txt"};\par
00278   FILE *table = fopen (interal_paths, {\cf22 "rb"});\par
00279   {\cf19 if} (table == NULL)\par
00280     \{\par
00281       {\cf19 return} handle_fopen_error (({\cf18 char} *)interal_paths);\par
00282     \}\par
00283 \par
00284   {\cf19 while} (!peek_eof (table))\par
00285     \{\par
00286       {\cf20 // TODO: convert as many malloc'd strings to char arrays as possible.}\par
00287       {\cf18 char} index_file_path[256] = \{ 0 \};\par
00288       build_path_string_from_file (table, index_file_path);\par
00289 \par
00290       FILE *fptr = NULL;\par
00291       {\cf19 if} (hh_setup_extractor (&fptr, index_file_path) != 0)\par
00292         \{\par
00293           hh_log (HH_LOG_WARNING, {\cf22 "Skipping..."});\par
00294 \par
00295           {\cf20 // Skip next line}\par
00296           build_path_string_from_file (table, index_file_path);\par
00297 \par
00298           {\cf19 continue};\par
00299         \}\par
00300 \par
00301       index_file idx_file;\par
00302       {\cf19 if} (create_index_file (&idx_file) != 0)\par
00303         \{\par
00304           fclose (fptr);\par
00305           fclose (table);\par
00306           {\cf19 return} -1;\par
00307         \}\par
00308 \par
00309       hh_log (HH_LOG_INFO, {\cf22 "Processing index file: %s"}, index_file_path);\par
00310       {\cf19 if} (process_index_file (fptr, &idx_file) != 0)\par
00311         \{\par
00312           destroy_index_file (&idx_file);\par
00313           fclose (table);\par
00314           fclose (fptr);\par
00315           {\cf19 return} -1;\par
00316         \}\par
00317       fclose (fptr);\par
00318 \par
00319       {\cf18 char} dat_file_path[256] = \{ 0 \};\par
00320       build_path_string_from_file (table, dat_file_path);\par
00321 \par
00322       {\cf19 if} (extract_index_file (&idx_file, index_file_path, dat_file_path) != 0)\par
00323         \{\par
00324           destroy_index_file (&idx_file);\par
00325           {\cf19 return} -1;\par
00326         \}\par
00327 \par
00328       destroy_index_file (&idx_file);\par
00329     \}\par
00330 \par
00331   fclose (table);\par
00332   {\cf19 return} 0;\par
00333 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/index_file.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "index_file.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_indicies} (index_file *idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 index_file} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_index_file} (index_file *i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b destroy_index_file} (index_file *i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_index_file} (FILE *fptr, index_file *idxf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_index_entry} (index_entry *idxe)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_entry_to_index_file} (index_file *file, index_entry *entry)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_STARTING_NUM_INDICIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_index_file\:index_file.c}
{\xe \v index_file.c\:add_entry_to_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_index_file (index_file * file, index_entry * entry)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b index_file.c}.}\par
}
{\xe \v create_index_file\:index_file.c}
{\xe \v index_file.c\:create_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_index_file (index_file * i)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b index_file.c}.}\par
}
{\xe \v destroy_index_file\:index_file.c}
{\xe \v index_file.c\:destroy_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t destroy_index_file (index_file * i)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b index_file.c}.}\par
}
{\xe \v print_index_entry\:index_file.c}
{\xe \v index_file.c\:print_index_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_index_entry (index_entry * idxe)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b index_file.c}.}\par
}
{\xe \v process_index_file\:index_file.c}
{\xe \v index_file.c\:process_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_index_file (FILE * fptr, index_file * idxf)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every entry is 0x94 bytes apart, the part we're most concerned about is the last 16 bytes. Currently treating unknown data in between as junk. If you have any idea what this data might be used for, please feel free to make changes.\par
}{
Definition at line {\b 56} of file {\b index_file.c}.}\par
}
{\xe \v resize_indicies\:index_file.c}
{\xe \v index_file.c\:resize_indicies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_indicies (index_file * idx){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 index_file} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 153} of file {\b index_file.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDX_RECORDS_GROWTH_RATE\:index_file.c}
{\xe \v index_file.c\:IDX_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b index_file.c}.}\par
}
{\xe \v IDX_STARTING_NUM_INDICIES\:index_file.c}
{\xe \v index_file.c\:IDX_STARTING_NUM_INDICIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_STARTING_NUM_INDICIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b index_file.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file.c\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "index_file.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 {\cf21 #include "utils.h"}\par
00020 \par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 \par
00024 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_STARTING_NUM_INDICIES = 10;\par
00025 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_RECORDS_GROWTH_RATE = 2;\par
00026 \par
00031 {\cf17 static} int8_t resize_indicies (index_file *idx);\par
00032 \par
00033 int8_t\par
00034 create_index_file (index_file *i)\par
00035 \{\par
00036   i->indicies = malloc (IDX_STARTING_NUM_INDICIES * {\cf17 sizeof} (index_entry));\par
00037   {\cf19 if} (i->indicies == NULL)\par
00038     \{\par
00039       {\cf19 return} handle_malloc_error ({\cf22 "index file indicies."});\par
00040     \}\par
00041 \par
00042   i->size = IDX_STARTING_NUM_INDICIES;\par
00043   i->current_index = 0;\par
00044 \par
00045   {\cf19 return} 0;\par
00046 \}\par
00047 \par
00048 int8_t\par
00049 destroy_index_file (index_file *i)\par
00050 \{\par
00051   free (i->indicies);\par
00052   {\cf19 return} 0;\par
00053 \}\par
00054 \par
00055 int8_t\par
00056 process_index_file (FILE *fptr, index_file *idxf)\par
00057 \{\par
00058   {\cf19 while} (!peek_eof (fptr))\par
00059     \{\par
00060       index_entry entry;\par
00061       entry.entry_start = ftell (fptr);\par
00062 \par
00063       fseek (fptr, 0x5, SEEK_CUR); {\cf20 // skip `XFLE#`}\par
00064 \par
00065       {\cf19 if} (!peek_char_is (fptr, {\cf23 ':'}))\par
00066         \{\par
00067           hh_log (HH_LOG_ERROR,\par
00068                   {\cf22 "Unexpected character in index file. Aborting processing."});\par
00069           {\cf19 return} -1;\par
00070         \}\par
00071 \par
00072       {\cf19 if} (read_string (fptr, entry.full_path, (uint8_t)FULL_PATH_MAX_LEN) != 0)\par
00073         {\cf19 return} HH_FREAD_ERROR;\par
00074 \par
00075       uint8_t len = strlen (entry.full_path);\par
00076       {\cf18 char} *last_word = entry.full_path;\par
00077       {\cf19 for} (uint8_t i = 0; i < len; i++)\par
00078         \{\par
00079           {\cf19 if} (entry.full_path[i] == {\cf23 '\\\\'})\par
00080             \{\par
00081               last_word = entry.full_path + i + 1;\par
00082               entry.full_path[i] = OP_PATH_SEPARATOR;\par
00083             \}\par
00084         \}\par
00085       strcpy (entry.filename, last_word);\par
00086 \par
00093       fseek (fptr, entry.entry_start + (0x94 - 0x10), SEEK_SET);\par
00094 \par
00095       {\cf20 /* clang-format off */}\par
00096       {\cf19 if} ((read_little_endian_data_uint32_t (fptr, &entry.start) != 0)\par
00097           || (read_little_endian_data_uint32_t (fptr, &entry.size) != 0))\par
00098         \{\par
00099           {\cf19 return} HH_FREAD_ERROR;\par
00100         \}\par
00101       {\cf20 /* clang-format on */}\par
00102 \par
00103       fseek (fptr, 0x4, SEEK_CUR); {\cf20 // Skip zeros}\par
00104 \par
00105       {\cf20 // Very unnecessary, but we might as well double check our data}\par
00106       uint32_t value;\par
00107       {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00108         {\cf19 return} HH_FREAD_ERROR;\par
00109 \par
00110       {\cf19 if} (entry.size != value)\par
00111         \{\par
00112           hh_log (HH_LOG_ERROR, {\cf22 "Expected 0x%08X, got 0x%08X."}, entry.size,\par
00113                   value);\par
00114           {\cf19 return} -1;\par
00115         \}\par
00116 \par
00117       {\cf19 if} (add_entry_to_index_file (idxf, &entry) != 0)\par
00118         \{\par
00119           {\cf19 return} -1;\par
00120         \}\par
00121     \}\par
00122 \par
00123   {\cf19 return} 0;\par
00124 \}\par
00125 \par
00126 {\cf18 void}\par
00127 print_index_entry (index_entry *idxe)\par
00128 \{\par
00129   printf ({\cf22 "Entry start: %08X\\n"}, idxe->entry_start);\par
00130   printf ({\cf22 "Full path: %s\\n"}, idxe->full_path);\par
00131   printf ({\cf22 "Filename: %s\\n"}, idxe->filename);\par
00132   printf ({\cf22 "File start: %08X\\n"}, idxe->start);\par
00133   printf ({\cf22 "File size: %08X\\n"}, idxe->size);\par
00134 \}\par
00135 \par
00136 int8_t\par
00137 add_entry_to_index_file (index_file *file, index_entry *entry)\par
00138 \{\par
00139   {\cf19 if} (file->current_index >= file->size)\par
00140     \{\par
00141       {\cf19 if} (resize_indicies (file) != 0)\par
00142         \{\par
00143           {\cf19 return} -1;\par
00144         \}\par
00145     \}\par
00146 \par
00147   file->indicies[file->current_index] = *entry;\par
00148   file->current_index++;\par
00149   {\cf19 return} 0;\par
00150 \}\par
00151 \par
00152 int8_t\par
00153 resize_indicies (index_file *idx)\par
00154 \{\par
00155   {\cf18 size_t} new_size = idx->size * IDX_RECORDS_GROWTH_RATE;\par
00156   index_entry *new_indicies = (index_entry *)realloc (\par
00157       idx->indicies, new_size * sizeof (index_entry));\par
00158   {\cf19 if} (new_indicies == NULL)\par
00159     \{\par
00160       destroy_index_file (idx);\par
00161       {\cf19 return} handle_realloc_error ({\cf22 "indicies"}, idx->size, new_size);\par
00162     \}\par
00163 \par
00164   idx->indicies = new_indicies;\par
00165   idx->size = new_size;\par
00166   {\cf19 return} 0;\par
00167 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "log.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BYTES_TO_READ}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_hex_data} (unsigned char *buffer, const uint8_t BUFFER_LEN)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_some_data_from_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hh_log} (hh_log_level lvl, const char *fmt,...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BYTES_TO_READ\:log.c}
{\xe \v log.c\:BYTES_TO_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BYTES_TO_READ\~ 32}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b log.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v hh_log\:log.c}
{\xe \v log.c\:hh_log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void hh_log (hh_log_level lvl, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b log.c}.}\par
}
{\xe \v print_hex_data\:log.c}
{\xe \v log.c\:print_hex_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_hex_data (unsigned char * buffer, const uint8_t BUFFER_LEN)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Formats said data to add spaces between bytes, tabs after after every four bytes, and a new line after every 16 bytes.\par
TODO: These values are currently hardcoded in, but they likely should be moved to options.h in the future. \par
}{
Definition at line {\b 29} of file {\b log.c}.}\par
}
{\xe \v print_some_data_from_file\:log.c}
{\xe \v log.c\:print_some_data_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_some_data_from_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }}\par
{
Definition at line {\b 53} of file {\b log.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
log.c\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "log.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 \par
00017 {\cf21 #include <stdarg.h>}\par
00018 {\cf21 #include <stdio.h>}\par
00019 \par
00028 {\cf18 void}\par
00029 print_hex_data ({\cf18 unsigned} {\cf18 char} *buffer, {\cf17 const} uint8_t BUFFER_LEN)\par
00030 \{\par
00031   {\cf19 for} (uint8_t i = 0; i < BUFFER_LEN; i++)\par
00032     \{\par
00033       printf ({\cf22 " %02x"}, buffer[i]);\par
00034       {\cf19 if} ((i != 0) && (i % 4 == 3))\par
00035         \{\par
00036           printf ({\cf22 "\\t"});\par
00037         \}\par
00038       {\cf19 if} ((i != 0) && (i % 16 == 15))\par
00039         \{\par
00040           puts ({\cf22 ""});\par
00041         \}\par
00042     \}\par
00043   puts ({\cf22 ""});\par
00044 \}\par
00045 \par
00046 {\cf21 #define BYTES_TO_READ 32}\par
00052 {\cf18 void}\par
00053 print_some_data_from_file (FILE *fptr)\par
00054 \{\par
00055   {\cf18 unsigned} {\cf18 char} buffer[BYTES_TO_READ];\par
00056   {\cf18 size_t} bytes_read = fread (buffer, {\cf17 sizeof} (buffer[0]), BYTES_TO_READ, fptr);\par
00057   {\cf19 if} (bytes_read != BYTES_TO_READ)\par
00058     \{\par
00059       handle_fread_error (bytes_read, BYTES_TO_READ);\par
00060       {\cf19 return};\par
00061     \}\par
00062 \par
00063   print_hex_data (buffer, BYTES_TO_READ);\par
00064   fseek (fptr, -BYTES_TO_READ, SEEK_CUR);\par
00065 \}\par
00066 \par
00067 {\cf20 // TODO: add an command-line arg to output to a log file or to run silently.}\par
00068 {\cf18 void}\par
00069 hh_log (hh_log_level lvl, {\cf17 const} {\cf18 char} *fmt, ...)\par
00070 \{\par
00071   {\cf17 const} {\cf18 char} *program_tag = {\cf22 "[HarvesterHarvester]"};\par
00072   FILE *output_stream = stdout;\par
00073 \par
00074   {\cf19 switch} (lvl)\par
00075     \{\par
00076     {\cf19 case} HH_LOG_INFO:\par
00077       fprintf (stdout, {\cf22 "%s[INFO] "}, program_tag);\par
00078       output_stream = stdout;\par
00079       {\cf19 break};\par
00080     {\cf19 case} HH_LOG_WARNING:\par
00081       fprintf (stderr, {\cf22 "%s[WARNING] "}, program_tag);\par
00082       output_stream = stderr;\par
00083       {\cf19 break};\par
00084     {\cf19 case} HH_LOG_ERROR:\par
00085       fprintf (stderr, {\cf22 "%s[ERROR] "}, program_tag);\par
00086       output_stream = stderr;\par
00087       {\cf19 break};\par
00088     {\cf19 default}:\par
00089       hh_log (HH_LOG_ERROR, {\cf22 "Unrecognized hh_log_level, %d"}, lvl);\par
00090       {\cf19 return};\par
00091     \}\par
00092 \par
00093   va_list args;\par
00094   va_start (args, fmt);\par
00095   vfprintf (output_stream, fmt, args);\par
00096   va_end (args);\par
00097   fprintf (output_stream, {\cf22 "\\n"});\par
00098 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "hh.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b main.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.c\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "hh.h"}\par
00002 {\cf21 #include "options.h"}\par
00003 \par
00004 {\cf21 #include <stdlib.h>}\par
00005 \par
00006 {\cf18 int}\par
00007 main ({\cf18 int} argc, {\cf18 char} **argv)\par
00008 \{\par
00009   FILE *fptr = NULL;\par
00010 \par
00011   {\cf19 if} (argc >= 2)\par
00012     handle_command_line_args (argc, argv);\par
00013 \par
00014   {\cf19 if} (OP_BATCH_PROCESS && !OP_SKIP_DAT_PROCESSING)\par
00015     \{\par
00016       {\cf19 if} (hh_batch_process_DAT_files () != 0)\par
00017         exit (1);\par
00018     \}\par
00019   {\cf19 else} {\cf19 if} (!OP_SKIP_DAT_PROCESSING)\par
00020     \{\par
00021       {\cf19 if} (hh_setup_extractor (&fptr, argv[argc - 1]) != 0)\par
00022         exit (1);\par
00023 \par
00024       {\cf19 if} (hh_process_DAT_file (fptr) != 0)\par
00025         exit (1);\par
00026 \par
00027       fclose (fptr);\par
00028     \}\par
00029 \par
00030   {\cf19 if} (!OP_SKIP_INT_DAT_PROCESSING && hh_process_internal_dat_files () != 0)\par
00031     \{\par
00032       exit (1);\par
00033     \}\par
00034 \par
00035   {\cf19 return} 0;\par
00036 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/options.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "options.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_out_list_of_command_line_arguments} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_flag} (char *f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_command_line_args} (int argc, char **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_BATCH_PROCESS} = true\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_DAT_PROCESSING} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_INT_DAT_PROCESSING} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_DEBUG_MODE} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_INPUT_DIR} = (char *)"dat-files"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_OUTPUT_DIR} = (char *)"output"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OP_PATH_SEPARATOR} = '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OP_DEBUG_FILE_SIZE_LIMIT} = 0xF00000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b CURRENT_DISK_NAME} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b VERSION_NUMBER_STR} [9] = "01.00.00"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_command_line_args\:options.c}
{\xe \v options.c\:handle_command_line_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_command_line_args (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle multi-part command-line arguments.\par
}{
Definition at line {\b 44} of file {\b options.c}.}\par
}
{\xe \v print_out_list_of_command_line_arguments\:options.c}
{\xe \v options.c\:print_out_list_of_command_line_arguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_out_list_of_command_line_arguments (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }}\par
{
Definition at line {\b 95} of file {\b options.c}.}\par
}
{\xe \v process_flag\:options.c}
{\xe \v options.c\:process_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process_flag (char * f){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }}\par
{
Definition at line {\b 124} of file {\b options.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CURRENT_DISK_NAME\:options.c}
{\xe \v options.c\:CURRENT_DISK_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CURRENT_DISK_NAME = NULL}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b options.c}.}\par
}
{\xe \v OP_BATCH_PROCESS\:options.c}
{\xe \v options.c\:OP_BATCH_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_BATCH_PROCESS = true}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_FILE_SIZE_LIMIT\:options.c}
{\xe \v options.c\:OP_DEBUG_FILE_SIZE_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }}\par
{
Definition at line {\b 30} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_MODE\:options.c}
{\xe \v options.c\:OP_DEBUG_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_DEBUG_MODE = false}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b options.c}.}\par
}
{\xe \v OP_INPUT_DIR\:options.c}
{\xe \v options.c\:OP_INPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_INPUT_DIR = (char *)"dat-files"}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b options.c}.}\par
}
{\xe \v OP_OUTPUT_DIR\:options.c}
{\xe \v options.c\:OP_OUTPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_OUTPUT_DIR = (char *)"output"}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b options.c}.}\par
}
{\xe \v OP_PATH_SEPARATOR\:options.c}
{\xe \v options.c\:OP_PATH_SEPARATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OP_PATH_SEPARATOR = '/'}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_DAT_PROCESSING\:options.c}
{\xe \v options.c\:OP_SKIP_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_DAT_PROCESSING = false}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_INT_DAT_PROCESSING\:options.c}
{\xe \v options.c\:OP_SKIP_INT_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_INT_DAT_PROCESSING = false}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b options.c}.}\par
}
{\xe \v VERSION_NUMBER_STR\:options.c}
{\xe \v options.c\:VERSION_NUMBER_STR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char VERSION_NUMBER_STR[9] = "01.00.00"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b options.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
options.c\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "options.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "utils.h"}\par
00017 \par
00018 {\cf21 #include <stdio.h>}\par
00019 {\cf21 #include <stdlib.h>}\par
00020 {\cf21 #include <string.h>}\par
00021 \par
00022 {\cf20 /* Option defaults */}\par
00023 {\cf18 bool} OP_BATCH_PROCESS = {\cf17 true};\par
00024 {\cf18 bool} OP_SKIP_DAT_PROCESSING = {\cf17 false};\par
00025 {\cf18 bool} OP_SKIP_INT_DAT_PROCESSING = {\cf17 false};\par
00026 {\cf18 bool} OP_DEBUG_MODE = {\cf17 false};\par
00027 {\cf18 char} *OP_INPUT_DIR = ({\cf18 char} *){\cf22 "dat-files"};\par
00028 {\cf18 char} *OP_OUTPUT_DIR = ({\cf18 char} *){\cf22 "output"};\par
00029 {\cf18 char} OP_PATH_SEPARATOR = {\cf23 '/'};\par
00030 uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000; \par
00031 \par
00032 {\cf20 /* Global defaults */}\par
00033 {\cf18 char} *CURRENT_DISK_NAME = NULL;\par
00034 \par
00035 {\cf17 static} {\cf17 const} {\cf18 char} VERSION_NUMBER_STR[9] = {\cf22 "01.00.00"};\par
00036 \par
00038 {\cf17 static} {\cf18 void} print_out_list_of_command_line_arguments ({\cf18 void});\par
00039 \par
00041 {\cf17 static} {\cf18 void} process_flag ({\cf18 char} *f);\par
00042 \par
00043 {\cf18 void}\par
00044 handle_command_line_args ({\cf18 int} argc, {\cf18 char} **argv)\par
00045 \{\par
00046   {\cf18 int} i;\par
00047   {\cf19 for} (i = 1; i < argc; i++)\par
00048     \{\par
00050       {\cf19 if} (strncmp (argv[i], {\cf22 "-d"}, 2) == 0)\par
00051         \{\par
00052           i++;\par
00053           {\cf18 size_t} path_len = strlen (argv[i]);\par
00054           {\cf19 if} (argv[i][path_len - 1] == {\cf23 '/'} || argv[i][path_len - 1] == {\cf23 '\\\\'})\par
00055             \{\par
00056               argv[i][path_len - 1] = {\cf23 '\\0'};\par
00057             \}\par
00058           OP_INPUT_DIR = argv[i];\par
00059         \}\par
00060       {\cf19 else} {\cf19 if} (strncmp (argv[i], {\cf22 "-o"}, 2) == 0)\par
00061         \{\par
00062           i++;\par
00063           {\cf18 size_t} path_len = strlen (argv[i]);\par
00064           {\cf19 if} (argv[i][path_len - 1] == {\cf23 '/'} || argv[i][path_len - 1] == {\cf23 '\\\\'})\par
00065             \{\par
00066               argv[i][path_len - 1] = {\cf23 '\\0'};\par
00067             \}\par
00068           OP_OUTPUT_DIR = argv[i];\par
00069         \}\par
00070       {\cf19 else} {\cf19 if} (argv[i][0] == {\cf23 '-'})\par
00071         \{\par
00072           process_flag (argv[i]);\par
00073         \}\par
00074       {\cf19 else}\par
00075         \{\par
00076           {\cf19 break};\par
00077         \}\par
00078     \}\par
00079 \par
00080   {\cf19 if} (i == argc)\par
00081     {\cf19 return};\par
00082 \par
00083   {\cf19 if} (is_string_dat_file (argv[argc - 1]))\par
00084     \{\par
00085       {\cf20 // just processing the user-provided file @ the user-provided path}\par
00086       OP_BATCH_PROCESS = {\cf17 false};\par
00087     \}\par
00088   {\cf19 else}\par
00089     \{\par
00090       handle_unknown_command_line_argument_error (argv[argc - 1]);\par
00091     \}\par
00092 \}\par
00093 \par
00094 {\cf18 void}\par
00095 print_out_list_of_command_line_arguments ({\cf18 void})\par
00096 \{\par
00097   printf (\par
00098       {\cf22 "HarvesterHarvester (HH) Version %s Copyright (C) 2024 IcePanorama\\n"},\par
00099       VERSION_NUMBER_STR);\par
00100 {\cf21 #ifdef _WIN32}\par
00101   puts ({\cf22 "Usage:\\n\\tHarvesterHarvester_[ARCH].exe [options] "}\par
00102         {\cf22 "[path_to_dat_file]\\n"});\par
00103 {\cf21 #else}\par
00104   puts ({\cf22 "Usage:\\n\\t./HarvesterHarvester [options] [path/to/dat_file.dat]\\n"});\par
00105 {\cf21 #endif}\par
00106   puts ({\cf22 "Command-line arguments:"});\par
00107   puts ({\cf22 "\\t--debug: enables debug mode, skips extracting large files."});\par
00108   puts ({\cf22 "\\t--help: displays list of command line arguments."});\par
00109   puts ({\cf22 "\\t--version: prints out the version number."});\par
00110   {\cf20 //  TODO: have some usage.md file that explains this in more detail.}\par
00111   {\cf20 //  add a note here saying to read that file for details.}\par
00112   puts ({\cf22 "\\t-d [path/to/some-dir]: specify the input directory for batch "}\par
00113         {\cf22 "processing dat files. (Default=./dat-files/)"});\par
00114   puts ({\cf22 "\\t-e: don't extract internal dat files."});\par
00115   puts ({\cf22 "\\t-i: extract internal dat files only."});\par
00116   puts ({\cf22 "\\t-o [path/to/some-dir]: extract dat files to the given "}\par
00117         {\cf22 "directory/look here for internal dat files. (Default=./output/)"});\par
00118   puts ({\cf22 "\\nOptional:"});\par
00119   puts ({\cf22 "\\tpath/to/dat_file.dat: specify the path to a dat file to be "}\par
00120         {\cf22 "processed."});\par
00121 \}\par
00122 \par
00123 {\cf18 void}\par
00124 process_flag ({\cf18 char} *f)\par
00125 \{\par
00126   {\cf19 if} (strcmp (f, {\cf22 "--debug"}) == 0)\par
00127     \{\par
00128       OP_DEBUG_MODE = {\cf17 true};\par
00129     \}\par
00130   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--help"}) == 0)\par
00131     \{\par
00132       print_out_list_of_command_line_arguments ();\par
00133       exit (0);\par
00134     \}\par
00135   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "-e"}) == 0)\par
00136     \{\par
00137       OP_SKIP_INT_DAT_PROCESSING = {\cf17 true};\par
00138     \}\par
00139   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "-i"}) == 0)\par
00140     \{\par
00141       OP_SKIP_DAT_PROCESSING = {\cf17 true};\par
00142     \}\par
00143   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--version"}) == 0)\par
00144     \{\par
00145       printf ({\cf22 "HarvesterHarvester v%s\\n"}, VERSION_NUMBER_STR);\par
00146       exit (0);\par
00147     \}\par
00148   {\cf19 else}\par
00149     \{\par
00150       handle_unknown_command_line_argument_error (f);\par
00151     \}\par
00152 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/output.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "output.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_output_directory} (char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_new_output_directory} (const char *path)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_new_output_directory\:output.c}
{\xe \v output.c\:create_new_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_new_output_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b output.c}.}\par
}
{\xe \v create_output_directory\:output.c}
{\xe \v output.c\:create_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_output_directory (char * path)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b output.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output.c\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "output.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "log.h"}\par
00017 {\cf21 #include "options.h"}\par
00018 {\cf21 #include "utils.h"}\par
00019 \par
00020 {\cf21 #include <stdio.h>}\par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 {\cf21 #include <sys/stat.h>}\par
00024 {\cf21 #ifdef _WIN32}\par
00025 {\cf21 #include <direct.h>}\par
00026 {\cf21 #endif}\par
00027 \par
00028 int8_t\par
00029 create_output_directory ({\cf18 char} *path)\par
00030 \{\par
00031   {\cf19 if} (CURRENT_DISK_NAME != NULL)\par
00032     \{\par
00033       {\cf19 if} (prepend_path_string (path, CURRENT_DISK_NAME) != 0)\par
00034         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00035     \}\par
00036 \par
00037   {\cf19 if} (prepend_path_string (path, OP_OUTPUT_DIR) != 0)\par
00038     {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00039 \par
00040   create_new_output_directory (path);\par
00041 \par
00042   {\cf19 return} 0;\par
00043 \}\par
00044 \par
00045 int8_t\par
00046 create_new_output_directory ({\cf17 const} {\cf18 char} *path)\par
00047 \{\par
00048   {\cf19 if} (directory_exists (path))\par
00049     {\cf19 return} 0;\par
00050 \par
00051   {\cf20 // Why +2 here? '\\0' and ?}\par
00052   {\cf18 char} *tmp = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00053   {\cf19 if} (tmp == NULL)\par
00054     \{\par
00055       {\cf19 return} handle_calloc_error (strlen (path) + 2);\par
00056     \}\par
00057 \par
00058   strcpy (tmp, path);\par
00059   {\cf18 char} *token = strtok (tmp, &OP_PATH_SEPARATOR);\par
00060 \par
00061   {\cf18 char} *dir = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00062   {\cf19 if} (dir == NULL)\par
00063     \{\par
00064       free (tmp);\par
00065       {\cf19 return} handle_calloc_error (strlen (path) + 2);\par
00066     \}\par
00067 \par
00068   {\cf19 while} (token != NULL)\par
00069     \{\par
00070       strcat (dir, token);\par
00071 \par
00072       {\cf19 if} (!directory_exists (dir))\par
00073         \{\par
00074           {\cf20 // TODO: test on Windows}\par
00075           {\cf18 int} status;\par
00076 {\cf21 #ifdef _WIN32}\par
00077           status = _mkdir (dir);\par
00078 {\cf21 #else}\par
00079           status = mkdir (dir, 0700);\par
00080 {\cf21 #endif}\par
00081           {\cf19 if} (status != 0)\par
00082             \{\par
00083               hh_log (HH_LOG_ERROR,\par
00084                       {\cf22 "Failed to create the following output directory, %s."},\par
00085                       path);\par
00086               free (dir);\par
00087               free (tmp);\par
00088               {\cf19 return} HH_CREATE_OUTPUT_DIR_ERROR;\par
00089             \}\par
00090         \}\par
00091 \par
00092       strcat (dir, &OP_PATH_SEPARATOR);\par
00093       token = strtok (NULL, &OP_PATH_SEPARATOR);\par
00094     \}\par
00095 \par
00096   free (dir);\par
00097   free (tmp);\par
00098   {\cf19 return} 0;\par
00099 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/path_table.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "path_table.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_path_table_entries} (path_table *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_path_table_entry} (path_table_entry *e)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a path_table_entry to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b add_entry_to_path_table} (path_table *pt, path_table_entry *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 path_table_entry}  to the given {\f2 path_table} 's list of {\f2 entries} , resizing it as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_path_table} (path_table *pt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_path_table} (path_table *pt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_path_table} (path_table *pt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_type_l_path_table} (FILE *fptr, path_table *pt)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_STARTING_NUM_ENTRIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_path_table\:path_table.c}
{\xe \v path_table.c\:add_entry_to_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_path_table (path_table * pt, path_table_entry * entry){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 path_table_entry}  to the given {\f2 path_table} 's list of {\f2 entries} , resizing it as needed. }}\par
{
Definition at line {\b 65} of file {\b path_table.c}.}\par
}
{\xe \v create_path_table\:path_table.c}
{\xe \v path_table.c\:create_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_path_table (path_table * pt)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b path_table.c}.}\par
}
{\xe \v destroy_path_table\:path_table.c}
{\xe \v path_table.c\:destroy_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_path_table (path_table * pt)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table\:path_table.c}
{\xe \v path_table.c\:print_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table (path_table * pt)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table_entry\:path_table.c}
{\xe \v path_table.c\:print_path_table_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table_entry (path_table_entry * e){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a path_table_entry to the stdout in a human-readable form. }}\par
{
Definition at line {\b 111} of file {\b path_table.c}.}\par
}
{\xe \v process_type_l_path_table\:path_table.c}
{\xe \v path_table.c\:process_type_l_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_type_l_path_table (FILE * fptr, path_table * pt)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b path_table.c}.}\par
}
{\xe \v resize_path_table_entries\:path_table.c}
{\xe \v path_table.c\:resize_path_table_entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_path_table_entries (path_table * pt){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }}\par
{
Definition at line {\b 79} of file {\b path_table.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PT_GROWTH_RATE\:path_table.c}
{\xe \v path_table.c\:PT_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b path_table.c}.}\par
}
{\xe \v PT_STARTING_NUM_ENTRIES\:path_table.c}
{\xe \v path_table.c\:PT_STARTING_NUM_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_STARTING_NUM_ENTRIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b path_table.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table.c\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "path_table.h"}\par
00002 {\cf21 #include "data_reader.h"}\par
00003 {\cf21 #include "errors.h"}\par
00004 \par
00005 {\cf21 #include <stdint.h>}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 \par
00009 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_STARTING_NUM_ENTRIES = 10;\par
00010 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_GROWTH_RATE = 2;\par
00011 \par
00016 {\cf17 static} int8_t resize_path_table_entries (path_table *pt);\par
00017 \par
00019 {\cf17 static} {\cf18 void} print_path_table_entry (path_table_entry *e);\par
00020 \par
00025 {\cf17 static} int8_t add_entry_to_path_table (path_table *pt,\par
00026                                        path_table_entry *entry);\par
00027 \par
00028 int8_t\par
00029 create_path_table (path_table *pt)\par
00030 \{\par
00031   pt->entries = malloc ({\cf17 sizeof} (path_table_entry) * PT_STARTING_NUM_ENTRIES);\par
00032   {\cf19 if} (pt->entries == NULL)\par
00033     \{\par
00034       {\cf19 return} handle_malloc_error ({\cf22 "path table entries."});\par
00035     \}\par
00036 \par
00037   pt->size = PT_STARTING_NUM_ENTRIES;\par
00038   pt->current_entry = 0;\par
00039 \par
00040   {\cf19 for} ({\cf18 size_t} i = 0; i < PT_STARTING_NUM_ENTRIES; i++)\par
00041     \{\par
00042       pt->entries[i].directory_identifier = NULL;\par
00043     \}\par
00044 \par
00045   {\cf19 return} 0;\par
00046 \}\par
00047 \par
00048 {\cf18 void}\par
00049 destroy_path_table (path_table *pt)\par
00050 \{\par
00051   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->size; i++)\par
00052     \{\par
00053       {\cf19 if} (pt->entries[i].directory_identifier == NULL)\par
00054         {\cf19 continue};\par
00055 \par
00056       free (pt->entries[i].directory_identifier);\par
00057       pt->entries[i].directory_identifier = NULL;\par
00058     \}\par
00059 \par
00060   free (pt->entries);\par
00061   pt->entries = NULL;\par
00062 \}\par
00063 \par
00064 int8_t\par
00065 add_entry_to_path_table (path_table *pt, path_table_entry *entry)\par
00066 \{\par
00067   {\cf19 if} (pt->current_entry >= pt->size)\par
00068     \{\par
00069       {\cf19 if} (resize_path_table_entries (pt) != 0)\par
00070         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00071     \}\par
00072 \par
00073   pt->entries[pt->current_entry] = *entry;\par
00074   pt->current_entry++;\par
00075   {\cf19 return} 0;\par
00076 \}\par
00077 \par
00078 int8_t\par
00079 resize_path_table_entries (path_table *pt)\par
00080 \{\par
00081   {\cf18 size_t} new_size = (size_t)(pt->size * PT_GROWTH_RATE);\par
00082   path_table_entry *new_entries = (path_table_entry *)realloc (\par
00083       pt->entries, sizeof (path_table_entry) * new_size);\par
00084   {\cf19 if} (new_entries == NULL)\par
00085     \{\par
00086       destroy_path_table (pt);\par
00087       {\cf19 return} handle_realloc_error ({\cf22 "entries"}, pt->size, new_size);\par
00088     \}\par
00089 \par
00090   pt->entries = new_entries;\par
00091   {\cf19 for} ({\cf18 size_t} i = pt->size; i < new_size; i++)\par
00092     \{\par
00093       pt->entries[i].directory_identifier = NULL;\par
00094     \}\par
00095 \par
00096   pt->size = new_size;\par
00097   {\cf19 return} 0;\par
00098 \}\par
00099 \par
00100 {\cf18 void}\par
00101 print_path_table (path_table *pt)\par
00102 \{\par
00103   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->current_entry; i++)\par
00104     \{\par
00105       printf ({\cf22 "Entry %zu:\\n"}, i + 1);\par
00106       print_path_table_entry (&pt->entries[i]);\par
00107     \}\par
00108 \}\par
00109 \par
00110 {\cf18 void}\par
00111 print_path_table_entry (path_table_entry *e)\par
00112 \{\par
00113   printf ({\cf22 "\\tDirectory identifier length: %02X\\n"},\par
00114           e->directory_identifier_length);\par
00115   printf ({\cf22 "\\tExtended attribute record length: %02X\\n"},\par
00116           e->extended_attribute_record_length);\par
00117   printf ({\cf22 "\\tLocation of extant: %08X\\n"}, e->location_of_extent);\par
00118   printf ({\cf22 "\\tParent directory number: %04X\\n"}, e->parent_directory_number);\par
00119   printf ({\cf22 "\\tDirectory identifier: %s\\n"}, e->directory_identifier);\par
00120 \}\par
00121 \par
00122 int8_t\par
00123 process_type_l_path_table (FILE *fptr, path_table *pt)\par
00124 \{\par
00125   uint8_t dir_identifier_length;\par
00126   {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00127     {\cf19 return} HH_FREAD_ERROR;\par
00128 \par
00129   {\cf19 do}\par
00130     \{\par
00131       path_table_entry curr;\par
00132       curr.directory_identifier_length = dir_identifier_length;\par
00133 \par
00134       {\cf19 if} (curr.directory_identifier_length != 1)\par
00135         curr.directory_identifier_length += 1;\par
00136 \par
00137       {\cf20 /* clang-format off */}\par
00138       {\cf19 if} ((read_single_uint8 (fptr, &curr.extended_attribute_record_length) != 0)\par
00139           || (read_little_endian_data_uint32_t (fptr, &curr.location_of_extent) != 0)\par
00140           || (read_little_endian_data_uint16_t (fptr, &curr.parent_directory_number)) != 0)\par
00141         \{\par
00142           {\cf19 return} HH_FREAD_ERROR;\par
00143         \}\par
00144       {\cf20 /* clang-format on */}\par
00145 \par
00146       curr.directory_identifier\par
00147           = ({\cf18 char} *)calloc (curr.directory_identifier_length, sizeof ({\cf18 char}));\par
00148 \par
00149       {\cf19 if} (curr.directory_identifier_length != 1)\par
00150         \{\par
00151           {\cf18 size_t} bytes_read\par
00152               = fread (curr.directory_identifier, sizeof ({\cf18 char}),\par
00153                        curr.directory_identifier_length - 1, fptr);\par
00154           curr.directory_identifier[curr.directory_identifier_length - 1]\par
00155               = {\cf23 '\\0'};\par
00156           {\cf19 if} (bytes_read\par
00157               != {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1))\par
00158             \{\par
00159               handle_fread_error (\par
00160                   bytes_read,\par
00161                   {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1));\par
00162               {\cf19 return} HH_FREAD_ERROR;\par
00163             \}\par
00164         \}\par
00165       {\cf19 else}\par
00166         \{\par
00167           fseek (fptr, 1, SEEK_CUR);\par
00168         \}\par
00169 \par
00170       {\cf19 if} (add_entry_to_path_table (pt, &curr) != 0)\par
00171         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00172 \par
00173       {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00174         {\cf19 return} HH_FREAD_ERROR;\par
00175 \par
00176       {\cf19 if} (dir_identifier_length == 0) {\cf20 // handle padding field}\par
00177         \{\par
00178           {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00179             {\cf19 return} HH_FREAD_ERROR;\par
00180         \}\par
00181     \}\par
00182   {\cf19 while} (dir_identifier_length != 0);\par
00183 \par
00184   {\cf19 return} 0;\par
00185 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utils.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b prepend_path_string} (char *str, const char *prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b prepend_string} (char *str, const char *prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string_dat_file} (char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directory_exists} (const char *dir)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b file_exists} (const char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_char_is} (FILE *fptr, uint8_t expected_ch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_eof} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b change_endianness_uint16} (uint16_t value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_endianness_uint16\:utils.c}
{\xe \v utils.c\:change_endianness_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t change_endianness_uint16 (uint16_t value)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b utils.c}.}\par
}
{\xe \v directory_exists\:utils.c}
{\xe \v utils.c\:directory_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool directory_exists (const char * dir)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b utils.c}.}\par
}
{\xe \v file_exists\:utils.c}
{\xe \v utils.c\:file_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_exists (const char * filename)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b utils.c}.}\par
}
{\xe \v is_string_dat_file\:utils.c}
{\xe \v utils.c\:is_string_dat_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_string_dat_file (char * str)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b utils.c}.}\par
}
{\xe \v peek_char_is\:utils.c}
{\xe \v utils.c\:peek_char_is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_char_is (FILE * fptr, uint8_t expected_ch)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }}\par
{
Definition at line {\b 117} of file {\b utils.c}.}\par
}
{\xe \v peek_eof\:utils.c}
{\xe \v utils.c\:peek_eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_eof (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: implement better err handling. \par
}{
Definition at line {\b 135} of file {\b utils.c}.}\par
}
{\xe \v prepend_path_string\:utils.c}
{\xe \v utils.c\:prepend_path_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t prepend_path_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b utils.c}.}\par
}
{\xe \v prepend_string\:utils.c}
{\xe \v utils.c\:prepend_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void prepend_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b utils.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.c\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "utils.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 \par
00020 {\cf21 #include <stdio.h>}\par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 {\cf21 #include <sys/stat.h>}\par
00024 \par
00025 {\cf21 #ifdef _WIN32}\par
00026 {\cf21 #include <direct.h>}\par
00027 {\cf21 #include <windows.h>}\par
00028 {\cf21 #else}\par
00029 {\cf21 #include <unistd.h>}\par
00030 {\cf21 #endif}\par
00031 \par
00032 int8_t\par
00033 prepend_path_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00034 \{\par
00035   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00036       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00037     \{\par
00038       {\cf19 return} 0;\par
00039     \}\par
00040 \par
00041   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00042   {\cf19 if} (tmp == NULL)\par
00043     \{\par
00044       hh_log (HH_LOG_ERROR, {\cf22 "Unable to calloc string of size %zu."},\par
00045               strlen (str) + strlen (prefix) + 2);\par
00046       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00047     \}\par
00048 \par
00049   strcpy (tmp, str);\par
00050   strcpy (str, prefix);\par
00051   strcat (str, &OP_PATH_SEPARATOR);\par
00052   strcat (str, tmp);\par
00053   free (tmp);\par
00054 \par
00055   {\cf19 return} 0;\par
00056 \}\par
00057 \par
00058 {\cf18 void}\par
00059 prepend_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00060 \{\par
00061   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00062       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00063     \{\par
00064       {\cf19 return};\par
00065     \}\par
00066 \par
00067   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00068   {\cf19 if} (tmp == NULL)\par
00069     \{\par
00070       hh_log (HH_LOG_ERROR, {\cf22 "Unable to calloc string of size %zu."},\par
00071               strlen (str) + strlen (prefix) + 2);\par
00072       exit (1);\par
00073     \}\par
00074   strcpy (tmp, str);\par
00075   strcpy (str, prefix);\par
00076   strcat (str, tmp);\par
00077   free (tmp);\par
00078 \}\par
00079 \par
00080 {\cf18 bool}\par
00081 is_string_dat_file ({\cf18 char} *str)\par
00082 \{\par
00083   {\cf17 const} {\cf18 char} *EXPECTED_EXTENSION = {\cf22 ".DAT"};\par
00084   {\cf17 const} uint8_t EXTENSION_LEN = 5; {\cf20 // +1 for null terminator}\par
00085 \par
00086   {\cf18 size_t} len = strlen (str) + 1;\par
00087   {\cf19 return} (len > EXTENSION_LEN\par
00088           && strcmp (str + (len - EXTENSION_LEN), EXPECTED_EXTENSION) == 0);\par
00089 \}\par
00090 \par
00091 {\cf18 bool}\par
00092 directory_exists ({\cf17 const} {\cf18 char} *dir)\par
00093 \{\par
00094 {\cf21 #ifdef _WIN32}\par
00095   {\cf17 struct }_stat st;\par
00096   {\cf19 return} (_stat (dir, &st) == 0 && (st.st_mode & _S_IFDIR));\par
00097 {\cf21 #else}\par
00098   {\cf17 struct }stat st;\par
00099   {\cf19 return} (stat (dir, &st) == 0 && S_ISDIR (st.st_mode));\par
00100 {\cf21 #endif}\par
00101 \}\par
00102 \par
00103 {\cf18 bool}\par
00104 file_exists ({\cf17 const} {\cf18 char} *filename)\par
00105 \{\par
00106 {\cf21 #ifdef _WIN32}\par
00107   DWORD attribs = GetFileAttributes (filename);\par
00108   {\cf19 return} attribs != INVALID_FILE_ATTRIBUTES\par
00109          && !(attribs & FILE_ATTRIBUTE_DIRECTORY);\par
00110 {\cf21 #else}\par
00111   {\cf19 return} access (filename, F_OK) != -1;\par
00112 {\cf21 #endif}\par
00113 \}\par
00114 \par
00116 {\cf18 bool}\par
00117 peek_char_is (FILE *fptr, uint8_t expected_ch)\par
00118 \{\par
00119   uint8_t byte;\par
00120   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00121     \{\par
00122       {\cf19 return} {\cf17 false};\par
00123     \}\par
00124   {\cf19 else} {\cf19 if} ({\cf18 byte} == expected_ch)\par
00125     \{\par
00126       {\cf19 return} {\cf17 true};\par
00127     \}\par
00128 \par
00129   fseek (fptr, -1, SEEK_CUR);\par
00130   {\cf19 return} {\cf17 false};\par
00131 \}\par
00132 \par
00134 {\cf18 bool}\par
00135 peek_eof (FILE *fptr)\par
00136 \{\par
00137   uint8_t value;\par
00138   {\cf18 size_t} bytes_read = fread (&value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00139   fseek (fptr, -1, SEEK_CUR);\par
00140   {\cf19 return} bytes_read == 0;\par
00141 \}\par
00142 \par
00143 uint16_t\par
00144 change_endianness_uint16 (uint16_t value)\par
00145 \{\par
00146   {\cf19 return} (value << 8) | (value >> 8);\par
00147 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/volume_descriptor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "volume_descriptor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_volume_descriptor} (volume_descriptor *vd, uint8_t type_code, uint8_t version)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_header} (volume_descriptor *vd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_data} (volume_descriptor_data *vdd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_header} (FILE *fptr, volume_descriptor *vd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_data} (FILE *fptr, volume_descriptor_data *vdd)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_volume_descriptor\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:create_volume_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_volume_descriptor (volume_descriptor * vd, uint8_t type_code, uint8_t version)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_data (volume_descriptor_data * vdd)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_header (volume_descriptor * vd)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_data (FILE * fptr, volume_descriptor_data * vdd)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_header (FILE * fptr, volume_descriptor * vd)}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b volume_descriptor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor.c\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "volume_descriptor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <string.h>}\par
00020 \par
00021 {\cf18 void}\par
00022 create_volume_descriptor (volume_descriptor *vd, uint8_t type_code,\par
00023                           uint8_t version)\par
00024 \{\par
00025   vd->type_code = type_code;\par
00026   strncpy (vd->identifier, {\cf22 "CD001"}, sizeof (vd->identifier));\par
00027   vd->identifier[{\cf17 sizeof} (vd->identifier) - 1] = {\cf23 '\\0'};\par
00028   vd->version = version;\par
00029 \}\par
00030 \par
00031 {\cf18 void}\par
00032 print_volume_descriptor_header (volume_descriptor *vd)\par
00033 \{\par
00034   printf ({\cf22 "Volume descriptor type code: %02x\\n"}, vd->type_code);\par
00035   printf ({\cf22 "Volume descriptor identifier: %s\\n"}, vd->identifier);\par
00036   printf ({\cf22 "Volume descriptor version: %02x\\n"}, vd->version);\par
00037 \}\par
00038 \par
00039 {\cf18 void}\par
00040 print_volume_descriptor_data (volume_descriptor_data *vdd)\par
00041 \{\par
00042   printf ({\cf22 "System identifier: %s\\n"}, vdd->system_identifier);\par
00043   printf ({\cf22 "Volume identifier: %s\\n"}, vdd->volume_identifier);\par
00044   printf ({\cf22 "Vol space size: %08X\\n"}, vdd->volume_space_size);\par
00045   printf ({\cf22 "Vol set size: %04X\\n"}, vdd->volume_set_size);\par
00046   printf ({\cf22 "Vol sequence size: %04X\\n"}, vdd->volume_sequence_number);\par
00047   printf ({\cf22 "Logical block size: %04X\\n"}, vdd->logical_block_size);\par
00048   printf ({\cf22 "Path table size: %08X\\n"}, vdd->path_table_size);\par
00049   printf ({\cf22 "Type-L path table location: %08X\\n"},\par
00050           vdd->type_l_path_table_location);\par
00051   printf ({\cf22 "Optional Type-L path table location: %08X\\n"},\par
00052           vdd->optional_type_l_path_table_location);\par
00053   printf ({\cf22 "Type-M path table location: %08X\\n"},\par
00054           vdd->type_m_path_table_location);\par
00055   printf ({\cf22 "Optional Type-M path table location: %08X\\n"},\par
00056           vdd->optional_type_m_path_table_location);\par
00057   printf ({\cf22 "Volume set identifier: %s\\n"}, vdd->volume_set_identifier);\par
00058   printf ({\cf22 "Publisher identifier: %s\\n"}, vdd->publisher_identifier);\par
00059   printf ({\cf22 "Data preparer identifier: %s\\n"}, vdd->data_preparer_identifier);\par
00060   printf ({\cf22 "Application identifier: %s\\n"}, vdd->application_identifier);\par
00061   printf ({\cf22 "Copyright file identifier: %s\\n"}, vdd->copyright_file_identifier);\par
00062   printf ({\cf22 "Abstract file identifier: %s\\n"}, vdd->abstract_file_identifier);\par
00063   printf ({\cf22 "Bibliographic file identifier: %s\\n"},\par
00064           vdd->bibliographic_file_identifier);\par
00065   printf ({\cf22 "Volume creation date and time: "});\par
00066   print_dec_datetime (vdd->volume_creation_date_and_time);\par
00067   printf ({\cf22 "Volume modification date and time: "});\par
00068   print_dec_datetime (vdd->volume_modification_date_and_time);\par
00069   printf ({\cf22 "Volume expiration date and time: "});\par
00070   print_dec_datetime (vdd->volume_expiration_date_and_time);\par
00071   printf ({\cf22 "Volume effective date and time: "});\par
00072   print_dec_datetime (vdd->volume_effective_date_and_time);\par
00073   printf ({\cf22 "File structure version: %02X\\n"}, vdd->file_structure_version);\par
00074   printf ({\cf22 "DAT file creation software identifier: %s\\n"},\par
00075           vdd->DAT_file_creation_software_identifier);\par
00076   printf ({\cf22 "DAT file creation software version number: %s\\n"},\par
00077           vdd->DAT_file_creation_software_version_number);\par
00078 \}\par
00079 \par
00080 int8_t\par
00081 process_volume_descriptor_header (FILE *fptr, volume_descriptor *vd)\par
00082 \{\par
00083   uint8_t descriptor_type;\par
00084   {\cf19 if} (read_single_uint8 (fptr, &descriptor_type) != 0)\par
00085     {\cf19 return} HH_FREAD_ERROR;\par
00086 \par
00087   fseek (fptr, 5, SEEK_CUR);\par
00088 \par
00089   uint8_t descriptor_ver;\par
00090   {\cf19 if} (read_single_uint8 (fptr, &descriptor_ver) != 0)\par
00091     {\cf19 return} HH_FREAD_ERROR;\par
00092 \par
00093   create_volume_descriptor (vd, descriptor_type, descriptor_ver);\par
00094 \par
00095   {\cf19 return} 0;\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 process_volume_descriptor_data (FILE *fptr, volume_descriptor_data *vdd)\par
00100 \{\par
00101   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00102 \par
00103   {\cf19 if} ((read_string (fptr, vdd->system_identifier, SYSTEM_IDENTIFIER_LEN) != 0)\par
00104       || (read_string (fptr, vdd->volume_identifier, VOLUME_IDENTIFIER_LEN)\par
00105           != 0))\par
00106     \{\par
00107       {\cf19 return} HH_FREAD_ERROR;\par
00108     \}\par
00109 \par
00110   fseek (fptr, 8, SEEK_CUR); {\cf20 // Unused field}\par
00111 \par
00112   {\cf19 if} (read_both_endian_data_uint32 (fptr, &vdd->volume_space_size) != 0)\par
00113     {\cf19 return} HH_FREAD_ERROR;\par
00114 \par
00115   fseek (fptr, 32, SEEK_CUR); {\cf20 // Unused field}\par
00116 \par
00117   {\cf20 /* clang-format off */}\par
00118   {\cf19 if} ((read_both_endian_data_uint16 (fptr, &vdd->volume_set_size) != 0)\par
00119       || (read_both_endian_data_uint16 (fptr, &vdd->volume_sequence_number) != 0)\par
00120       || (read_both_endian_data_uint16 (fptr, &vdd->logical_block_size) != 0))\par
00121   \{\par
00122     {\cf19 return} HH_FREAD_ERROR;\par
00123   \}\par
00124   {\cf20 /* clang-format on */}\par
00125 \par
00126   {\cf19 if} ((read_both_endian_data_uint32 (fptr, &vdd->path_table_size) != 0)\par
00127       || (read_little_endian_data_uint32_t (fptr,\par
00128                                             &vdd->type_l_path_table_location)\par
00129           != 0)\par
00130       || (read_little_endian_data_uint32_t (\par
00131               fptr, &vdd->optional_type_l_path_table_location)\par
00132           != 0)\par
00133       || (read_little_endian_data_uint32_t (fptr,\par
00134                                             &vdd->type_m_path_table_location)\par
00135           != 0)\par
00136       || (read_little_endian_data_uint32_t (\par
00137               fptr, &vdd->optional_type_m_path_table_location)\par
00138           != 0))\par
00139     \{\par
00140       {\cf19 return} HH_FREAD_ERROR;\par
00141     \}\par
00142 \par
00143   {\cf19 if} (read_array_uint8 (fptr, vdd->root_directory_entry,\par
00144                         ROOT_DIRECTORY_ENTRY_LEN)\par
00145       != 0)\par
00146     \{\par
00147       {\cf19 return} HH_FREAD_ERROR;\par
00148     \}\par
00149 \par
00150   {\cf20 /* clang-format off */}\par
00151   {\cf19 if} ((read_string (fptr, vdd->volume_set_identifier, VOLUME_SET_IDENTIFIER_LEN) != 0)\par
00152       || (read_string (fptr, vdd->publisher_identifier, PUBLISHER_IDENTIFIER_LEN) != 0)\par
00153       || (read_string (fptr, vdd->data_preparer_identifier, DATA_PREPARER_IDENTIFIER_LEN) != 0)\par
00154       || (read_string (fptr, vdd->application_identifier, APPLICATION_IDENTIFIER_LEN) != 0)\par
00155       || (read_string (fptr, vdd->copyright_file_identifier, COPYRIGHT_FILE_IDENTIFIER_LEN) != 0)\par
00156       || (read_string (fptr, vdd->abstract_file_identifier, ABSTRACT_FILE_IDENTIFIER_LEN) != 0)\par
00157       || (read_string (fptr, vdd->bibliographic_file_identifier, BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN) != 0))\par
00158   \{\par
00159     {\cf19 return} HH_FREAD_ERROR;\par
00160   \}\par
00161   {\cf20 /* clang-format on */}\par
00162 \par
00163   {\cf19 if} ((read_dec_datetime (fptr, &vdd->volume_creation_date_and_time) != 0)\par
00164       || (read_dec_datetime (fptr, &vdd->volume_modification_date_and_time)\par
00165           != 0)\par
00166       || (read_dec_datetime (fptr, &vdd->volume_expiration_date_and_time) != 0)\par
00167       || (read_dec_datetime (fptr, &vdd->volume_effective_date_and_time) != 0))\par
00168     \{\par
00169       {\cf19 return} HH_FREAD_ERROR;\par
00170     \}\par
00171 \par
00172   {\cf19 if} (read_single_uint8 (fptr, &vdd->file_structure_version) != 0)\par
00173     {\cf19 return} HH_FREAD_ERROR;\par
00174 \par
00175   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00176 \par
00177   read_string (fptr, vdd->DAT_file_creation_software_identifier,\par
00178                DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN);\par
00179 \par
00180   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00181 \par
00182   read_string (fptr, vdd->DAT_file_creation_software_version_number,\par
00183                DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN);\par
00184 \par
00185   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00186 \par
00187   fseek (fptr, 0x1EC, SEEK_CUR); {\cf20 // Unknown data (492 bytes)}\par
00188 \par
00189   fseek (fptr, 0x28D, SEEK_CUR); {\cf20 // Reserved by ISO}\par
00190 \par
00191   {\cf19 return} 0;\par
00192 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
