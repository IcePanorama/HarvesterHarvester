{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment HarvesterHarvester  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
00.00.00 \par
}}HarvesterHarvester}
{\comment Generated by doxygen 1.11.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt HarvesterHarvester}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 00.00.00\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
HarvesterHarvester\par \pard\plain 
{\tc\tcl1 \v HarvesterHarvester}
{\xe \v HarvesterHarvester}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
A tool for harvesting data out of {\f2 {\i Harvester} 's (DigiFX Interactive, 1996)} dat files.\par
This program is the first piece of a toolchain that I'm developing as I work to reverse engineering {\i Harvester} . The ultimate goal of this project is to eventually port the game to a more modern graphics framework (Raylib or OpenGL) just for fun/to teach myself the basics of reverse engineering.\par
The program works in two steps:{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab It reconstructs the original disk images that Harvester would've shipped with in 1996{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\i Note} : if you own the original game disks, this step is not needed.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
See USAGE.md for more details.\par}
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab It extracts the dat files contained within those new directories in order to give you full access to all of the game's files.\par}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Future Projects
\par}
{\tc\tcl3 \v Future Projects}
The next step for me in this project will be creating an asset viewer.\par
This will require me to reverse engineer all of the various, non-standardized file formats that DigiFX used when making the game, which will be essential for porting the game in the future.\par
So far, I've already been able to reverse engineer the {\f2 *.BM}  files, which are used for all the static backgrounds in the games, for character portraits, the map, and more. Unfortunately, I likely can't to share these files, at least not in bulk (see below). I will, however, be sharing a small handful of these images as I show this project off online and I'll make sure to add a link here in the future if you wish to view those!\par}
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Easiest Way
\par}
{\tc\tcl3 \v Easiest Way}
Navigate to the {\f2 releases} page and download the latest zip file.\par
Once downloaded, extract the zip file wherever you'd like and you're done! See USAGE.md for more details on how to run the program.\par
{\b NOTE} : {\i if you're reading this in the present, you'll notice that there currently aren't any available releases. I'm writing this README in advance \'96 this project isn't quite done yet, sorry!} \par}
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Building from source (Linux/MacOS/Unix)
\par}
{\tc\tcl3 \v Building from source (Linux/MacOS/Unix)}
1) Install the following dependencies: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gcc make mingw32-gcc clang-tools-extra valgrind doxygen\par
}
 2) Clone the repo: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ git clone https://github.com/IcePanorama/HarvesterHarvester/ && cd HarvesterHarvester\par
}
 3) Build using make: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ make release # for *nix, x86_64, and i686 executables\par
# ... or, alternatively ...\par
$ make full    # for just the *nix executable\par
}
 Running {\f2 make release}  is strongly recommended as the build process for the release target makes use of every single dependency listed above, thus ensuring that you have all the correct packages installed on your machine.\par
Congrats! You're now all set to use the program or start contributing.\par}
\par}
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A note on piracy
\par}
{\tc\tcl2 \v A note on piracy}
This program requires that you legally own a copy of {\i Harvester}  in order to source the necessary dat files.\par
The GOG version (which this project was built around) {\f2 is available here for $5.99}, although it's worth noting that it does go on sale rather often.\par
{\f2 Alternatively, visit any of the retailers on this link if you'd rather shop elsewhere}.\par
This project in no way intends to encourage the piracy of DigiFX' software. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b dec_datetime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dir_datetime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b directory} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b directory_record} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory.h - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b file_flags} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File_flags.h - {\b file_flags} data type and its associated functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b index_entry} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A file entry in an {\f2 {\b index_file}}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b index_file} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b path_table} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b path_table_entry} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Path_table.h - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b volume_descriptor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b volume_descriptor_data} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/{\b data_reader.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b data_reader.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b datetime.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b datetime.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b directory.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b directory.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b errors.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b errors.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b extractor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b extractor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_flags.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_flags.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b hh.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b hh.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b index_file.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b index_file.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b options.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b options.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b output.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b output.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b path_table.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b path_table.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b utils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b volume_descriptor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b volume_descriptor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dec_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v dec_datetime}
{\xe \v dec_datetime}
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. }}\par
{
{\f2 #include <datetime.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b year} [{\b YEAR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b month} [{\b MONTH_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b day} [{\b HOUR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b hour} [{\b HOUR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b minute} [{\b MINUTE_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b second} [{\b SECOND_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b hundredths_of_a_second} [{\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b time_zone_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses ASCII digits to represent the main parts of the date/time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Date/time_format} \par
{\b volume_descriptor} \par
}}}{
Definition at line {\b 38} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:dec_datetime}
{\xe \v dec_datetime\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::day[{\b HOUR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b datetime.h}.}\par
}
{\xe \v hour\:dec_datetime}
{\xe \v dec_datetime\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::hour[{\b HOUR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b datetime.h}.}\par
}
{\xe \v hundredths_of_a_second\:dec_datetime}
{\xe \v dec_datetime\:hundredths_of_a_second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::hundredths_of_a_second[{\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b datetime.h}.}\par
}
{\xe \v minute\:dec_datetime}
{\xe \v dec_datetime\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::minute[{\b MINUTE_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b datetime.h}.}\par
}
{\xe \v month\:dec_datetime}
{\xe \v dec_datetime\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::month[{\b MONTH_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b datetime.h}.}\par
}
{\xe \v second\:dec_datetime}
{\xe \v dec_datetime\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::second[{\b SECOND_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b datetime.h}.}\par
}
{\xe \v time_zone_offset\:dec_datetime}
{\xe \v dec_datetime\:time_zone_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dec_datetime::time_zone_offset}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b datetime.h}.}\par
}
{\xe \v year\:dec_datetime}
{\xe \v dec_datetime\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::year[{\b YEAR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b datetime.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dir_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v dir_datetime}
{\xe \v dir_datetime}
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. }}\par
{
{\f2 #include <datetime.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b year}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of years since 1900. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b month}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b day}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b minute}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b second}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b time_zone_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This format is presumably used to save disc space over a large number of entries.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
{\b directory_record} \par
}}}{
Definition at line {\b 57} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:dir_datetime}
{\xe \v dir_datetime\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::day}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b datetime.h}.}\par
}
{\xe \v hour\:dir_datetime}
{\xe \v dir_datetime\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::hour}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b datetime.h}.}\par
}
{\xe \v minute\:dir_datetime}
{\xe \v dir_datetime\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::minute}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b datetime.h}.}\par
}
{\xe \v month\:dir_datetime}
{\xe \v dir_datetime\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::month}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b datetime.h}.}\par
}
{\xe \v second\:dir_datetime}
{\xe \v dir_datetime\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::second}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b datetime.h}.}\par
}
{\xe \v time_zone_offset\:dir_datetime}
{\xe \v dir_datetime\:time_zone_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::time_zone_offset}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b datetime.h}.}\par
}
{\xe \v year\:dir_datetime}
{\xe \v dir_datetime\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::year}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of years since 1900. }}\par
{
Definition at line {\b 59} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b datetime.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory Struct Reference\par \pard\plain 
{\tc\tcl2 \v directory}
{\xe \v directory}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. }}\par
{
{\f2 #include <directory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b directory_record} * {\b records}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the max capacity of {\f2 records} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_record}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last record in {\f2 records} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b directory_record} \par
}}}{
Definition at line {\b 60} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_record\:directory}
{\xe \v directory\:current_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t directory::current_record}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last record in {\f2 records} . }}\par
{
Definition at line {\b 64} of file {\b directory.h}.}\par
}
{\xe \v records\:directory}
{\xe \v directory\:records}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b directory_record}* directory::records}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b directory.h}.}\par
}
{\xe \v size\:directory}
{\xe \v directory\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t directory::size}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the max capacity of {\f2 records} . }}\par
{
Definition at line {\b 63} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b directory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory_record Struct Reference\par \pard\plain 
{\tc\tcl2 \v directory_record}
{\xe \v directory_record}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. }}\par
{
{\f2 #include <directory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b extended_attribute_record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b location_of_extent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b data_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dir_datetime} {\b recording_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b file_flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_unit_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b interleave_gap_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_sequence_number}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_identifier_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b file_identifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions, except those with a return value of void, return zero on success and non-zero on failure. A directory record. It's perhaps easier to think of this as a {\f2 file} . It is worth noting, however, that we don't differentiate betewen files and subdirectories.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
}}}{
Definition at line {\b 38} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data_length\:directory_record}
{\xe \v directory_record\:data_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t directory_record::data_length}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b directory.h}.}\par
}
{\xe \v extended_attribute_record_length\:directory_record}
{\xe \v directory_record\:extended_attribute_record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::extended_attribute_record_length}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b directory.h}.}\par
}
{\xe \v file_flags\:directory_record}
{\xe \v directory_record\:file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} directory_record::file_flags}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b directory.h}.}\par
}
{\xe \v file_identifier\:directory_record}
{\xe \v directory_record\:file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* directory_record::file_identifier}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b directory.h}.}\par
}
{\xe \v file_identifier_length\:directory_record}
{\xe \v directory_record\:file_identifier_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::file_identifier_length}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b directory.h}.}\par
}
{\xe \v file_unit_size\:directory_record}
{\xe \v directory_record\:file_unit_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::file_unit_size}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }}\par
{
Definition at line {\b 47} of file {\b directory.h}.}\par
}
{\xe \v interleave_gap_size\:directory_record}
{\xe \v directory_record\:interleave_gap_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::interleave_gap_size}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }}\par
{
Definition at line {\b 49} of file {\b directory.h}.}\par
}
{\xe \v location_of_extent\:directory_record}
{\xe \v directory_record\:location_of_extent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t directory_record::location_of_extent}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b directory.h}.}\par
}
{\xe \v record_length\:directory_record}
{\xe \v directory_record\:record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::record_length}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b directory.h}.}\par
}
{\xe \v recording_datetime\:directory_record}
{\xe \v directory_record\:recording_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dir_datetime} directory_record::recording_datetime}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b directory.h}.}\par
}
{\xe \v volume_sequence_number\:directory_record}
{\xe \v directory_record\:volume_sequence_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t directory_record::volume_sequence_number}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b directory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags Struct Reference\par \pard\plain 
{\tc\tcl2 \v file_flags}
{\xe \v file_flags}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. }}\par
{
{\f2 #include <file_flags.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hidden}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subdirectory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b associated_file}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No clue what this means. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b extended_attribute_record_contains_owner_and_group_permissions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b final_directory_record}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If false, this directory record is not the file's final resting place; the file spans over multiple extents. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The file flags for a directory record.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
{\b directory_record} \par
}}}{
Definition at line {\b 27} of file {\b file_flags.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v associated_file\:file_flags}
{\xe \v file_flags\:associated_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::associated_file}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No clue what this means. }}\par
{
Definition at line {\b 31} of file {\b file_flags.h}.}\par
}
{\xe \v extended_attribute_record_contains_owner_and_group_permissions\:file_flags}
{\xe \v file_flags\:extended_attribute_record_contains_owner_and_group_permissions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::extended_attribute_record_contains_owner_and_group_permissions}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b file_flags.h}.}\par
}
{\xe \v final_directory_record\:file_flags}
{\xe \v file_flags\:final_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::final_directory_record}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If false, this directory record is not the file's final resting place; the file spans over multiple extents. }}\par
{
Definition at line {\b 37} of file {\b file_flags.h}.}\par
}
{\xe \v hidden\:file_flags}
{\xe \v file_flags\:hidden}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::hidden}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b file_flags.h}.}\par
}
{\xe \v subdirectory\:file_flags}
{\xe \v file_flags\:subdirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::subdirectory}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b file_flags.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b file_flags.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v index_entry}
{\xe \v index_entry}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A file entry in an {\f2 {\b index_file}} . }}\par
{
{\f2 #include <index_file.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b entry_start}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's location in the {\f2 INDEX.00#}  file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b full_path} [{\b FULL_PATH_MAX_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b filename} [{\b FILENAME_MAX_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b start}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's location in the {\f2 *.DAT}  file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A file entry in an {\f2 {\b index_file}} . \par
}{
Definition at line {\b 43} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v entry_start\:index_entry}
{\xe \v index_entry\:entry_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::entry_start}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's location in the {\f2 INDEX.00#}  file. }}\par
{
Definition at line {\b 45} of file {\b index_file.h}.}\par
}
{\xe \v filename\:index_entry}
{\xe \v index_entry\:filename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char index_entry::filename[{\b FILENAME_MAX_LEN}]}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b index_file.h}.}\par
}
{\xe \v full_path\:index_entry}
{\xe \v index_entry\:full_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char index_entry::full_path[{\b FULL_PATH_MAX_LEN}]}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b index_file.h}.}\par
}
{\xe \v size\:index_entry}
{\xe \v index_entry\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::size}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b index_file.h}.}\par
}
{\xe \v start\:index_entry}
{\xe \v index_entry\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::start}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's location in the {\f2 *.DAT}  file. }}\par
{
Definition at line {\b 48} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b index_file.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file Struct Reference\par \pard\plain 
{\tc\tcl2 \v index_file}
{\xe \v index_file}
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. }}\par
{
{\f2 #include <index_file.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b index_entry} * {\b indicies}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 indicies} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_index}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to last item in {\f2 indicies} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. \par
}{
Definition at line {\b 53} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_index\:index_file}
{\xe \v index_file\:current_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t index_file::current_index}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to last item in {\f2 indicies} . }}\par
{
Definition at line {\b 57} of file {\b index_file.h}.}\par
}
{\xe \v indicies\:index_file}
{\xe \v index_file\:indicies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b index_entry}* index_file::indicies}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b index_file.h}.}\par
}
{\xe \v size\:index_file}
{\xe \v index_file\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t index_file::size}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 indicies} . }}\par
{
Definition at line {\b 56} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b index_file.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table Struct Reference\par \pard\plain 
{\tc\tcl2 \v path_table}
{\xe \v path_table}
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. }}\par
{
{\f2 #include <path_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b path_table_entry} * {\b entries}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_entry}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to most recent item in {\f2 entries} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. \par
}{
Definition at line {\b 42} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_entry\:path_table}
{\xe \v path_table\:current_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t path_table::current_entry}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to most recent item in {\f2 entries} . }}\par
{
Definition at line {\b 46} of file {\b path_table.h}.}\par
}
{\xe \v entries\:path_table}
{\xe \v path_table\:entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b path_table_entry}* path_table::entries}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b path_table.h}.}\par
}
{\xe \v size\:path_table}
{\xe \v path_table\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t path_table::size}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 entries} . }}\par
{
Definition at line {\b 45} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b path_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v path_table_entry}
{\xe \v path_table_entry}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. }}\par
{
{\f2 #include <path_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b directory_identifier_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b extended_attribute_record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b location_of_extent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b parent_directory_number}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indexed from 1 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b directory_identifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions, except those which are void, return zero on success and non-zero on failure. An entry of some path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#The_Path_Table} \par
}}}{
Definition at line {\b 32} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v directory_identifier\:path_table_entry}
{\xe \v path_table_entry\:directory_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* path_table_entry::directory_identifier}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b path_table.h}.}\par
}
{\xe \v directory_identifier_length\:path_table_entry}
{\xe \v path_table_entry\:directory_identifier_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t path_table_entry::directory_identifier_length}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b path_table.h}.}\par
}
{\xe \v extended_attribute_record_length\:path_table_entry}
{\xe \v path_table_entry\:extended_attribute_record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t path_table_entry::extended_attribute_record_length}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b path_table.h}.}\par
}
{\xe \v location_of_extent\:path_table_entry}
{\xe \v path_table_entry\:location_of_extent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t path_table_entry::location_of_extent}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b path_table.h}.}\par
}
{\xe \v parent_directory_number\:path_table_entry}
{\xe \v path_table_entry\:parent_directory_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t path_table_entry::parent_directory_number}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indexed from 1 }}\par
{
Definition at line {\b 37} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b path_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor Struct Reference\par \pard\plain 
{\tc\tcl2 \v volume_descriptor}
{\xe \v volume_descriptor}
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. }}\par
{
{\f2 #include <volume_descriptor.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b type_code}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b identifier} [6]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 CD001} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b version}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b volume_descriptor_data} {\b data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Volume_Descriptors} \par
}}}{
Definition at line {\b 81} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:volume_descriptor}
{\xe \v volume_descriptor\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b volume_descriptor_data} volume_descriptor::data}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b volume_descriptor.h}.}\par
}
{\xe \v identifier\:volume_descriptor}
{\xe \v volume_descriptor\:identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor::identifier[6]}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 CD001} . }}\par
{
Definition at line {\b 84} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_code\:volume_descriptor}
{\xe \v volume_descriptor\:type_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor::type_code}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b volume_descriptor.h}.}\par
}
{\xe \v version\:volume_descriptor}
{\xe \v volume_descriptor\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor::version}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b volume_descriptor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v volume_descriptor_data}
{\xe \v volume_descriptor_data}
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. }}\par
{
{\f2 #include <volume_descriptor.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b system_identifier} [{\b SYSTEM_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volume_identifier} [{\b VOLUME_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b volume_space_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_set_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_sequence_number}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b logical_block_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b path_table_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b type_l_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b optional_type_l_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b type_m_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b optional_type_m_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b root_directory_entry} [{\b ROOT_DIRECTORY_ENTRY_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volume_set_identifier} [{\b VOLUME_SET_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b publisher_identifier} [{\b PUBLISHER_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b data_preparer_identifier} [{\b DATA_PREPARER_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b application_identifier} [{\b APPLICATION_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b copyright_file_identifier} [{\b COPYRIGHT_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b abstract_file_identifier} [{\b ABSTRACT_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bibliographic_file_identifier} [{\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_creation_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_modification_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_expiration_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_effective_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_structure_version}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 0x01}  }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b DAT_file_creation_software_identifier} [{\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b DAT_file_creation_software_version_number} [{\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor} \par
}}}{
Definition at line {\b 44} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v abstract_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:abstract_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::abstract_file_identifier[{\b ABSTRACT_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b volume_descriptor.h}.}\par
}
{\xe \v application_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:application_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::application_identifier[{\b APPLICATION_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b volume_descriptor.h}.}\par
}
{\xe \v bibliographic_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:bibliographic_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::bibliographic_file_identifier[{\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b volume_descriptor.h}.}\par
}
{\xe \v copyright_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:copyright_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::copyright_file_identifier[{\b COPYRIGHT_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_file_creation_software_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:DAT_file_creation_software_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::DAT_file_creation_software_identifier[{\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_file_creation_software_version_number\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:DAT_file_creation_software_version_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::DAT_file_creation_software_version_number[{\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}]}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b volume_descriptor.h}.}\par
}
{\xe \v data_preparer_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:data_preparer_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::data_preparer_identifier[{\b DATA_PREPARER_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b volume_descriptor.h}.}\par
}
{\xe \v file_structure_version\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:file_structure_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor_data::file_structure_version}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 0x01}  }}\par
{
Definition at line {\b 69} of file {\b volume_descriptor.h}.}\par
}
{\xe \v logical_block_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:logical_block_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::logical_block_size}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b volume_descriptor.h}.}\par
}
{\xe \v optional_type_l_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:optional_type_l_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::optional_type_l_path_table_location}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b volume_descriptor.h}.}\par
}
{\xe \v optional_type_m_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:optional_type_m_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::optional_type_m_path_table_location}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b volume_descriptor.h}.}\par
}
{\xe \v path_table_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:path_table_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::path_table_size}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b volume_descriptor.h}.}\par
}
{\xe \v publisher_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:publisher_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::publisher_identifier[{\b PUBLISHER_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b volume_descriptor.h}.}\par
}
{\xe \v root_directory_entry\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:root_directory_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor_data::root_directory_entry[{\b ROOT_DIRECTORY_ENTRY_LEN}]}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b volume_descriptor.h}.}\par
}
{\xe \v system_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:system_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::system_identifier[{\b SYSTEM_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_l_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:type_l_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::type_l_path_table_location}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_m_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:type_m_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::type_m_path_table_location}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_creation_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_creation_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_creation_date_and_time}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_effective_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_effective_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_effective_date_and_time}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_expiration_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_expiration_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_expiration_date_and_time}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::volume_identifier[{\b VOLUME_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_modification_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_modification_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_modification_date_and_time}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_sequence_number\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_sequence_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::volume_sequence_number}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_set_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_set_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::volume_set_identifier[{\b VOLUME_SET_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_set_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_set_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::volume_set_size}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_space_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_space_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::volume_space_size}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b volume_descriptor.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/data_reader.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint32} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint16} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_string} (FILE *fptr, char *output, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_array_uint8} (FILE *fptr, uint8_t *arr, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dec_datetime} (FILE *fptr, {\b dec_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_single_uint8} (FILE *fptr, uint8_t *value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dir_datetime} (FILE *fptr, {\b dir_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_file_flags} (FILE *fptr, {\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build_path_string_from_file} (FILE *fptr, char *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builds strings using formats provided by {\f2 internal-dat-file-paths.txt} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v build_path_string_from_file\:data_reader.c}
{\xe \v data_reader.c\:build_path_string_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void build_path_string_from_file (FILE * fptr, char * output)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builds strings using formats provided by {\f2 internal-dat-file-paths.txt} . }}\par
{
Definition at line {\b 255} of file {\b data_reader.c}.}\par
}
{\xe \v read_array_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_array_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_array_uint8 (FILE * fptr, uint8_t * arr, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 159} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint16_t (FILE * fptr, uint16_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 130} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint32_t (FILE * fptr, uint32_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 99} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint16\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint16 (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint32() \par
}}}{
Definition at line {\b 59} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint32\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint32 (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint16() \par
}}}{
Definition at line {\b 37} of file {\b data_reader.c}.}\par
}
{\xe \v read_dec_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dec_datetime (FILE * fptr, {\b dec_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 172} of file {\b data_reader.c}.}\par
}
{\xe \v read_dir_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dir_datetime (FILE * fptr, {\b dir_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 205} of file {\b data_reader.c}.}\par
}
{\xe \v read_file_flags\:data_reader.c}
{\xe \v data_reader.c\:read_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_file_flags (FILE * fptr, {\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b file_flags} \par
}}}{
Definition at line {\b 222} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint16_t (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 115} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint32_t (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 81} of file {\b data_reader.c}.}\par
}
{\xe \v read_single_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_single_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_single_uint8 (FILE * fptr, uint8_t * value)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All of these functions return zero on success, non-zero on failure. The caller is responsible for freeing any memory which may or may not have been allocated during the use of these functions. Reads in a single uint8_t from a given file, storing the output in {\f2 value} . \par
}{
Definition at line {\b 192} of file {\b data_reader.c}.}\par
}
{\xe \v read_string\:data_reader.c}
{\xe \v data_reader.c\:read_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_string (FILE * fptr, char * output, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 145} of file {\b data_reader.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_reader.c\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "data_reader.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "file_flags.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 \par
00020 {\cf21 #include <stdbool.h>}\par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 \par
00028 {\cf17 static} int8_t read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output);\par
00029 \par
00034 {\cf17 static} int8_t read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output);\par
00035 \par
00036 int8_t\par
00037 read_both_endian_data_uint32 (FILE *fptr, uint32_t *output)\par
00038 \{\par
00039   uint32_t value;\par
00040   {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00041     {\cf19 return} HH_FREAD_ERROR;\par
00042 \par
00043   uint32_t expected_value;\par
00044   read_big_endian_data_uint32_t (fptr, &expected_value);\par
00045 \par
00046   {\cf19 if} (value != expected_value)\par
00047     \{\par
00048       hh_log (HH_LOG_ERROR,\par
00049               {\cf22 "ERROR: Incorrect endian conversion (uint32_t). Expected "}\par
00050               {\cf22 "0x%08X, got 0x%08X."},\par
00051               expected_value, value);\par
00052     \}\par
00053 \par
00054   *output = value;\par
00055   {\cf19 return} 0;\par
00056 \}\par
00057 \par
00058 int8_t\par
00059 read_both_endian_data_uint16 (FILE *fptr, uint16_t *output)\par
00060 \{\par
00061   {\cf19 if} (read_little_endian_data_uint16_t (fptr, output) != 0)\par
00062     {\cf19 return} HH_FREAD_ERROR;\par
00063 \par
00064   uint16_t expected_value;\par
00065   {\cf19 if} (read_big_endian_data_uint16_t (fptr, &expected_value) != 0)\par
00066     {\cf19 return} HH_FREAD_ERROR;\par
00067 \par
00068   {\cf19 if} (*output != expected_value)\par
00069     \{\par
00070       hh_log (HH_LOG_ERROR,\par
00071               {\cf22 "Incorrect endian conversion (uint16_t). Expected 0x%04X, got "}\par
00072               {\cf22 "0x%04X."},\par
00073               expected_value, *output);\par
00074       {\cf19 return} -1;\par
00075     \}\par
00076 \par
00077   {\cf19 return} 0;\par
00078 \}\par
00079 \par
00080 int8_t\par
00081 read_little_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00082 \{\par
00083   uint8_t bytes[4];\par
00084   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00085   {\cf19 if} (bytes_read != 4)\par
00086     \{\par
00087       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00088 \par
00089       {\cf19 return} HH_FREAD_ERROR;\par
00090     \}\par
00091 \par
00092   *output = ((uint32_t)bytes[3] << 24) | ((uint32_t)bytes[2] << 16)\par
00093             | ((uint32_t)bytes[1] << 8) | (uint32_t)bytes[0];\par
00094 \par
00095   {\cf19 return} 0;\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00100 \{\par
00101   uint8_t bytes[4];\par
00102   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00103   {\cf19 if} (bytes_read != 4)\par
00104     \{\par
00105       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00106       {\cf19 return} HH_FREAD_ERROR;\par
00107     \}\par
00108 \par
00109   *output = ((uint32_t)bytes[0] << 24) | ((uint32_t)bytes[1] << 16)\par
00110             | ((uint32_t)bytes[2] << 8) | (uint32_t)bytes[3];\par
00111   {\cf19 return} 0;\par
00112 \}\par
00113 \par
00114 int8_t\par
00115 read_little_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00116 \{\par
00117   uint8_t bytes[2];\par
00118   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00119   {\cf19 if} (bytes_read != 2)\par
00120     \{\par
00121       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00122       {\cf19 return} HH_FREAD_ERROR;\par
00123     \}\par
00124 \par
00125   *output = ((uint16_t)bytes[0] << 8) | (uint16_t)bytes[1];\par
00126   {\cf19 return} 0;\par
00127 \}\par
00128 \par
00129 int8_t\par
00130 read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00131 \{\par
00132   uint8_t bytes[2];\par
00133   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00134   {\cf19 if} (bytes_read != 2)\par
00135     \{\par
00136       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00137       {\cf19 return} HH_FREAD_ERROR;\par
00138     \}\par
00139 \par
00140   *output = ((uint16_t)bytes[1] << 8) | (uint16_t)bytes[0];\par
00141   {\cf19 return} 0;\par
00142 \}\par
00143 \par
00144 int8_t\par
00145 read_string (FILE *fptr, {\cf18 char} *output, uint8_t length)\par
00146 \{\par
00147   {\cf18 size_t} bytes_read = fread (output, {\cf17 sizeof} ({\cf18 char}), length - 1, fptr);\par
00148   output[length - 1] = {\cf23 '\\0'};\par
00149   {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * length - 1)\par
00150     \{\par
00151       handle_fread_error (bytes_read, {\cf17 sizeof} ({\cf18 char}) * length - 1);\par
00152       {\cf19 return} HH_FREAD_ERROR;\par
00153     \}\par
00154 \par
00155   {\cf19 return} 0;\par
00156 \}\par
00157 \par
00158 int8_t\par
00159 read_array_uint8 (FILE *fptr, uint8_t *arr, uint8_t length)\par
00160 \{\par
00161   {\cf18 size_t} bytes_read = fread (arr, {\cf17 sizeof} (uint8_t), length, fptr);\par
00162   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t) * length)\par
00163     \{\par
00164       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t) * length);\par
00165       {\cf19 return} HH_FREAD_ERROR;\par
00166     \}\par
00167 \par
00168   {\cf19 return} 0;\par
00169 \}\par
00170 \par
00171 int8_t\par
00172 read_dec_datetime (FILE *fptr, dec_datetime *dt)\par
00173 \{\par
00174   {\cf19 if} ((read_string (fptr, dt->year, YEAR_FIELD_LEN) != 0)\par
00175       || (read_string (fptr, dt->month, MONTH_FIELD_LEN) != 0)\par
00176       || (read_string (fptr, dt->day, DAY_FIELD_LEN) != 0)\par
00177       || (read_string (fptr, dt->hour, HOUR_FIELD_LEN) != 0)\par
00178       || (read_string (fptr, dt->minute, MINUTE_FIELD_LEN) != 0)\par
00179       || (read_string (fptr, dt->second, SECOND_FIELD_LEN) != 0)\par
00180       || (read_string (fptr, dt->hundredths_of_a_second,\par
00181                        HUNDREDTHS_OF_A_SECOND_FIELD_LEN)\par
00182           != 0)\par
00183       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00184     \{\par
00185       {\cf19 return} HH_FREAD_ERROR;\par
00186     \}\par
00187 \par
00188   {\cf19 return} 0;\par
00189 \}\par
00190 \par
00191 int8_t\par
00192 read_single_uint8 (FILE *fptr, uint8_t *value)\par
00193 \{\par
00194   {\cf18 size_t} bytes_read = fread (value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00195   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t))\par
00196     \{\par
00197       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t));\par
00198       {\cf19 return} HH_FREAD_ERROR;\par
00199     \}\par
00200 \par
00201   {\cf19 return} 0;\par
00202 \}\par
00203 \par
00204 int8_t\par
00205 read_dir_datetime (FILE *fptr, dir_datetime *dt)\par
00206 \{\par
00207   {\cf19 if} ((read_single_uint8 (fptr, &dt->year) != 0)\par
00208       || (read_single_uint8 (fptr, &dt->month) != 0)\par
00209       || (read_single_uint8 (fptr, &dt->day) != 0)\par
00210       || (read_single_uint8 (fptr, &dt->hour) != 0)\par
00211       || (read_single_uint8 (fptr, &dt->minute) != 0)\par
00212       || (read_single_uint8 (fptr, &dt->second) != 0)\par
00213       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00214     \{\par
00215       {\cf19 return} HH_FREAD_ERROR;\par
00216     \}\par
00217 \par
00218   {\cf19 return} 0;\par
00219 \}\par
00220 \par
00221 int8_t\par
00222 read_file_flags (FILE *fptr, file_flags *ff)\par
00223 \{\par
00224   uint8_t byte;\par
00225   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00226     {\cf19 return} HH_FREAD_ERROR;\par
00227 \par
00228   {\cf19 if} ({\cf18 byte} & 0x1)\par
00229     \{\par
00230       ff->hidden = {\cf17 true};\par
00231     \}\par
00232   {\cf19 if} ({\cf18 byte} & 0x2)\par
00233     \{\par
00234       ff->subdirectory = {\cf17 true};\par
00235     \}\par
00236   {\cf19 if} ({\cf18 byte} & 0x4)\par
00237     \{\par
00238       ff->associated_file = {\cf17 true};\par
00239     \}\par
00240   {\cf19 if} ({\cf18 byte} & 0x8)\par
00241     \{\par
00242       ff->extended_attribute_record_contains_owner_and_group_permissions\par
00243           = {\cf17 true};\par
00244     \}\par
00245   {\cf19 if} ({\cf18 byte} & 0x10)\par
00246     \{\par
00247       ff->final_directory_record = {\cf17 true};\par
00248     \}\par
00249 \par
00250   {\cf19 return} 0;\par
00251 \}\par
00252 \par
00253 {\cf20 // this system could probably be replaced with a macro}\par
00254 {\cf18 void}\par
00255 build_path_string_from_file (FILE *fptr, {\cf18 char} *output)\par
00256 \{\par
00257   {\cf18 char} format[32] = \{ 0 \};\par
00258   fgets (format, {\cf17 sizeof} (format), fptr);\par
00259   {\cf18 size_t} len = strlen (format);\par
00260   format[len - 1] = {\cf23 '\\0'};\par
00261 \par
00262   sprintf (output, format, OP_OUTPUT_DIR, OP_PATH_SEPARATOR,\par
00263            OP_PATH_SEPARATOR);\par
00264 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/data_reader.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/data_reader.h}
{\xe \v src/data_reader.h}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_single_uint8} (FILE *fptr, uint8_t *value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint16} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint32} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_string} (FILE *fptr, char *output, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_array_uint8} (FILE *fptr, uint8_t *arr, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dec_datetime} (FILE *fptr, {\b dec_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dir_datetime} (FILE *fptr, {\b dir_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_file_flags} (FILE *fptr, {\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build_path_string_from_file} (FILE *fptr, char *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builds strings using formats provided by {\f2 internal-dat-file-paths.txt} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v build_path_string_from_file\:data_reader.h}
{\xe \v data_reader.h\:build_path_string_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void build_path_string_from_file (FILE * fptr, char * output)}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builds strings using formats provided by {\f2 internal-dat-file-paths.txt} . }}\par
{
Definition at line {\b 255} of file {\b data_reader.c}.}\par
}
{\xe \v read_array_uint8\:data_reader.h}
{\xe \v data_reader.h\:read_array_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_array_uint8 (FILE * fptr, uint8_t * arr, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 159} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint16\:data_reader.h}
{\xe \v data_reader.h\:read_both_endian_data_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint16 (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint32() \par
}}}{
Definition at line {\b 59} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint32\:data_reader.h}
{\xe \v data_reader.h\:read_both_endian_data_uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint32 (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint16() \par
}}}{
Definition at line {\b 37} of file {\b data_reader.c}.}\par
}
{\xe \v read_dec_datetime\:data_reader.h}
{\xe \v data_reader.h\:read_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dec_datetime (FILE * fptr, {\b dec_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 172} of file {\b data_reader.c}.}\par
}
{\xe \v read_dir_datetime\:data_reader.h}
{\xe \v data_reader.h\:read_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dir_datetime (FILE * fptr, {\b dir_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 205} of file {\b data_reader.c}.}\par
}
{\xe \v read_file_flags\:data_reader.h}
{\xe \v data_reader.h\:read_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_file_flags (FILE * fptr, {\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b file_flags} \par
}}}{
Definition at line {\b 222} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint16_t\:data_reader.h}
{\xe \v data_reader.h\:read_little_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint16_t (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 115} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint32_t\:data_reader.h}
{\xe \v data_reader.h\:read_little_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint32_t (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 81} of file {\b data_reader.c}.}\par
}
{\xe \v read_single_uint8\:data_reader.h}
{\xe \v data_reader.h\:read_single_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_single_uint8 (FILE * fptr, uint8_t * value)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All of these functions return zero on success, non-zero on failure. The caller is responsible for freeing any memory which may or may not have been allocated during the use of these functions. Reads in a single uint8_t from a given file, storing the output in {\f2 value} . \par
}{
Definition at line {\b 192} of file {\b data_reader.c}.}\par
}
{\xe \v read_string\:data_reader.h}
{\xe \v data_reader.h\:read_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_string (FILE * fptr, char * output, uint8_t length)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 145} of file {\b data_reader.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_reader.h\par \pard\plain 
{\tc\tcl2 \v src/data_reader.h}
{\xe \v src/data_reader.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_DATA_READER_H_}\par
00022 {\cf21 #define _HH_DATA_READER_H_}\par
00023 \par
00024 {\cf21 #include "datetime.h"}\par
00025 {\cf21 #include "file_flags.h"}\par
00026 \par
00027 {\cf21 #include <stdint.h>}\par
00028 {\cf21 #include <stdio.h>}\par
00029 \par
00033 int8_t read_single_uint8 (FILE *fptr, uint8_t *value);\par
00034 \par
00039 int8_t read_little_endian_data_uint16_t (FILE *fptr, uint16_t *output);\par
00040 \par
00045 int8_t read_little_endian_data_uint32_t (FILE *fptr, uint32_t *output);\par
00046 \par
00056 int8_t read_both_endian_data_uint16 (FILE *fptr, uint16_t *output);\par
00057 \par
00067 int8_t read_both_endian_data_uint32 (FILE *fptr, uint32_t *output);\par
00068 \par
00073 int8_t read_string (FILE *fptr, {\cf18 char} *output, uint8_t length);\par
00074 \par
00079 int8_t read_array_uint8 (FILE *fptr, uint8_t *arr, uint8_t length);\par
00080 \par
00086 int8_t read_dec_datetime (FILE *fptr, dec_datetime *dt);\par
00087 \par
00093 int8_t read_dir_datetime (FILE *fptr, dir_datetime *dt);\par
00094 \par
00100 int8_t read_file_flags (FILE *fptr, file_flags *ff);\par
00101 \par
00103 {\cf18 void} build_path_string_from_file (FILE *fptr, {\cf18 char} *output);\par
00104 \par
00105 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/datetime.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dec_datetime} ({\b dec_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dir_datetime} ({\b dir_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_dec_datetime\:datetime.c}
{\xe \v datetime.c\:print_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dec_datetime ({\b dec_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 6} of file {\b datetime.c}.}\par
}
{\xe \v print_dir_datetime\:datetime.c}
{\xe \v datetime.c\:print_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dir_datetime ({\b dir_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 14} of file {\b datetime.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.c\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "datetime.h"}\par
00002 \par
00003 {\cf21 #include <stdio.h>}\par
00004 \par
00005 {\cf18 void}\par
00006 print_dec_datetime (dec_datetime dt)\par
00007 \{\par
00008   printf ({\cf22 "%s-%s-%s @ %s:%s:%s.%s (%02X)\\n"}, dt.year, dt.month, dt.day,\par
00009           dt.hour, dt.minute, dt.second, dt.hundredths_of_a_second,\par
00010           dt.time_zone_offset);\par
00011 \}\par
00012 \par
00013 {\cf18 void}\par
00014 print_dir_datetime (dir_datetime dt)\par
00015 \{\par
00016   printf ({\cf22 "%02X-%02X-%02X @ %02X:%02X:%02X (%02X)\\n"}, dt.year, dt.month,\par
00017           dt.day, dt.hour, dt.minute, dt.second, dt.time_zone_offset);\par
00018 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/datetime.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/datetime.h}
{\xe \v src/datetime.h}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dec_datetime}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dir_datetime}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YEAR_FIELD_LEN}\~ 5\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b datetime.h} - contains the {\f2 {\b dec_datetime}}  and {\f2 {\b dir_datetime}}  data types and their associated functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MONTH_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAY_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HOUR_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MINUTE_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECOND_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}\~ 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dec_datetime} ({\b dec_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dir_datetime} ({\b dir_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DAY_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:DAY_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAY_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b datetime.h}.}\par
}
{\xe \v HOUR_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:HOUR_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HOUR_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b datetime.h}.}\par
}
{\xe \v HUNDREDTHS_OF_A_SECOND_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:HUNDREDTHS_OF_A_SECOND_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HUNDREDTHS_OF_A_SECOND_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b datetime.h}.}\par
}
{\xe \v MINUTE_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:MINUTE_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MINUTE_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b datetime.h}.}\par
}
{\xe \v MONTH_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:MONTH_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MONTH_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b datetime.h}.}\par
}
{\xe \v SECOND_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:SECOND_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECOND_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b datetime.h}.}\par
}
{\xe \v YEAR_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:YEAR_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YEAR_FIELD_LEN\~ 5}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b datetime.h} - contains the {\f2 {\b dec_datetime}}  and {\f2 {\b dir_datetime}}  data types and their associated functions. }}\par
{
Definition at line {\b 23} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_dec_datetime\:datetime.h}
{\xe \v datetime.h\:print_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dec_datetime ({\b dec_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 6} of file {\b datetime.c}.}\par
}
{\xe \v print_dir_datetime\:datetime.h}
{\xe \v datetime.h\:print_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dir_datetime ({\b dir_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 14} of file {\b datetime.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.h\par \pard\plain 
{\tc\tcl2 \v src/datetime.h}
{\xe \v src/datetime.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00018 {\cf21 #ifndef _HH_DATETIME_H_}\par
00019 {\cf21 #define _HH_DATETIME_H_}\par
00020 \par
00021 {\cf21 #include <stdint.h>}\par
00022 \par
00023 {\cf21 #define YEAR_FIELD_LEN 5}\par
00024 {\cf21 #define MONTH_FIELD_LEN 3}\par
00025 {\cf21 #define DAY_FIELD_LEN 3}\par
00026 {\cf21 #define HOUR_FIELD_LEN 3}\par
00027 {\cf21 #define MINUTE_FIELD_LEN 3}\par
00028 {\cf21 #define SECOND_FIELD_LEN 3}\par
00029 {\cf21 #define HUNDREDTHS_OF_A_SECOND_FIELD_LEN 3}\par
00030 \par
00038 {\cf17 typedef} {\cf17 struct }dec_datetime\par
00039 \{\par
00040   {\cf18 char} year[YEAR_FIELD_LEN];\par
00041   {\cf18 char} month[MONTH_FIELD_LEN];\par
00042   {\cf18 char} day[HOUR_FIELD_LEN];\par
00043   {\cf18 char} hour[HOUR_FIELD_LEN];\par
00044   {\cf18 char} minute[MINUTE_FIELD_LEN];\par
00045   {\cf18 char} second[SECOND_FIELD_LEN];\par
00046   {\cf18 char} hundredths_of_a_second[HUNDREDTHS_OF_A_SECOND_FIELD_LEN];\par
00047   uint8_t time_zone_offset;\par
00048 \} dec_datetime;\par
00049 \par
00057 {\cf17 typedef} {\cf17 struct }dir_datetime\par
00058 \{\par
00059   uint8_t year; \par
00060   uint8_t month;\par
00061   uint8_t day;\par
00062   uint8_t hour;\par
00063   uint8_t minute;\par
00064   uint8_t second;\par
00065   uint8_t time_zone_offset;\par
00066 \} dir_datetime;\par
00067 \par
00074 {\cf18 void} print_dec_datetime (dec_datetime dt);\par
00075 \par
00082 {\cf18 void} print_dir_datetime (dir_datetime dt);\par
00083 \par
00084 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/directory.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "directory.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_directory_records} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_record_to_directory} ({\b directory} *d, {\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory_record} ({\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_directory} (FILE *fptr, {\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_STARTING_NUM_RECORDS} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_record_to_directory\:directory.c}
{\xe \v directory.c\:add_record_to_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_record_to_directory ({\b directory} * d, {\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }}\par
{
Definition at line {\b 68} of file {\b directory.c}.}\par
}
{\xe \v create_directory\:directory.c}
{\xe \v directory.c\:create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, a directory has {\f2 DIR_STARTING_NUM_RECORDS}  records. \par
}{
Definition at line {\b 32} of file {\b directory.c}.}\par
}
{\xe \v destroy_directory\:directory.c}
{\xe \v directory.c\:destroy_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }}\par
{
Definition at line {\b 52} of file {\b directory.c}.}\par
}
{\xe \v print_directory\:directory.c}
{\xe \v directory.c\:print_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }}\par
{
Definition at line {\b 121} of file {\b directory.c}.}\par
}
{\xe \v print_directory_record\:directory.c}
{\xe \v directory.c\:print_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory_record ({\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }}\par
{
Definition at line {\b 82} of file {\b directory.c}.}\par
}
{\xe \v process_directory\:directory.c}
{\xe \v directory.c\:process_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_directory (FILE * fptr, {\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 133} of file {\b directory.c}.}\par
}
{\xe \v resize_directory_records\:directory.c}
{\xe \v directory.c\:resize_directory_records}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_directory_records ({\b directory} * d){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 99} of file {\b directory.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v DIR_RECORDS_GROWTH_RATE\:directory.c}
{\xe \v directory.c\:DIR_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b directory.c}.}\par
}
{\xe \v DIR_STARTING_NUM_RECORDS\:directory.c}
{\xe \v directory.c\:DIR_STARTING_NUM_RECORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_STARTING_NUM_RECORDS = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b directory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory.c\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "directory.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <stdio.h>}\par
00020 {\cf21 #include <stdlib.h>}\par
00021 \par
00022 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_STARTING_NUM_RECORDS = 10;\par
00023 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_RECORDS_GROWTH_RATE = 2;\par
00024 \par
00029 {\cf17 static} int8_t resize_directory_records (directory *d);\par
00030 \par
00031 int8_t\par
00032 create_directory (directory *d)\par
00033 \{\par
00034   d->records = malloc ({\cf17 sizeof} (directory_record) * DIR_STARTING_NUM_RECORDS);\par
00035   {\cf19 if} (d->records == NULL)\par
00036     \{\par
00037       {\cf19 return} handle_malloc_error ({\cf22 "directory records."});\par
00038     \}\par
00039 \par
00040   d->size = DIR_STARTING_NUM_RECORDS;\par
00041   d->current_record = 0;\par
00042 \par
00043   {\cf19 for} ({\cf18 size_t} i = 0; i < DIR_STARTING_NUM_RECORDS; i++)\par
00044     \{\par
00045       d->records[i].file_identifier = NULL;\par
00046     \}\par
00047 \par
00048   {\cf19 return} 0;\par
00049 \}\par
00050 \par
00051 {\cf18 void}\par
00052 destroy_directory (directory *d)\par
00053 \{\par
00054   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00055     \{\par
00056       {\cf19 if} (d->records[i].file_identifier == NULL)\par
00057         {\cf19 continue};\par
00058 \par
00059       free (d->records[i].file_identifier);\par
00060       d->records[i].file_identifier = NULL;\par
00061     \}\par
00062 \par
00063   free (d->records);\par
00064   d->records = NULL;\par
00065 \}\par
00066 \par
00067 int8_t\par
00068 add_record_to_directory (directory *d, directory_record *r)\par
00069 \{\par
00070   {\cf19 if} (d->current_record >= d->size)\par
00071     \{\par
00072       {\cf19 if} (resize_directory_records (d) != 0)\par
00073         {\cf19 return} -1;\par
00074     \}\par
00075 \par
00076   d->records[d->current_record] = *r;\par
00077   d->current_record++;\par
00078   {\cf19 return} 0;\par
00079 \}\par
00080 \par
00081 {\cf18 void}\par
00082 print_directory_record (directory_record *r)\par
00083 \{\par
00084   printf ({\cf22 "Record length: %02X\\n"}, r->record_length);\par
00085   printf ({\cf22 "Extended attribute record length: %02X\\n"},\par
00086           r->extended_attribute_record_length);\par
00087   printf ({\cf22 "Location of extent: %08X\\n"}, r->location_of_extent);\par
00088   printf ({\cf22 "Data length: %08X\\n"}, r->data_length);\par
00089   print_dir_datetime (r->recording_datetime);\par
00090   print_file_flags (&r->file_flags);\par
00091   printf ({\cf22 "File unit size: %02X\\n"}, r->file_unit_size);\par
00092   printf ({\cf22 "Interleave gap size: %02X\\n"}, r->interleave_gap_size);\par
00093   printf ({\cf22 "Volume sequence number: %04X\\n"}, r->volume_sequence_number);\par
00094   printf ({\cf22 "File identifier length: %02X\\n"}, r->file_identifier_length);\par
00095   printf ({\cf22 "File identifier: %s\\n"}, r->file_identifier);\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 resize_directory_records (directory *d)\par
00100 \{\par
00101   {\cf18 size_t} new_size = d->size * DIR_RECORDS_GROWTH_RATE;\par
00102   directory_record *new_records = (directory_record *)realloc (\par
00103       d->records, sizeof (directory_record) * new_size);\par
00104   {\cf19 if} (new_records == NULL)\par
00105     \{\par
00106       destroy_directory (d);\par
00107       {\cf19 return} handle_realloc_error ({\cf22 "records"}, d->size, new_size);\par
00108     \}\par
00109 \par
00110   d->records = new_records;\par
00111   {\cf19 for} ({\cf18 size_t} i = d->size; i < new_size; i++)\par
00112     \{\par
00113       d->records[i].file_identifier = NULL;\par
00114     \}\par
00115 \par
00116   d->size = new_size;\par
00117   {\cf19 return} 0;\par
00118 \}\par
00119 \par
00120 {\cf18 void}\par
00121 print_directory (directory *d)\par
00122 \{\par
00123   printf ({\cf22 "Number of records: %zu\\n"}, d->current_record + 1);\par
00124   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00125     \{\par
00126       printf ({\cf22 "!!! Record #%zu\\n"}, i + 1);\par
00127       print_directory_record (&d->records[i]);\par
00128       puts ({\cf22 "-------------------------------"});\par
00129     \}\par
00130 \}\par
00131 \par
00132 int8_t\par
00133 process_directory (FILE *fptr, directory *d)\par
00134 \{\par
00135   uint8_t single_byte;\par
00136   {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00137     {\cf19 return} HH_FREAD_ERROR;\par
00138 \par
00139   {\cf19 do}\par
00140     \{\par
00141       directory_record dr;\par
00142       dr.record_length = single_byte;\par
00143 \par
00144       {\cf19 if} ((read_single_uint8 (fptr, &dr.extended_attribute_record_length) != 0)\par
00145           || (read_both_endian_data_uint32 (fptr, &dr.location_of_extent) != 0)\par
00146           || (read_both_endian_data_uint32 (fptr, &dr.data_length) != 0)\par
00147           || (read_dir_datetime (fptr, &dr.recording_datetime) != 0))\par
00148         \{\par
00149           {\cf19 return} HH_FREAD_ERROR;\par
00150         \}\par
00151 \par
00152       dr.file_flags = create_file_flags ();\par
00153       read_file_flags (fptr, &dr.file_flags);\par
00154 \par
00155       {\cf19 if} (read_single_uint8 (fptr, &dr.file_unit_size) != 0\par
00156           || read_single_uint8 (fptr, &dr.interleave_gap_size) != 0)\par
00157         \{\par
00158           {\cf19 return} HH_FREAD_ERROR;\par
00159         \}\par
00160 \par
00161       {\cf19 if} (read_both_endian_data_uint16 (fptr, &dr.volume_sequence_number) != 0)\par
00162         {\cf19 return} HH_FREAD_ERROR;\par
00163 \par
00164       {\cf19 if} (read_single_uint8 (fptr, &dr.file_identifier_length) != 0)\par
00165         \{\par
00166           {\cf19 return} HH_FREAD_ERROR;\par
00167         \}\par
00168       dr.file_identifier_length++;\par
00169 \par
00170       dr.file_identifier\par
00171           = ({\cf18 char} *)calloc (dr.file_identifier_length, sizeof ({\cf18 char}));\par
00172       {\cf18 size_t} bytes_read = fread (dr.file_identifier, sizeof ({\cf18 char}),\par
00173                                  dr.file_identifier_length - 1, fptr);\par
00174       dr.file_identifier[dr.file_identifier_length - 1] = {\cf23 '\\0'};\par
00175       {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1))\par
00176         \{\par
00177           handle_fread_error (bytes_read,\par
00178                               {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1));\par
00179           {\cf19 return} HH_FREAD_ERROR;\par
00180         \}\par
00181 \par
00182       {\cf19 if} (add_record_to_directory (d, &dr) != 0)\par
00183         \{\par
00184           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00185         \}\par
00186 \par
00187       {\cf19 if} (dr.file_identifier_length % 2 != 0) {\cf20 // handle padding field}\par
00188         fseek (fptr, 1, SEEK_CUR);\par
00189 \par
00190       {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00191         {\cf19 return} HH_FREAD_ERROR;\par
00192     \}\par
00193   {\cf19 while} (single_byte != 0);\par
00194 \par
00195   {\cf19 return} 0;\par
00196 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/directory.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/directory.h}
{\xe \v src/directory.h}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b directory_record}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b directory}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_record_to_directory} ({\b directory} *d, {\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory_record} ({\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_directory} (FILE *fptr, {\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_record_to_directory\:directory.h}
{\xe \v directory.h\:add_record_to_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_record_to_directory ({\b directory} * d, {\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }}\par
{
Definition at line {\b 68} of file {\b directory.c}.}\par
}
{\xe \v create_directory\:directory.h}
{\xe \v directory.h\:create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, a directory has {\f2 DIR_STARTING_NUM_RECORDS}  records. \par
}{
Definition at line {\b 32} of file {\b directory.c}.}\par
}
{\xe \v destroy_directory\:directory.h}
{\xe \v directory.h\:destroy_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }}\par
{
Definition at line {\b 52} of file {\b directory.c}.}\par
}
{\xe \v print_directory\:directory.h}
{\xe \v directory.h\:print_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }}\par
{
Definition at line {\b 121} of file {\b directory.c}.}\par
}
{\xe \v print_directory_record\:directory.h}
{\xe \v directory.h\:print_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory_record ({\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }}\par
{
Definition at line {\b 82} of file {\b directory.c}.}\par
}
{\xe \v process_directory\:directory.h}
{\xe \v directory.h\:process_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_directory (FILE * fptr, {\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 133} of file {\b directory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory.h\par \pard\plain 
{\tc\tcl2 \v src/directory.h}
{\xe \v src/directory.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_DIRECTORY_H_}\par
00022 {\cf21 #define _HH_DIRECTORY_H_}\par
00023 \par
00024 {\cf21 #include "datetime.h"}\par
00025 {\cf21 #include "file_flags.h"}\par
00026 \par
00027 {\cf21 #include <stdint.h>}\par
00028 {\cf21 #include <stdio.h>}\par
00029 {\cf21 #include <stdlib.h>}\par
00030 \par
00038 {\cf17 typedef} {\cf17 struct }directory_record\par
00039 \{\par
00040   uint8_t record_length;\par
00041   uint8_t extended_attribute_record_length;\par
00042   uint32_t location_of_extent;\par
00043   uint32_t data_length;\par
00044   dir_datetime recording_datetime;\par
00045   file_flags file_flags;\par
00047   uint8_t file_unit_size;\par
00049   uint8_t interleave_gap_size;\par
00050   uint16_t volume_sequence_number;\par
00051   uint8_t file_identifier_length;\par
00052   {\cf18 char} *file_identifier;\par
00053 \} directory_record;\par
00054 \par
00060 {\cf17 typedef} {\cf17 struct }directory\par
00061 \{\par
00062   directory_record *records;\par
00063   {\cf18 size_t} size;           \par
00064   {\cf18 size_t} current_record; \par
00065 \} directory;\par
00066 \par
00071 int8_t create_directory (directory *d);\par
00072 \par
00077 {\cf18 void} destroy_directory (directory *d);\par
00078 \par
00083 int8_t add_record_to_directory (directory *d, directory_record *r);\par
00084 \par
00088 {\cf18 void} print_directory (directory *d);\par
00089 \par
00093 {\cf18 void} print_directory_record (directory_record *r);\par
00094 \par
00100 int8_t process_directory (FILE *fptr, directory *d);\par
00101 \par
00102 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/errors.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fopen_error} (char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fread_error} (size_t actual, size_t expected_bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_unknown_command_line_argument_error} (char *arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_calloc_error} (size_t size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_realloc_error} (const char *arr_name, size_t old_size, size_t new_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_malloc_error} (const char *obj_name)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an malloc error. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CALLOC_FAILED_ERR_MSG_FMT} = "Unable to calloc string of size %zu."\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b FOPEN_FAILED_ERR_MSG_FMT} = "Unable to open output file, %s."\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_calloc_error\:errors.c}
{\xe \v errors.c\:handle_calloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_calloc_error (size_t size)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }}\par
{
Definition at line {\b 42} of file {\b errors.c}.}\par
}
{\xe \v handle_fopen_error\:errors.c}
{\xe \v errors.c\:handle_fopen_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fopen_error (char * filename)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }}\par
{
Definition at line {\b 11} of file {\b errors.c}.}\par
}
{\xe \v handle_fread_error\:errors.c}
{\xe \v errors.c\:handle_fread_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fread_error (size_t actual, size_t expected_bytes)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }}\par
{
Definition at line {\b 18} of file {\b errors.c}.}\par
}
{\xe \v handle_malloc_error\:errors.c}
{\xe \v errors.c\:handle_malloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_malloc_error (const char * obj_name)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an malloc error. }}\par
{
Definition at line {\b 58} of file {\b errors.c}.}\par
}
{\xe \v handle_realloc_error\:errors.c}
{\xe \v errors.c\:handle_realloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_realloc_error (const char * arr_name, size_t old_size, size_t new_size)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }}\par
{
Definition at line {\b 49} of file {\b errors.c}.}\par
}
{\xe \v handle_unknown_command_line_argument_error\:errors.c}
{\xe \v errors.c\:handle_unknown_command_line_argument_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_unknown_command_line_argument_error (char * arg)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }}\par
{
Definition at line {\b 26} of file {\b errors.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CALLOC_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:CALLOC_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CALLOC_FAILED_ERR_MSG_FMT = "Unable to calloc string of size %zu."}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b errors.c}.}\par
}
{\xe \v FOPEN_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:FOPEN_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* FOPEN_FAILED_ERR_MSG_FMT = "Unable to open output file, %s."}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }}\par
{
Definition at line {\b 8} of file {\b errors.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
errors.c\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "errors.h"}\par
00002 {\cf21 #include "log.h"}\par
00003 \par
00004 {\cf21 #include <stdbool.h>}\par
00005 {\cf21 #include <stdlib.h>}\par
00006 \par
00007 {\cf17 const} {\cf18 char} *CALLOC_FAILED_ERR_MSG_FMT = {\cf22 "Unable to calloc string of size %zu."};\par
00008 {\cf17 const} {\cf18 char} *FOPEN_FAILED_ERR_MSG_FMT = {\cf22 "Unable to open output file, %s."};\par
00009 \par
00010 HH_ERRORS\par
00011 handle_fopen_error ({\cf18 char} *filename)\par
00012 \{\par
00013   hh_log (HH_LOG_ERROR, {\cf22 "Unable to open file, %s."}, filename);\par
00014   {\cf19 return} HH_FOPEN_ERROR;\par
00015 \}\par
00016 \par
00017 HH_ERRORS\par
00018 handle_fread_error ({\cf18 size_t} actual, {\cf18 size_t} expected_bytes)\par
00019 \{\par
00020   hh_log (HH_LOG_ERROR, {\cf22 "Only read %zu byte(s), expected %zu."}, actual,\par
00021           expected_bytes);\par
00022   {\cf19 return} HH_FREAD_ERROR;\par
00023 \}\par
00024 \par
00025 {\cf18 void}\par
00026 handle_unknown_command_line_argument_error ({\cf18 char} *arg)\par
00027 \{\par
00028   {\cf18 bool} windows;\par
00029 {\cf21 #ifdef _WIN32}\par
00030   windows = {\cf17 true};\par
00031 {\cf21 #else}\par
00032   windows = {\cf17 false};\par
00033 {\cf21 #endif}\par
00034   hh_log (HH_LOG_ERROR,\par
00035           {\cf22 "Unknown command-line argument, %s. Run %s --help for a list of "}\par
00036           {\cf22 "command-line arguments."},\par
00037           arg, !windows ? {\cf22 "./HarvesterHarvester"} : {\cf22 "HarvesterHarvester.exe"});\par
00038   exit (1);\par
00039 \}\par
00040 \par
00041 HH_ERRORS\par
00042 handle_calloc_error ({\cf18 size_t} size)\par
00043 \{\par
00044   hh_log (HH_LOG_ERROR, CALLOC_FAILED_ERR_MSG_FMT, size);\par
00045   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00046 \}\par
00047 \par
00048 HH_ERRORS\par
00049 handle_realloc_error ({\cf17 const} {\cf18 char} *arr_name, {\cf18 size_t} old_size, {\cf18 size_t} new_size)\par
00050 \{\par
00051   hh_log (HH_LOG_ERROR,\par
00052           {\cf22 "Failed to reallocate array, %s, from size %zu to %zu."}, arr_name,\par
00053           old_size, new_size);\par
00054   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00055 \}\par
00056 \par
00057 HH_ERRORS\par
00058 handle_malloc_error ({\cf17 const} {\cf18 char} *obj_name)\par
00059 \{\par
00060   hh_log (HH_LOG_ERROR, {\cf22 "Failed to allocate memory for %s."}, obj_name);\par
00061   {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/errors.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/errors.h}
{\xe \v src/errors.h}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b HH_ERRORS} \{ {\b HH_FOPEN_ERROR} = -1
, {\b HH_FREAD_ERROR} = -2
, {\b HH_MEM_ALLOC_ERROR} = -3
, {\b HH_CREATE_OUTPUT_DIR_ERROR} = -4
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b errors.h} - a wrapper for all of hh's potential errors. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fopen_error} (char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fread_error} (size_t actual, size_t expected_bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_calloc_error} (size_t size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_realloc_error} (const char *arr_name, size_t old_size, size_t new_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_malloc_error} (const char *obj_name)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an malloc error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_unknown_command_line_argument_error} (char *arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b FOPEN_FAILED_ERR_MSG_FMT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v HH_ERRORS\:errors.h}
{\xe \v errors.h\:HH_ERRORS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b HH_ERRORS}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b errors.h} - a wrapper for all of hh's potential errors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An enum containing all the possible errors hh could throw. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v HH_FOPEN_ERROR\:errors.h}
{\xe \v errors.h\:HH_FOPEN_ERROR}
{\qr HH_FOPEN_ERROR{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
{\xe \v HH_FREAD_ERROR\:errors.h}
{\xe \v errors.h\:HH_FREAD_ERROR}
{\qr HH_FREAD_ERROR{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\cell }{\cell }{\row }
{\xe \v HH_MEM_ALLOC_ERROR\:errors.h}
{\xe \v errors.h\:HH_MEM_ALLOC_ERROR}
{\qr HH_MEM_ALLOC_ERROR{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{\cell }{\row }
{\xe \v HH_CREATE_OUTPUT_DIR_ERROR\:errors.h}
{\xe \v errors.h\:HH_CREATE_OUTPUT_DIR_ERROR}
{\qr HH_CREATE_OUTPUT_DIR_ERROR{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 22} of file {\b errors.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_calloc_error\:errors.h}
{\xe \v errors.h\:handle_calloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_calloc_error (size_t size)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }}\par
{
Definition at line {\b 42} of file {\b errors.c}.}\par
}
{\xe \v handle_fopen_error\:errors.h}
{\xe \v errors.h\:handle_fopen_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fopen_error (char * filename)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }}\par
{
Definition at line {\b 11} of file {\b errors.c}.}\par
}
{\xe \v handle_fread_error\:errors.h}
{\xe \v errors.h\:handle_fread_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fread_error (size_t actual, size_t expected_bytes)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }}\par
{
Definition at line {\b 18} of file {\b errors.c}.}\par
}
{\xe \v handle_malloc_error\:errors.h}
{\xe \v errors.h\:handle_malloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_malloc_error (const char * obj_name)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an malloc error. }}\par
{
Definition at line {\b 58} of file {\b errors.c}.}\par
}
{\xe \v handle_realloc_error\:errors.h}
{\xe \v errors.h\:handle_realloc_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_realloc_error (const char * arr_name, size_t old_size, size_t new_size)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an calloc error. }}\par
{
Definition at line {\b 49} of file {\b errors.c}.}\par
}
{\xe \v handle_unknown_command_line_argument_error\:errors.h}
{\xe \v errors.h\:handle_unknown_command_line_argument_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_unknown_command_line_argument_error (char * arg)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }}\par
{
Definition at line {\b 26} of file {\b errors.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v FOPEN_FAILED_ERR_MSG_FMT\:errors.h}
{\xe \v errors.h\:FOPEN_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* FOPEN_FAILED_ERR_MSG_FMT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }}\par
{
Definition at line {\b 8} of file {\b errors.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
errors.h\par \pard\plain 
{\tc\tcl2 \v src/errors.h}
{\xe \v src/errors.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_ERRORS_H_}\par
00016 {\cf21 #define _HH_ERRORS_H_}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <stdio.h>}\par
00020 \par
00022 {\cf17 typedef} {\cf17 enum} HH_ERRORS\par
00023 \{\par
00024   HH_FOPEN_ERROR = -1,\par
00025   HH_FREAD_ERROR = -2,\par
00026   HH_MEM_ALLOC_ERROR = -3,\par
00027   HH_CREATE_OUTPUT_DIR_ERROR = -4\par
00028 \} HH_ERRORS;\par
00029 \par
00031 {\cf17 extern} {\cf17 const} {\cf18 char} *FOPEN_FAILED_ERR_MSG_FMT;\par
00032 \par
00034 HH_ERRORS handle_fopen_error ({\cf18 char} *filename);\par
00035 \par
00037 HH_ERRORS handle_fread_error ({\cf18 size_t} actual, {\cf18 size_t} expected_bytes);\par
00038 \par
00040 HH_ERRORS handle_calloc_error ({\cf18 size_t} size);\par
00041 \par
00043 HH_ERRORS handle_realloc_error ({\cf17 const} {\cf18 char} *arr_name, {\cf18 size_t} old_size,\par
00044                                 {\cf18 size_t} new_size);\par
00045 \par
00047 HH_ERRORS handle_malloc_error ({\cf17 const} {\cf18 char} *obj_name);\par
00048 \par
00050 {\cf18 void} handle_unknown_command_line_argument_error ({\cf18 char} *arg);\par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/extractor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "extractor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "output.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_dir_record} (FILE *fptr, struct {\b directory_record} *dr, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_directory} (FILE *fptr, const uint16_t block_size, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directories_and_extract_data_from_path_file} (FILE *fptr, uint16_t block_size, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_idx_entry} (FILE *fptr, {\b index_entry} *idx, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts a file using its corresponding {\f2 {\b index_entry}}  and data pointed to by {\f2 fptr} , outputting it to the location denoated by {\f2 path} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_index_file} ({\b index_file} *idx, const char *idx_path, const char *dat_path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts all of the files described in the given {\f2 {\b index_file}} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_directories_and_extract_data_from_path_file\:extractor.c}
{\xe \v extractor.c\:create_directories_and_extract_data_from_path_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directories_and_extract_data_from_path_file (FILE * fptr, uint16_t block_size, struct {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper for {\f2 extract_directory}  and, therefore also, {\f2 extract_file_using_dir_record}  which handles the extraction of every file and subdirectory using a given path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i block_size} \cell }{logical block size (in big endian form). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b extract_directory()} \par
{\b extract_file_using_dir_record()} \par
}}}{
Definition at line {\b 128} of file {\b extractor.c}.}\par
}
{\xe \v extract_directory\:extractor.c}
{\xe \v extractor.c\:extract_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_directory (FILE * fptr, const uint16_t block_size, const char * path)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }}\par
{
Definition at line {\b 90} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_dir_record\:extractor.c}
{\xe \v extractor.c\:extract_file_using_dir_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_dir_record (FILE * fptr, struct {\b directory_record} * dr, const char * path)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions return zero on success, non-zero on failure. Extracts a file using its respective {\f2 {\b directory_record}}  and data pointed to by {\f2 fptr} , outputting it to the location denoted by {\f2 path} . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 file_identifier}  terminates with a {\f2 ;}  character followed by the file ID number in ASCII coded decimal ({\f2 1} ). See: {\f2 https://wiki.osdev.org/ISO_9660#Directories}\par
Just use the default/existing filename. It'll be incorrect, but probably not worth stoping execution over. Users could just manually remove the {\f2 ;1}  part; the data itself should be fine.\par
}{
Definition at line {\b 27} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_idx_entry\:extractor.c}
{\xe \v extractor.c\:extract_file_using_idx_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_idx_entry (FILE * fptr, {\b index_entry} * idx, const char * path)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts a file using its corresponding {\f2 {\b index_entry}}  and data pointed to by {\f2 fptr} , outputting it to the location denoated by {\f2 path} . }}\par
{
Definition at line {\b 183} of file {\b extractor.c}.}\par
}
{\xe \v extract_index_file\:extractor.c}
{\xe \v extractor.c\:extract_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_index_file ({\b index_file} * idx, const char * idx_path, const char * dat_path)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts all of the files described in the given {\f2 {\b index_file}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 idx_path}  is needed to build an output path.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i `idx_path`} \cell }{relative path to the given {\f2 {\b index_file}} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i `dat_path`} \cell }{relative path to the corresponding dat file. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gives you the {\f2 OP_OUTPUT_DIR/DISK#/}  part of the path. 10 = len("INDEX.001")\par
}{
Definition at line {\b 223} of file {\b extractor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
extractor.c\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "extractor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 {\cf21 #include "output.h"}\par
00020 {\cf21 #include "utils.h"}\par
00021 \par
00022 {\cf21 #include <stdint.h>}\par
00023 {\cf21 #include <stdio.h>}\par
00024 {\cf21 #include <string.h>}\par
00025 \par
00026 int8_t\par
00027 extract_file_using_dir_record (FILE *fptr, {\cf17 struct} directory_record *dr,\par
00028                                {\cf17 const} {\cf18 char} *path)\par
00029 \{\par
00035   {\cf18 char} *actual_filename = strtok (dr->file_identifier, ({\cf17 const} {\cf18 char} *){\cf22 ";"});\par
00036   {\cf19 if} (actual_filename == NULL)\par
00037     \{\par
00044       actual_filename = dr->file_identifier;\par
00045     \}\par
00046 \par
00047   hh_log (HH_LOG_INFO, {\cf22 "Extracting file: %s"}, actual_filename);\par
00048 \par
00049   {\cf20 // +1 for the null terminator, +1 for `/` between dir and filename}\par
00050   {\cf18 size_t} filename_length = strlen (path) + strlen (actual_filename) + 2;\par
00051 \par
00052   {\cf18 char} *output_filename = ({\cf18 char} *)calloc (filename_length, {\cf17 sizeof} ({\cf18 char}));\par
00053   {\cf19 if} (output_filename == NULL)\par
00054     \{\par
00055       {\cf19 return} handle_calloc_error (filename_length);\par
00056     \}\par
00057 \par
00058   strcpy (output_filename, path);\par
00059   strcat (output_filename, &OP_PATH_SEPARATOR);\par
00060   strcat (output_filename, actual_filename);\par
00061 \par
00062   FILE *output_file = fopen (output_filename, {\cf22 "wb"});\par
00063   {\cf19 if} (output_file == NULL)\par
00064     \{\par
00065       handle_fopen_error (output_filename);\par
00066       free (output_filename);\par
00067       {\cf19 return} HH_FOPEN_ERROR;\par
00068     \}\par
00069 \par
00070   {\cf20 // `j` must be in hex, otherwise `data_length` can be treated as an int value}\par
00071   {\cf19 for} (uint32_t j = 0x0; j < dr->data_length; j++)\par
00072     \{\par
00073       uint8_t byte;\par
00074       {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00075         \{\par
00076           fclose (output_file);\par
00077           free (output_filename);\par
00078           {\cf19 return} HH_FREAD_ERROR;\par
00079         \}\par
00080 \par
00081       fwrite (&{\cf18 byte}, {\cf17 sizeof} (uint8_t), 1, output_file);\par
00082     \}\par
00083 \par
00084   fclose (output_file);\par
00085   free (output_filename);\par
00086   {\cf19 return} 0;\par
00087 \}\par
00088 \par
00089 int8_t\par
00090 extract_directory (FILE *fptr, {\cf17 const} uint16_t block_size, {\cf17 const} {\cf18 char} *path)\par
00091 \{\par
00092   directory dir;\par
00093   create_directory (&dir);\par
00094   process_directory (fptr, &dir);\par
00095 \par
00096   hh_log (HH_LOG_INFO, {\cf22 "Extracting directory: %s"}, path);\par
00097 \par
00098   {\cf19 for} ({\cf18 size_t} i = 0x0; i < dir.current_record; i++)\par
00099     \{\par
00100       directory_record curr_file = dir.records[i];\par
00101 \par
00102       {\cf19 if} (curr_file.file_flags.subdirectory)\par
00103         \{\par
00104           {\cf19 continue};\par
00105         \}\par
00106       {\cf19 else} {\cf19 if} (OP_DEBUG_MODE\par
00107                && curr_file.data_length > OP_DEBUG_FILE_SIZE_LIMIT)\par
00108         \{\par
00109           hh_log (HH_LOG_INFO, {\cf22 "[DEBUG_MODE]Skipping file, %s."},\par
00110                   curr_file.file_identifier);\par
00111           {\cf19 continue};\par
00112         \}\par
00113 \par
00114       fseek (fptr, curr_file.location_of_extent * block_size, SEEK_SET);\par
00115 \par
00116       {\cf19 if} (extract_file_using_dir_record (fptr, &curr_file, path) != 0)\par
00117         \{\par
00118           destroy_directory (&dir);\par
00119           {\cf19 return} -1;\par
00120         \}\par
00121     \}\par
00122 \par
00123   destroy_directory (&dir);\par
00124   {\cf19 return} 0;\par
00125 \}\par
00126 \par
00127 int8_t\par
00128 create_directories_and_extract_data_from_path_file (FILE *fptr,\par
00129                                                     uint16_t block_size,\par
00130                                                     path_table *pt)\par
00131 \{\par
00132   {\cf19 for} ({\cf18 size_t} i = pt->current_entry - 1; i > 0; --i)\par
00133     \{\par
00134       path_table_entry curr_dir = pt->entries[i];\par
00135       path_table_entry target_dir = curr_dir;\par
00136 \par
00137       {\cf20 // supports 10 levels of directories which is probably overkill.}\par
00138       {\cf17 const} uint32_t PATH_MAX_LEN\par
00139           = ((curr_dir.directory_identifier_length + 1) * 10)\par
00140             + (strlen (OP_OUTPUT_DIR) + 1) + (strlen (CURRENT_DISK_NAME) + 1)\par
00141             + 1;\par
00142       {\cf18 char} *path = calloc (PATH_MAX_LEN, {\cf17 sizeof} ({\cf18 char}));\par
00143       {\cf19 if} (path == NULL)\par
00144         \{\par
00145           {\cf19 return} handle_calloc_error (PATH_MAX_LEN);\par
00146         \}\par
00147 \par
00148       strcat (path, curr_dir.directory_identifier);\par
00149 \par
00150       {\cf19 do}\par
00151         \{\par
00152           uint16_t index\par
00153               = change_endianness_uint16 (curr_dir.parent_directory_number);\par
00154 \par
00155           {\cf20 // parent_directory_number is 1-based}\par
00156           curr_dir = pt->entries[index - 1];\par
00157 \par
00158           {\cf19 if} (prepend_path_string (path,\par
00159                                    ({\cf17 const} {\cf18 char} *)curr_dir.directory_identifier)\par
00160               != 0)\par
00161             \{\par
00162               free (path);\par
00163               {\cf19 return} -1;\par
00164             \}\par
00165         \}\par
00166       {\cf19 while} (curr_dir.parent_directory_number > 0x0100);\par
00167 \par
00168       {\cf19 if} (create_output_directory (path) != 0)\par
00169         {\cf19 return} -1;\par
00170 \par
00171       fseek (fptr, block_size * target_dir.location_of_extent, SEEK_SET);\par
00172 \par
00173       {\cf19 if} (extract_directory (fptr, block_size, path) != 0)\par
00174         {\cf19 return} -1;\par
00175 \par
00176       free (path);\par
00177     \}\par
00178 \par
00179   {\cf19 return} 0;\par
00180 \}\par
00181 \par
00182 int8_t\par
00183 extract_file_using_idx_entry (FILE *fptr, index_entry *idx, {\cf17 const} {\cf18 char} *path)\par
00184 \{\par
00185   hh_log (HH_LOG_INFO, {\cf22 "Extracting file: %s"}, path);\par
00186 \par
00187   FILE *output_file = fopen (path, {\cf22 "wb"});\par
00188   {\cf19 if} (output_file == NULL)\par
00189     \{\par
00190       {\cf18 char} tmp[256] = \{ 0 \};\par
00191       strncpy (tmp, path, strlen (path) - strlen (idx->filename));\par
00192 \par
00193       {\cf19 if} (create_new_output_directory (tmp) != 0)\par
00194         {\cf19 return} -1;\par
00195 \par
00196       output_file = fopen (path, {\cf22 "wb"});\par
00197       {\cf19 if} (output_file == NULL)\par
00198         \{\par
00199           hh_log (HH_LOG_ERROR, {\cf22 "Error opening output file, %s."}, path);\par
00200           {\cf19 return} HH_FOPEN_ERROR;\par
00201         \}\par
00202     \}\par
00203 \par
00204   fseek (fptr, idx->start, SEEK_SET);\par
00205 \par
00206   {\cf19 for} (uint32_t i = 0x0; i < idx->size; i++)\par
00207     \{\par
00208       uint8_t byte;\par
00209       {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00210         \{\par
00211           fclose (output_file);\par
00212           {\cf19 return} -1;\par
00213         \}\par
00214 \par
00215       fwrite (&{\cf18 byte}, {\cf17 sizeof} (uint8_t), 1, output_file);\par
00216     \}\par
00217 \par
00218   fclose (output_file);\par
00219   {\cf19 return} 0;\par
00220 \}\par
00221 \par
00222 int8_t\par
00223 extract_index_file (index_file *idx, {\cf17 const} {\cf18 char} *idx_path,\par
00224                     {\cf17 const} {\cf18 char} *dat_path)\par
00225 \{\par
00226   FILE *dat_file = fopen (dat_path, {\cf22 "rb"});\par
00227   {\cf19 if} (dat_file == NULL)\par
00228     \{\par
00229       {\cf19 return} handle_fopen_error (({\cf18 char} *)dat_path);\par
00230     \}\par
00231 \par
00232   {\cf19 for} ({\cf18 size_t} i = 0; i < idx->current_index; i++)\par
00233     \{\par
00234       {\cf18 char} output_path[256] = \{ 0 \};\par
00235 \par
00240       strncpy (output_path, idx_path, strlen (idx_path) - 10);\par
00241       strcat (output_path, idx->indicies[i].full_path);\par
00242 \par
00243       {\cf19 if} (extract_file_using_idx_entry (dat_file, &idx->indicies[i],\par
00244                                         output_path)\par
00245           != 0)\par
00246         \{\par
00247           fclose (dat_file);\par
00248           {\cf19 return} -1;\par
00249         \}\par
00250     \}\par
00251 \par
00252   fclose (dat_file);\par
00253   {\cf19 return} 0;\par
00254 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/extractor.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/extractor.h}
{\xe \v src/extractor.h}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "directory.h"}\par
{\f2 #include "index_file.h"}\par
{\f2 #include "path_table.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_dir_record} (FILE *fptr, struct {\b directory_record} *dr, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file_using_idx_entry} (FILE *fptr, {\b index_entry} *idx, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts a file using its corresponding {\f2 {\b index_entry}}  and data pointed to by {\f2 fptr} , outputting it to the location denoated by {\f2 path} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_directory} (FILE *fptr, const uint16_t block_size, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_index_file} ({\b index_file} *idx, const char *idx_path, const char *dat_path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts all of the files described in the given {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directories_and_extract_data_from_path_file} (FILE *fptr, uint16_t block_size, struct {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_directories_and_extract_data_from_path_file\:extractor.h}
{\xe \v extractor.h\:create_directories_and_extract_data_from_path_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directories_and_extract_data_from_path_file (FILE * fptr, uint16_t block_size, struct {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper for {\f2 extract_directory}  and, therefore also, {\f2 extract_file_using_dir_record}  which handles the extraction of every file and subdirectory using a given path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i block_size} \cell }{logical block size (in big endian form). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b extract_directory()} \par
{\b extract_file_using_dir_record()} \par
}}}{
Definition at line {\b 128} of file {\b extractor.c}.}\par
}
{\xe \v extract_directory\:extractor.h}
{\xe \v extractor.h\:extract_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_directory (FILE * fptr, const uint16_t block_size, const char * path)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }}\par
{
Definition at line {\b 90} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_dir_record\:extractor.h}
{\xe \v extractor.h\:extract_file_using_dir_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_dir_record (FILE * fptr, struct {\b directory_record} * dr, const char * path)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions return zero on success, non-zero on failure. Extracts a file using its respective {\f2 {\b directory_record}}  and data pointed to by {\f2 fptr} , outputting it to the location denoted by {\f2 path} . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 file_identifier}  terminates with a {\f2 ;}  character followed by the file ID number in ASCII coded decimal ({\f2 1} ). See: {\f2 https://wiki.osdev.org/ISO_9660#Directories}\par
Just use the default/existing filename. It'll be incorrect, but probably not worth stoping execution over. Users could just manually remove the {\f2 ;1}  part; the data itself should be fine.\par
}{
Definition at line {\b 27} of file {\b extractor.c}.}\par
}
{\xe \v extract_file_using_idx_entry\:extractor.h}
{\xe \v extractor.h\:extract_file_using_idx_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file_using_idx_entry (FILE * fptr, {\b index_entry} * idx, const char * path)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts a file using its corresponding {\f2 {\b index_entry}}  and data pointed to by {\f2 fptr} , outputting it to the location denoated by {\f2 path} . }}\par
{
Definition at line {\b 183} of file {\b extractor.c}.}\par
}
{\xe \v extract_index_file\:extractor.h}
{\xe \v extractor.h\:extract_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_index_file ({\b index_file} * idx, const char * idx_path, const char * dat_path)}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts all of the files described in the given {\f2 {\b index_file}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 idx_path}  is needed to build an output path.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i `idx_path`} \cell }{relative path to the given {\f2 {\b index_file}} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i `dat_path`} \cell }{relative path to the corresponding dat file. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gives you the {\f2 OP_OUTPUT_DIR/DISK#/}  part of the path. 10 = len("INDEX.001")\par
}{
Definition at line {\b 223} of file {\b extractor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
extractor.h\par \pard\plain 
{\tc\tcl2 \v src/extractor.h}
{\xe \v src/extractor.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00019 {\cf21 #ifndef _HH_EXTRACTOR_H_}\par
00020 {\cf21 #define _HH_EXTRACTOR_H_}\par
00021 \par
00022 {\cf21 #include "directory.h"}\par
00023 {\cf21 #include "index_file.h"}\par
00024 {\cf21 #include "path_table.h"}\par
00025 \par
00026 {\cf21 #include <stdint.h>}\par
00027 {\cf21 #include <stdio.h>}\par
00028 \par
00033 int8_t extract_file_using_dir_record (FILE *fptr, {\cf17 struct} directory_record *dr,\par
00034                                       {\cf17 const} {\cf18 char} *path);\par
00039 int8_t extract_file_using_idx_entry (FILE *fptr, index_entry *idx,\par
00040                                      {\cf17 const} {\cf18 char} *path);\par
00041 \par
00043 int8_t extract_directory (FILE *fptr, {\cf17 const} uint16_t block_size,\par
00044                           {\cf17 const} {\cf18 char} *path);\par
00045 \par
00053 int8_t extract_index_file (index_file *idx, {\cf17 const} {\cf18 char} *idx_path,\par
00054                            {\cf17 const} {\cf18 char} *dat_path);\par
00055 \par
00066 int8_t create_directories_and_extract_data_from_path_file (\par
00067     FILE *fptr, uint16_t block_size, {\cf17 struct} path_table *pt);\par
00068 \par
00069 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_flags.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "file_flags.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b create_file_flags} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_file_flags} ({\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_file_flags\:file_flags.c}
{\xe \v file_flags.c\:create_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} create_file_flags (void )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }}\par
{
Definition at line {\b 19} of file {\b file_flags.c}.}\par
}
{\xe \v print_file_flags\:file_flags.c}
{\xe \v file_flags.c\:print_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_file_flags ({\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }}\par
{
Definition at line {\b 31} of file {\b file_flags.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags.c\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "file_flags.h"}\par
00015 \par
00016 {\cf21 #include <stdio.h>}\par
00017 \par
00018 file_flags\par
00019 create_file_flags ({\cf18 void})\par
00020 \{\par
00021   file_flags ff;\par
00022   ff.hidden = {\cf17 false};\par
00023   ff.subdirectory = {\cf17 false};\par
00024   ff.associated_file = {\cf17 false};\par
00025   ff.extended_attribute_record_contains_owner_and_group_permissions = {\cf17 false};\par
00026   ff.final_directory_record = {\cf17 false};\par
00027   {\cf19 return} ff;\par
00028 \}\par
00029 \par
00030 {\cf18 void}\par
00031 print_file_flags (file_flags *ff)\par
00032 \{\par
00033   printf ({\cf22 "\\tHidden: %d\\n"}, ff->hidden);\par
00034   printf ({\cf22 "\\tSubdirectory: %d\\n"}, ff->subdirectory);\par
00035   printf ({\cf22 "\\tAssociated file: %d\\n"}, ff->associated_file);\par
00036   printf (\par
00037       {\cf22 "\\tExtended attrib. record contains owner and group permissions: %d\\n"},\par
00038       ff->extended_attribute_record_contains_owner_and_group_permissions);\par
00039   printf ({\cf22 "\\tFinal directory record: %d\\n"}, ff->final_directory_record);\par
00040 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_flags.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_flags.h}
{\xe \v src/file_flags.h}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b file_flags}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b create_file_flags} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_file_flags} ({\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_file_flags\:file_flags.h}
{\xe \v file_flags.h\:create_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} create_file_flags (void )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }}\par
{
Definition at line {\b 19} of file {\b file_flags.c}.}\par
}
{\xe \v print_file_flags\:file_flags.h}
{\xe \v file_flags.h\:print_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_file_flags ({\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }}\par
{
Definition at line {\b 31} of file {\b file_flags.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags.h\par \pard\plain 
{\tc\tcl2 \v src/file_flags.h}
{\xe \v src/file_flags.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_FILE_FLAGS_H_}\par
00016 {\cf21 #define _HH_FILE_FLAGS_H_}\par
00017 \par
00018 {\cf21 #include <stdbool.h>}\par
00019 {\cf21 #include <stdint.h>}\par
00020 \par
00027 {\cf17 typedef} {\cf17 struct }file_flags\par
00028 \{\par
00029   {\cf18 bool} hidden;\par
00030   {\cf18 bool} subdirectory;\par
00031   {\cf18 bool} associated_file; \par
00032   {\cf18 bool} extended_attribute_record_contains_owner_and_group_permissions;\par
00037   {\cf18 bool} final_directory_record;\par
00038 \} file_flags;\par
00039 \par
00041 file_flags create_file_flags ({\cf18 void});\par
00042 \par
00047 {\cf18 void} print_file_flags (file_flags *ff);\par
00048 \par
00049 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/hh.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "hh.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "extractor.h"}\par
{\f2 #include "index_file.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "path_table.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include "volume_descriptor.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b setup_extractor} (FILE **fptr, char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_DAT_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b batch_process_DAT_files} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_internal_dat_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v batch_process_DAT_files\:hh.c}
{\xe \v hh.c\:batch_process_DAT_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t batch_process_DAT_files (void )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 180} of file {\b hh.c}.}\par
}
{\xe \v main\:hh.c}
{\xe \v hh.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b hh.c}.}\par
}
{\xe \v process_DAT_file\:hh.c}
{\xe \v hh.c\:process_DAT_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_DAT_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is accomplished by first processing the volume descriptor header (checking that this is indeed a primary volume descriptor after it does so) and the volume descriptor data. Once complete, it updates the {\f2 CURRENT_DISK_NAME}  variable using the appropriate data. Finally, it constructs a path table, a extracts every file from the given DAT file to the {\f2 OP_OUTPUT_DIR} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to a DAT file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660} \par
{\b process_volume_descriptor_header()} \par
{\b process_volume_descriptor_data()} \par
{\b create_path_table()} \par
{\b process_type_l_path_table()} \par
{\b extract_directory()} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 94} of file {\b hh.c}.}\par
}
{\xe \v process_internal_dat_files\:hh.c}
{\xe \v hh.c\:process_internal_dat_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_internal_dat_files (void )}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These {\f2 .DAT}  files are not ISO 9660 file systems, rather they're some proprietary format. These files can be processed by reading the associated {\f2 INDEX.00#}  file, which contains all the filenames, paths, and location of data for files stored in these new {\f2 .DAT}  files.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int8_t zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 300} of file {\b hh.c}.}\par
}
{\xe \v setup_extractor\:hh.c}
{\xe \v hh.c\:setup_extractor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t setup_extractor (FILE ** fptr, char * filename)}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\f2 FILE *}  for the given {\f2 filename} , handling error messages as needed, while also checking the end-user's operating system and updating {\f2 OP_PATH_SEPARATOR} . The caller is responsible for closing the file pointer when they're finished with it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to the file associated with the given filename \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{the path to a DAT file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 71} of file {\b hh.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hh.c\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "hh.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "extractor.h"}\par
00018 {\cf21 #include "index_file.h"}\par
00019 {\cf21 #include "log.h"}\par
00020 {\cf21 #include "options.h"}\par
00021 {\cf21 #include "path_table.h"}\par
00022 {\cf21 #include "utils.h"}\par
00023 {\cf21 #include "volume_descriptor.h"}\par
00024 \par
00025 {\cf21 #include <stdbool.h>}\par
00026 {\cf21 #include <stdint.h>}\par
00027 {\cf21 #include <stdio.h>}\par
00028 {\cf21 #include <stdlib.h>}\par
00029 {\cf21 #include <string.h>}\par
00030 {\cf21 #include <time.h>}\par
00031 \par
00032 {\cf21 #ifdef _WIN32}\par
00033 {\cf21 #include <windows.h>}\par
00034 {\cf21 #else}\par
00035 {\cf21 #include <dirent.h>}\par
00036 {\cf21 #endif}\par
00037 \par
00038 {\cf18 int}\par
00039 main ({\cf18 int} argc, {\cf18 char} **argv)\par
00040 \{\par
00041   FILE *fptr = NULL;\par
00042 \par
00043   {\cf19 if} (argc >= 2)\par
00044     handle_command_line_args (argc, argv);\par
00045 \par
00046   {\cf19 if} (OP_BATCH_PROCESS && !OP_SKIP_DAT_PROCESSING)\par
00047     \{\par
00048       {\cf19 if} (batch_process_DAT_files () != 0)\par
00049         exit (1);\par
00050     \}\par
00051   {\cf19 else} {\cf19 if} (!OP_SKIP_DAT_PROCESSING)\par
00052     \{\par
00053       {\cf19 if} (setup_extractor (&fptr, argv[argc - 1]) != 0)\par
00054         exit (1);\par
00055 \par
00056       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00057         exit (1);\par
00058 \par
00059       fclose (fptr);\par
00060     \}\par
00061 \par
00062   {\cf19 if} (!OP_SKIP_INT_DAT_PROCESSING && process_internal_dat_files () != 0)\par
00063     \{\par
00064       exit (1);\par
00065     \}\par
00066 \par
00067   {\cf19 return} 0;\par
00068 \}\par
00069 \par
00070 int8_t\par
00071 setup_extractor (FILE **fptr, {\cf18 char} *filename)\par
00072 \{\par
00073   *fptr = fopen (filename, {\cf22 "rb"});\par
00074   {\cf19 if} (*fptr == NULL)\par
00075     \{\par
00076       handle_fopen_error (filename);\par
00077       {\cf20 /*}\par
00078 {\cf20        * Need to explicitly return `HH_FOPEN_ERROR` here otherwise gcc}\par
00079 {\cf20        * complains}\par
00080 {\cf20        */}\par
00081       {\cf19 return} HH_FOPEN_ERROR;\par
00082     \}\par
00083 \par
00084 {\cf21 #ifdef _WIN32}\par
00085   OP_PATH_SEPARATOR = {\cf23 '\\\\'};\par
00086 {\cf21 #else}\par
00087   OP_PATH_SEPARATOR = {\cf23 '/'};\par
00088 {\cf21 #endif}\par
00089 \par
00090   {\cf19 return} 0;\par
00091 \}\par
00092 \par
00093 int8_t\par
00094 process_DAT_file (FILE *fptr)\par
00095 \{\par
00096   {\cf20 /*}\par
00097 {\cf20    * First 32k (up to 0x8000) stores the `system area` of the disk.}\par
00098 {\cf20    * Unused by HARVEST.DAT, HARVEST3.DAT, HARVEST4.DAT.}\par
00099 {\cf20    * See: https://wiki.osdev.org/ISO_9660#System_Area}\par
00100 {\cf20    */}\par
00101   fseek (fptr, 0x8000, SEEK_SET);\par
00102 \par
00103   volume_descriptor vd;\par
00104   {\cf19 if} (process_volume_descriptor_header (fptr, &vd) != 0)\par
00105     {\cf19 return} -1;\par
00106 \par
00107   {\cf20 // Verify that this is a primary volume descriptor}\par
00108   {\cf19 if} (vd.type_code != 0x01)\par
00109     \{\par
00110       hh_log (HH_LOG_ERROR,\par
00111               {\cf22 "Unexpected volume descriptor type code. Expected 0x%02X, got "}\par
00112               {\cf22 "0x%02X."},\par
00113               0x01, vd.type_code);\par
00114       {\cf19 return} -1;\par
00115     \}\par
00116 \par
00117   {\cf19 if} (process_volume_descriptor_data (fptr, &vd.data) != 0)\par
00118     {\cf19 return} -1;\par
00119 \par
00120   {\cf18 size_t} current_disk_name_length = strcspn (vd.data.volume_identifier, {\cf22 " "});\par
00121   CURRENT_DISK_NAME = vd.data.volume_identifier;\par
00122   CURRENT_DISK_NAME[current_disk_name_length] = {\cf23 '\\0'};\par
00123 \par
00124   {\cf20 // TODO: print the volume descriptor header/data to some file/log.}\par
00125 \par
00126   {\cf20 // logical block size, in big endian form}\par
00127   {\cf17 const} uint16_t block_size_be\par
00128       = change_endianness_uint16 (vd.data.logical_block_size);\par
00129 \par
00130   {\cf20 // move to beginning of type-l path table}\par
00131   fseek (fptr, block_size_be * vd.data.type_l_path_table_location, SEEK_SET);\par
00132 \par
00133   path_table pt;\par
00134   {\cf19 if} (create_path_table (&pt) != 0)\par
00135     {\cf19 return} -1;\par
00136 \par
00137   {\cf19 if} (process_type_l_path_table (fptr, &pt) != 0)\par
00138     \{\par
00139       destroy_path_table (&pt);\par
00140       {\cf19 return} -1;\par
00141     \}\par
00142 \par
00143   {\cf19 if} (create_directories_and_extract_data_from_path_file (fptr, block_size_be,\par
00144                                                           &pt)\par
00145       != 0)\par
00146     \{\par
00147       destroy_path_table (&pt);\par
00148       {\cf19 return} -1;\par
00149     \}\par
00150 \par
00151   {\cf20 // handle root directory}\par
00152   fseek (fptr, block_size_be * pt.entries[0].location_of_extent, SEEK_SET);\par
00153 \par
00154   {\cf18 char} *path = calloc (strlen (OP_OUTPUT_DIR) + current_disk_name_length + 2,\par
00155                        {\cf17 sizeof} ({\cf18 char}));\par
00156   {\cf19 if} (path == NULL)\par
00157     \{\par
00158       destroy_path_table (&pt);\par
00159       {\cf19 return} handle_calloc_error (strlen (OP_OUTPUT_DIR)\par
00160                                   + current_disk_name_length + 2);\par
00161     \}\par
00162 \par
00163   strcpy (path, OP_OUTPUT_DIR);\par
00164   strcat (path, &OP_PATH_SEPARATOR);\par
00165   strcat (path, CURRENT_DISK_NAME);\par
00166 \par
00167   {\cf19 if} (extract_directory (fptr, block_size_be, path) != 0)\par
00168     \{\par
00169       free (path);\par
00170       destroy_path_table (&pt);\par
00171       {\cf19 return} -1;\par
00172     \}\par
00173 \par
00174   free (path);\par
00175   destroy_path_table (&pt);\par
00176   {\cf19 return} 0;\par
00177 \}\par
00178 \par
00179 int8_t\par
00180 batch_process_DAT_files ()\par
00181 \{\par
00182   {\cf17 const} {\cf18 char} *OPEN_INPUT_DIR_ERR_MSG_FMT\par
00183       = {\cf22 "[HarvesterHarvester]ERROR: Error opening input directory, %s."};\par
00184   {\cf17 const} uint8_t DAT_FILENAME_LEN = strlen ({\cf22 "HARVESTX.DAT"});\par
00185   {\cf18 char} *filename;\par
00186 \par
00187 {\cf21 #ifdef _WIN32}\par
00188   WIN32_FIND_DATAA file_data;\par
00189   HANDLE hFind;\par
00190   {\cf18 char} search_path[256];\par
00191   strcpy (search_path, OP_INPUT_DIR);\par
00192   strcat (search_path, {\cf22 "\\\\*"});\par
00193 \par
00194   hFind = FindFirstFileA (search_path, &file_data);\par
00195   {\cf19 if} (hFind == INVALID_HANDLE_VALUE)\par
00196     \{\par
00197       hh_log (HH_LOG_ERROR, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00198       {\cf19 return} -1;\par
00199     \}\par
00200 \par
00201   {\cf19 do}\par
00202     \{\par
00203       {\cf19 if} (strcmp (file_data.cFileName, {\cf22 "."}) == 0\par
00204           || strcmp (file_data.cFileName, {\cf22 ".."}) == 0\par
00205           || !is_string_dat_file (file_data.cFileName))\par
00206         \{\par
00207           {\cf19 continue};\par
00208         \}\par
00209 \par
00210       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00211                          {\cf17 sizeof} ({\cf18 char}));\par
00212       {\cf19 if} (filename == NULL)\par
00213         \{\par
00214           {\cf19 return} handle_calloc_error (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN\par
00215                                       + 2);\par
00216         \}\par
00217 \par
00218       strcpy (filename, OP_INPUT_DIR);\par
00219       strcat (filename, &OP_PATH_SEPARATOR);\par
00220       strcat (filename, file_data.cFileName);\par
00221 \par
00222       FILE *fptr = NULL;\par
00223       {\cf19 if} (setup_extractor (&fptr, filename) != 0)\par
00224         \{\par
00225           free (filename);\par
00226           FindClose (hFind);\par
00227           {\cf19 return} HH_FOPEN_ERROR;\par
00228         \}\par
00229 \par
00230       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00231         \{\par
00232           fclose (fptr);\par
00233           free (filename);\par
00234           FindClose (hFind);\par
00235           {\cf19 return} -1;\par
00236         \}\par
00237 \par
00238       fclose (fptr);\par
00239       free (filename);\par
00240     \}\par
00241   {\cf19 while} (FindNextFileA (hFind, &file_data) != 0);\par
00242 \par
00243   FindClose (hFind);\par
00244 {\cf21 #else}\par
00245   {\cf17 struct }dirent *entry;\par
00246   DIR *dir;\par
00247   dir = opendir (OP_INPUT_DIR);\par
00248   {\cf19 if} (dir == NULL)\par
00249     \{\par
00250       hh_log (HH_LOG_ERROR, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00251       {\cf19 return} -1;\par
00252     \}\par
00253 \par
00254   {\cf19 while} ((entry = readdir (dir)) != NULL)\par
00255     \{\par
00256       {\cf19 if} (strcmp (entry->d_name, {\cf22 "."}) == 0 || strcmp (entry->d_name, {\cf22 ".."}) == 0\par
00257           || !is_string_dat_file (entry->d_name))\par
00258         \{\par
00259           {\cf19 continue};\par
00260         \}\par
00261 \par
00262       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00263                          {\cf17 sizeof} ({\cf18 char}));\par
00264       {\cf19 if} (filename == NULL)\par
00265         \{\par
00266           {\cf19 return} handle_calloc_error (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN\par
00267                                       + 2);\par
00268         \}\par
00269 \par
00270       strcpy (filename, OP_INPUT_DIR);\par
00271       strcat (filename, &OP_PATH_SEPARATOR);\par
00272       strcat (filename, entry->d_name);\par
00273 \par
00274       FILE *fptr = NULL;\par
00275       {\cf19 if} (setup_extractor (&fptr, filename) != 0)\par
00276         \{\par
00277           free (filename);\par
00278           closedir (dir);\par
00279           {\cf19 return} HH_FOPEN_ERROR;\par
00280         \}\par
00281 \par
00282       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00283         \{\par
00284           fclose (fptr);\par
00285           free (filename);\par
00286           closedir (dir);\par
00287           {\cf19 return} -1;\par
00288         \}\par
00289 \par
00290       fclose (fptr);\par
00291       free (filename);\par
00292     \}\par
00293 \par
00294   closedir (dir);\par
00295 {\cf21 #endif}\par
00296   {\cf19 return} 0;\par
00297 \}\par
00298 \par
00299 int8_t\par
00300 process_internal_dat_files ({\cf18 void})\par
00301 \{\par
00302   {\cf17 const} {\cf18 char} *interal_paths = {\cf22 "internal-dat-file-paths.txt"};\par
00303   FILE *table = fopen (interal_paths, {\cf22 "rb"});\par
00304   {\cf19 if} (table == NULL)\par
00305     \{\par
00306       {\cf19 return} handle_fopen_error (({\cf18 char} *)interal_paths);\par
00307     \}\par
00308 \par
00309   {\cf19 while} (!peek_eof (table))\par
00310     \{\par
00311       {\cf20 // TODO: convert as many malloc'd strings to char arrays as possible.}\par
00312       {\cf18 char} index_file_path[256] = \{ 0 \};\par
00313       build_path_string_from_file (table, index_file_path);\par
00314 \par
00315       FILE *fptr = NULL;\par
00316       {\cf19 if} (setup_extractor (&fptr, index_file_path) != 0)\par
00317         \{\par
00318           hh_log (HH_LOG_WARNING, {\cf22 "Skipping..."});\par
00319 \par
00320           {\cf20 // Skip next line}\par
00321           build_path_string_from_file (table, index_file_path);\par
00322 \par
00323           {\cf19 continue};\par
00324         \}\par
00325 \par
00326       index_file idx_file;\par
00327       {\cf19 if} (create_index_file (&idx_file) != 0)\par
00328         \{\par
00329           fclose (fptr);\par
00330           fclose (table);\par
00331           {\cf19 return} -1;\par
00332         \}\par
00333 \par
00334       hh_log (HH_LOG_INFO, {\cf22 "Processing index file: %s"}, index_file_path);\par
00335       {\cf19 if} (process_index_file (fptr, &idx_file) != 0)\par
00336         \{\par
00337           destroy_index_file (&idx_file);\par
00338           fclose (table);\par
00339           fclose (fptr);\par
00340           {\cf19 return} -1;\par
00341         \}\par
00342       fclose (fptr);\par
00343 \par
00344       {\cf18 char} dat_file_path[256] = \{ 0 \};\par
00345       build_path_string_from_file (table, dat_file_path);\par
00346 \par
00347       {\cf19 if} (extract_index_file (&idx_file, index_file_path, dat_file_path) != 0)\par
00348         \{\par
00349           destroy_index_file (&idx_file);\par
00350           {\cf19 return} -1;\par
00351         \}\par
00352 \par
00353       destroy_index_file (&idx_file);\par
00354     \}\par
00355 \par
00356   fclose (table);\par
00357   {\cf19 return} 0;\par
00358 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/hh.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/hh.h}
{\xe \v src/hh.h}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b setup_extractor} (FILE **fptr, char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b process_DAT_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b batch_process_DAT_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b process_internal_dat_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v batch_process_DAT_files\:hh.h}
{\xe \v hh.h\:batch_process_DAT_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t batch_process_DAT_files (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 180} of file {\b hh.c}.}\par
}
{\xe \v process_DAT_file\:hh.h}
{\xe \v hh.h\:process_DAT_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t process_DAT_file (FILE * fptr){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is accomplished by first processing the volume descriptor header (checking that this is indeed a primary volume descriptor after it does so) and the volume descriptor data. Once complete, it updates the {\f2 CURRENT_DISK_NAME}  variable using the appropriate data. Finally, it constructs a path table, a extracts every file from the given DAT file to the {\f2 OP_OUTPUT_DIR} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to a DAT file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660} \par
{\b process_volume_descriptor_header()} \par
{\b process_volume_descriptor_data()} \par
{\b create_path_table()} \par
{\b process_type_l_path_table()} \par
{\b extract_directory()} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 94} of file {\b hh.c}.}\par
}
{\xe \v process_internal_dat_files\:hh.h}
{\xe \v hh.h\:process_internal_dat_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t process_internal_dat_files (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These {\f2 .DAT}  files are not ISO 9660 file systems, rather they're some proprietary format. These files can be processed by reading the associated {\f2 INDEX.00#}  file, which contains all the filenames, paths, and location of data for files stored in these new {\f2 .DAT}  files.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int8_t zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 300} of file {\b hh.c}.}\par
}
{\xe \v setup_extractor\:hh.h}
{\xe \v hh.h\:setup_extractor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t setup_extractor (FILE ** fptr, char * filename){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\f2 FILE *}  for the given {\f2 filename} , handling error messages as needed, while also checking the end-user's operating system and updating {\f2 OP_PATH_SEPARATOR} . The caller is responsible for closing the file pointer when they're finished with it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to the file associated with the given filename \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{the path to a DAT file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 71} of file {\b hh.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hh.h\par \pard\plain 
{\tc\tcl2 \v src/hh.h}
{\xe \v src/hh.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00017 {\cf21 #ifndef _HARVESTER_HARVESTER_H_}\par
00018 {\cf21 #define _HARVESTER_HARVESTER_H_}\par
00019 \par
00020 {\cf21 #include <stdint.h>}\par
00021 {\cf21 #include <stdio.h>}\par
00022 \par
00033 {\cf17 static} int8_t setup_extractor (FILE **fptr, {\cf18 char} *filename);\par
00034 \par
00053 {\cf17 static} int8_t process_DAT_file (FILE *fptr);\par
00054 \par
00060 {\cf17 static} int8_t batch_process_DAT_files ({\cf18 void});\par
00061 \par
00071 {\cf17 static} int8_t process_internal_dat_files ({\cf18 void});\par
00072 \par
00073 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/index_file.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "index_file.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_indicies} ({\b index_file} *idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 {\b index_file}} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b destroy_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_index_file} (FILE *fptr, {\b index_file} *idxf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_index_entry} ({\b index_entry} *idxe)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_entry_to_index_file} ({\b index_file} *file, {\b index_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_STARTING_NUM_INDICIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_index_file\:index_file.c}
{\xe \v index_file.c\:add_entry_to_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_index_file ({\b index_file} * file, {\b index_entry} * entry)}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 137} of file {\b index_file.c}.}\par
}
{\xe \v create_index_file\:index_file.c}
{\xe \v index_file.c\:create_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 34} of file {\b index_file.c}.}\par
}
{\xe \v destroy_index_file\:index_file.c}
{\xe \v index_file.c\:destroy_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t destroy_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 49} of file {\b index_file.c}.}\par
}
{\xe \v print_index_entry\:index_file.c}
{\xe \v index_file.c\:print_index_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_index_entry ({\b index_entry} * idxe)}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }}\par
{
Definition at line {\b 127} of file {\b index_file.c}.}\par
}
{\xe \v process_index_file\:index_file.c}
{\xe \v index_file.c\:process_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_index_file (FILE * fptr, {\b index_file} * idxf)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every entry is 0x94 bytes apart, the part we're most concerned about is the last 16 bytes. Currently treating unknown data in between as junk. If you have any idea what this data might be used for, please feel free to make changes.\par
}{
Definition at line {\b 56} of file {\b index_file.c}.}\par
}
{\xe \v resize_indicies\:index_file.c}
{\xe \v index_file.c\:resize_indicies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_indicies ({\b index_file} * idx){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 {\b index_file}} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 153} of file {\b index_file.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDX_RECORDS_GROWTH_RATE\:index_file.c}
{\xe \v index_file.c\:IDX_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b index_file.c}.}\par
}
{\xe \v IDX_STARTING_NUM_INDICIES\:index_file.c}
{\xe \v index_file.c\:IDX_STARTING_NUM_INDICIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_STARTING_NUM_INDICIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b index_file.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file.c\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "index_file.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 {\cf21 #include "utils.h"}\par
00020 \par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 \par
00024 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_STARTING_NUM_INDICIES = 10;\par
00025 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_RECORDS_GROWTH_RATE = 2;\par
00026 \par
00031 {\cf17 static} int8_t resize_indicies (index_file *idx);\par
00032 \par
00033 int8_t\par
00034 create_index_file (index_file *i)\par
00035 \{\par
00036   i->indicies = malloc (IDX_STARTING_NUM_INDICIES * {\cf17 sizeof} (index_entry));\par
00037   {\cf19 if} (i->indicies == NULL)\par
00038     \{\par
00039       {\cf19 return} handle_malloc_error ({\cf22 "index file indicies."});\par
00040     \}\par
00041 \par
00042   i->size = IDX_STARTING_NUM_INDICIES;\par
00043   i->current_index = 0;\par
00044 \par
00045   {\cf19 return} 0;\par
00046 \}\par
00047 \par
00048 int8_t\par
00049 destroy_index_file (index_file *i)\par
00050 \{\par
00051   free (i->indicies);\par
00052   {\cf19 return} 0;\par
00053 \}\par
00054 \par
00055 int8_t\par
00056 process_index_file (FILE *fptr, index_file *idxf)\par
00057 \{\par
00058   {\cf19 while} (!peek_eof (fptr))\par
00059     \{\par
00060       index_entry entry;\par
00061       entry.entry_start = ftell (fptr);\par
00062 \par
00063       fseek (fptr, 0x5, SEEK_CUR); {\cf20 // skip `XFLE#`}\par
00064 \par
00065       {\cf19 if} (!peek_char_is (fptr, {\cf23 ':'}))\par
00066         \{\par
00067           hh_log (HH_LOG_ERROR,\par
00068                   {\cf22 "Unexpected character in index file. Aborting processing."});\par
00069           {\cf19 return} -1;\par
00070         \}\par
00071 \par
00072       {\cf19 if} (read_string (fptr, entry.full_path, (uint8_t)FULL_PATH_MAX_LEN) != 0)\par
00073         {\cf19 return} HH_FREAD_ERROR;\par
00074 \par
00075       uint8_t len = strlen (entry.full_path);\par
00076       {\cf18 char} *last_word = entry.full_path;\par
00077       {\cf19 for} (uint8_t i = 0; i < len; i++)\par
00078         \{\par
00079           {\cf19 if} (entry.full_path[i] == {\cf23 '\\\\'})\par
00080             \{\par
00081               last_word = entry.full_path + i + 1;\par
00082               entry.full_path[i] = OP_PATH_SEPARATOR;\par
00083             \}\par
00084         \}\par
00085       strcpy (entry.filename, last_word);\par
00086 \par
00093       fseek (fptr, entry.entry_start + (0x94 - 0x10), SEEK_SET);\par
00094 \par
00095       {\cf20 /* clang-format off */}\par
00096       {\cf19 if} ((read_little_endian_data_uint32_t (fptr, &entry.start) != 0)\par
00097           || (read_little_endian_data_uint32_t (fptr, &entry.size) != 0))\par
00098         \{\par
00099           {\cf19 return} HH_FREAD_ERROR;\par
00100         \}\par
00101       {\cf20 /* clang-format on */}\par
00102 \par
00103       fseek (fptr, 0x4, SEEK_CUR); {\cf20 // Skip zeros}\par
00104 \par
00105       {\cf20 // Very unnecessary, but we might as well double check our data}\par
00106       uint32_t value;\par
00107       {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00108         {\cf19 return} HH_FREAD_ERROR;\par
00109 \par
00110       {\cf19 if} (entry.size != value)\par
00111         \{\par
00112           hh_log (HH_LOG_ERROR, {\cf22 "Expected 0x%08X, got 0x%08X."}, entry.size,\par
00113                   value);\par
00114           {\cf19 return} -1;\par
00115         \}\par
00116 \par
00117       {\cf19 if} (add_entry_to_index_file (idxf, &entry) != 0)\par
00118         \{\par
00119           {\cf19 return} -1;\par
00120         \}\par
00121     \}\par
00122 \par
00123   {\cf19 return} 0;\par
00124 \}\par
00125 \par
00126 {\cf18 void}\par
00127 print_index_entry (index_entry *idxe)\par
00128 \{\par
00129   printf ({\cf22 "Entry start: %08X\\n"}, idxe->entry_start);\par
00130   printf ({\cf22 "Full path: %s\\n"}, idxe->full_path);\par
00131   printf ({\cf22 "Filename: %s\\n"}, idxe->filename);\par
00132   printf ({\cf22 "File start: %08X\\n"}, idxe->start);\par
00133   printf ({\cf22 "File size: %08X\\n"}, idxe->size);\par
00134 \}\par
00135 \par
00136 int8_t\par
00137 add_entry_to_index_file (index_file *file, index_entry *entry)\par
00138 \{\par
00139   {\cf19 if} (file->current_index >= file->size)\par
00140     \{\par
00141       {\cf19 if} (resize_indicies (file) != 0)\par
00142         \{\par
00143           {\cf19 return} -1;\par
00144         \}\par
00145     \}\par
00146 \par
00147   file->indicies[file->current_index] = *entry;\par
00148   file->current_index++;\par
00149   {\cf19 return} 0;\par
00150 \}\par
00151 \par
00152 int8_t\par
00153 resize_indicies (index_file *idx)\par
00154 \{\par
00155   {\cf18 size_t} new_size = idx->size * IDX_RECORDS_GROWTH_RATE;\par
00156   index_entry *new_indicies = (index_entry *)realloc (\par
00157       idx->indicies, new_size * sizeof (index_entry));\par
00158   {\cf19 if} (new_indicies == NULL)\par
00159     \{\par
00160       destroy_index_file (idx);\par
00161       {\cf19 return} handle_realloc_error ({\cf22 "indicies"}, idx->size, new_size);\par
00162     \}\par
00163 \par
00164   idx->indicies = new_indicies;\par
00165   idx->size = new_size;\par
00166   {\cf19 return} 0;\par
00167 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/index_file.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/index_file.h}
{\xe \v src/index_file.h}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_entry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A file entry in an {\f2 {\b index_file}} . }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_file}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FULL_PATH_MAX_LEN}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b index_file.h} - {\b index_file} datatype and its associated functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILENAME_MAX_LEN}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b destroy_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_index_file} (FILE *fptr, {\b index_file} *idxf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_index_entry} ({\b index_entry} *idxe)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_entry_to_index_file} ({\b index_file} *file, {\b index_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILENAME_MAX_LEN\:index_file.h}
{\xe \v index_file.h\:FILENAME_MAX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILENAME_MAX_LEN\~ 32}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b index_file.h}.}\par
}
{\xe \v FULL_PATH_MAX_LEN\:index_file.h}
{\xe \v index_file.h\:FULL_PATH_MAX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FULL_PATH_MAX_LEN\~ 128}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b index_file.h} - {\b index_file} datatype and its associated functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for processing Harvester's {\f2 INDEX.00#}  files. \par
Both the {\b index_file} datatype and the functions contained herein are based on my own observations from studying the {\f2 INDEX.00#}  files and their associated {\f2 .DAT}  files in a hexeditor. \par
Through these observations alone, I believe we have enough data to successfully extract files, however, it's worth noting that there is a fair bit of data that we're ignoring here. \par
Between the {\f2 filename}  and {\f2 start} , there's occasionally some data, but I can't for the life of me seem to figure out what it's used for. It could be random garbage generated by whatever program created these {\f2 .DAT} /{\f2 INDEX.00#}  files, or they could be file flags, or perhaps even some sort of primative checksum; I'm not sure. \par
If you have any idea what this data might be used for, feel free to make whatever changes are needed! Both of these are probably too large, but better to be safe than sorry. \par
}{
Definition at line {\b 39} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_index_file\:index_file.h}
{\xe \v index_file.h\:add_entry_to_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_index_file ({\b index_file} * file, {\b index_entry} * entry)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 137} of file {\b index_file.c}.}\par
}
{\xe \v create_index_file\:index_file.h}
{\xe \v index_file.h\:create_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 34} of file {\b index_file.c}.}\par
}
{\xe \v destroy_index_file\:index_file.h}
{\xe \v index_file.h\:destroy_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t destroy_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 49} of file {\b index_file.c}.}\par
}
{\xe \v print_index_entry\:index_file.h}
{\xe \v index_file.h\:print_index_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_index_entry ({\b index_entry} * idxe)}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }}\par
{
Definition at line {\b 127} of file {\b index_file.c}.}\par
}
{\xe \v process_index_file\:index_file.h}
{\xe \v index_file.h\:process_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_index_file (FILE * fptr, {\b index_file} * idxf)}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every entry is 0x94 bytes apart, the part we're most concerned about is the last 16 bytes. Currently treating unknown data in between as junk. If you have any idea what this data might be used for, please feel free to make changes.\par
}{
Definition at line {\b 56} of file {\b index_file.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file.h\par \pard\plain 
{\tc\tcl2 \v src/index_file.h}
{\xe \v src/index_file.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00032 {\cf21 #ifndef _HH_INDEX_FILE_H_}\par
00033 {\cf21 #define _HH_INDEX_FILE_H_}\par
00034 \par
00035 {\cf21 #include <stdint.h>}\par
00036 {\cf21 #include <stdio.h>}\par
00037 \par
00039 {\cf21 #define FULL_PATH_MAX_LEN 128}\par
00040 {\cf21 #define FILENAME_MAX_LEN 32}\par
00041 \par
00043 {\cf17 typedef} {\cf17 struct }index_entry\par
00044 \{\par
00045   uint32_t entry_start; \par
00046   {\cf18 char} full_path[FULL_PATH_MAX_LEN];\par
00047   {\cf18 char} filename[FILENAME_MAX_LEN];\par
00048   uint32_t start; \par
00049   uint32_t size;\par
00050 \} index_entry;\par
00051 \par
00053 {\cf17 typedef} {\cf17 struct }index_file\par
00054 \{\par
00055   index_entry *indicies;\par
00056   {\cf18 size_t} size;          \par
00057   {\cf18 size_t} current_index; \par
00058 \} index_file;\par
00059 \par
00061 int8_t create_index_file (index_file *i);\par
00062 \par
00064 int8_t destroy_index_file (index_file *i);\par
00065 \par
00070 int8_t process_index_file (FILE *fptr, index_file *idxf);\par
00071 \par
00076 {\cf18 void} print_index_entry (index_entry *idxe);\par
00077 \par
00079 int8_t add_entry_to_index_file (index_file *file, index_entry *entry);\par
00080 \par
00081 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "log.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BYTES_TO_READ}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_hex_data} (unsigned char *buffer, const uint8_t BUFFER_LEN)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_some_data_from_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hh_log} ({\b hh_log_level} lvl, const char *fmt,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A logger function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BYTES_TO_READ\:log.c}
{\xe \v log.c\:BYTES_TO_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BYTES_TO_READ\~ 32}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b log.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v hh_log\:log.c}
{\xe \v log.c\:hh_log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void hh_log ({\b hh_log_level} lvl, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A logger function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs fmt and args to either the stdout or stderr depending on the {\f2 lvl}  passed into the function. \par
}{
Definition at line {\b 69} of file {\b log.c}.}\par
}
{\xe \v print_hex_data\:log.c}
{\xe \v log.c\:print_hex_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_hex_data (unsigned char * buffer, const uint8_t BUFFER_LEN)}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Formats said data to add spaces between bytes, tabs after after every four bytes, and a new line after every 16 bytes.\par
TODO: These values are currently hardcoded in, but they likely should be moved to {\b options.h} in the future. \par
}{
Definition at line {\b 29} of file {\b log.c}.}\par
}
{\xe \v print_some_data_from_file\:log.c}
{\xe \v log.c\:print_some_data_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_some_data_from_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the next {\f2 BYTES_TO_READ}  many bytes to the stdout, formatted in order to be easy to read. \par
}{
Definition at line {\b 53} of file {\b log.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
log.c\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "log.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 \par
00017 {\cf21 #include <stdarg.h>}\par
00018 {\cf21 #include <stdio.h>}\par
00019 \par
00028 {\cf18 void}\par
00029 print_hex_data ({\cf18 unsigned} {\cf18 char} *buffer, {\cf17 const} uint8_t BUFFER_LEN)\par
00030 \{\par
00031   {\cf19 for} (uint8_t i = 0; i < BUFFER_LEN; i++)\par
00032     \{\par
00033       printf ({\cf22 " %02x"}, buffer[i]);\par
00034       {\cf19 if} ((i != 0) && (i % 4 == 3))\par
00035         \{\par
00036           printf ({\cf22 "\\t"});\par
00037         \}\par
00038       {\cf19 if} ((i != 0) && (i % 16 == 15))\par
00039         \{\par
00040           puts ({\cf22 ""});\par
00041         \}\par
00042     \}\par
00043   puts ({\cf22 ""});\par
00044 \}\par
00045 \par
00046 {\cf21 #define BYTES_TO_READ 32}\par
00052 {\cf18 void}\par
00053 print_some_data_from_file (FILE *fptr)\par
00054 \{\par
00055   {\cf18 unsigned} {\cf18 char} buffer[BYTES_TO_READ];\par
00056   {\cf18 size_t} bytes_read = fread (buffer, {\cf17 sizeof} (buffer[0]), BYTES_TO_READ, fptr);\par
00057   {\cf19 if} (bytes_read != BYTES_TO_READ)\par
00058     \{\par
00059       handle_fread_error (bytes_read, BYTES_TO_READ);\par
00060       {\cf19 return};\par
00061     \}\par
00062 \par
00063   print_hex_data (buffer, BYTES_TO_READ);\par
00064   fseek (fptr, -BYTES_TO_READ, SEEK_CUR);\par
00065 \}\par
00066 \par
00067 {\cf20 // TODO: add an command-line arg to output to a log file or to run silently.}\par
00068 {\cf18 void}\par
00069 hh_log (hh_log_level lvl, {\cf17 const} {\cf18 char} *fmt, ...)\par
00070 \{\par
00071   {\cf17 const} {\cf18 char} *program_tag = {\cf22 "[HarvesterHarvester]"};\par
00072   FILE *output_stream = stdout;\par
00073 \par
00074   {\cf19 switch} (lvl)\par
00075     \{\par
00076     {\cf19 case} HH_LOG_INFO:\par
00077       fprintf (stdout, {\cf22 "%s[INFO] "}, program_tag);\par
00078       output_stream = stdout;\par
00079       {\cf19 break};\par
00080     {\cf19 case} HH_LOG_WARNING:\par
00081       fprintf (stderr, {\cf22 "%s[WARNING] "}, program_tag);\par
00082       output_stream = stderr;\par
00083       {\cf19 break};\par
00084     {\cf19 case} HH_LOG_ERROR:\par
00085       fprintf (stderr, {\cf22 "%s[ERROR] "}, program_tag);\par
00086       output_stream = stderr;\par
00087       {\cf19 break};\par
00088     {\cf19 default}:\par
00089       hh_log (HH_LOG_ERROR, {\cf22 "Unrecognized hh_log_level, %d"}, lvl);\par
00090       {\cf19 return};\par
00091     \}\par
00092 \par
00093   va_list args;\par
00094   va_start (args, fmt);\par
00095   vfprintf (output_stream, fmt, args);\par
00096   va_end (args);\par
00097   fprintf (output_stream, {\cf22 "\\n"});\par
00098 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/log.h}
{\xe \v src/log.h}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b hh_log_level} \{ {\b HH_LOG_INFO}
, {\b HH_LOG_WARNING}
, {\b HH_LOG_ERROR}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b log.h} - wrapper for hh_log and its related functions functions. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hh_log} ({\b hh_log_level} lvl, const char *fmt,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A logger function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_some_data_from_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the next {\f2 BYTES_TO_READ}  many bytes to the stdout, formatted in order to be easy to read. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v hh_log_level\:log.h}
{\xe \v log.h\:hh_log_level}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b hh_log_level}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b log.h} - wrapper for hh_log and its related functions functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The three levels of log messages: INFO, WARNING, and ERROR. When used with the {\f2 {\b hh_log()}}  function, these log_levels modify the output string and stream.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b hh_log} \par
}}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v HH_LOG_INFO\:log.h}
{\xe \v log.h\:HH_LOG_INFO}
{\qr HH_LOG_INFO{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\cell }{\cell }{\row }
{\xe \v HH_LOG_WARNING\:log.h}
{\xe \v log.h\:HH_LOG_WARNING}
{\qr HH_LOG_WARNING{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\cell }{\cell }{\row }
{\xe \v HH_LOG_ERROR\:log.h}
{\xe \v log.h\:HH_LOG_ERROR}
{\qr HH_LOG_ERROR{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 30} of file {\b log.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v hh_log\:log.h}
{\xe \v log.h\:hh_log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void hh_log ({\b hh_log_level} lvl, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A logger function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs fmt and args to either the stdout or stderr depending on the {\f2 lvl}  passed into the function. \par
}{
Definition at line {\b 69} of file {\b log.c}.}\par
}
{\xe \v print_some_data_from_file\:log.h}
{\xe \v log.h\:print_some_data_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_some_data_from_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the next {\f2 BYTES_TO_READ}  many bytes to the stdout, formatted in order to be easy to read. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Useful for debugging. Note that {\f2 BYTES_TO_READ}  is defined in {\f2 {\b log.c}} .\par
Prints the next {\f2 BYTES_TO_READ}  many bytes to the stdout, formatted in order to be easy to read. \par
}{
Definition at line {\b 53} of file {\b log.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
log.h\par \pard\plain 
{\tc\tcl2 \v src/log.h}
{\xe \v src/log.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00017 {\cf21 #ifndef _HH_LOG_H_}\par
00018 {\cf21 #define _HH_LOG_H_}\par
00019 \par
00020 {\cf21 #include <stdint.h>}\par
00021 {\cf21 #include <stdio.h>}\par
00022 \par
00030 {\cf17 typedef} {\cf17 enum} hh_log_level\par
00031 \{\par
00032   HH_LOG_INFO,\par
00033   HH_LOG_WARNING,\par
00034   HH_LOG_ERROR,\par
00035 \} hh_log_level;\par
00036 \par
00041 {\cf18 void} hh_log (hh_log_level lvl, {\cf17 const} {\cf18 char} *fmt, ...);\par
00042 \par
00048 {\cf18 void} print_some_data_from_file (FILE *fptr);\par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/options.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "options.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_out_list_of_command_line_arguments} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_flag} (char *f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_command_line_args} (int argc, char **argv)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_BATCH_PROCESS} = true\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_DAT_PROCESSING} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip primary dat file processing and go directly to processing {\f2 INDEX.00#}  files and their associated dat files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_INT_DAT_PROCESSING} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skips extraction of dat files created from extracting primary dat files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_DEBUG_MODE} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_INPUT_DIR} = (char *)"dat-files"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_OUTPUT_DIR} = (char *)"output"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OP_PATH_SEPARATOR} = '/'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OP_DEBUG_FILE_SIZE_LIMIT} = 0xF00000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b CURRENT_DISK_NAME} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b VERSION_NUMBER_STR} [9] = "01.00.00"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_command_line_args\:options.c}
{\xe \v options.c\:handle_command_line_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_command_line_args (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle multi-part command-line arguments.\par
}{
Definition at line {\b 44} of file {\b options.c}.}\par
}
{\xe \v print_out_list_of_command_line_arguments\:options.c}
{\xe \v options.c\:print_out_list_of_command_line_arguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_out_list_of_command_line_arguments (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }}\par
{
Definition at line {\b 95} of file {\b options.c}.}\par
}
{\xe \v process_flag\:options.c}
{\xe \v options.c\:process_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process_flag (char * f){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }}\par
{
Definition at line {\b 124} of file {\b options.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CURRENT_DISK_NAME\:options.c}
{\xe \v options.c\:CURRENT_DISK_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CURRENT_DISK_NAME = NULL}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not really an option, should be moved elsewhere. Stored here for the sake of convenience.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b volume_descriptor_data} \par
}}}{
Definition at line {\b 33} of file {\b options.c}.}\par
}
{\xe \v OP_BATCH_PROCESS\:options.c}
{\xe \v options.c\:OP_BATCH_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_BATCH_PROCESS = true}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Currently also home to some global variables until I figure out a better place for them to be stored. If true, batch process all the files in {\f2 OP_INPUT_DIR} . \par
}{
Definition at line {\b 23} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_FILE_SIZE_LIMIT\:options.c}
{\xe \v options.c\:OP_DEBUG_FILE_SIZE_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. \par
}{
Definition at line {\b 30} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_MODE\:options.c}
{\xe \v options.c\:OP_DEBUG_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_DEBUG_MODE = false}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }}\par
{
Definition at line {\b 26} of file {\b options.c}.}\par
}
{\xe \v OP_INPUT_DIR\:options.c}
{\xe \v options.c\:OP_INPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_INPUT_DIR = (char *)"dat-files"}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./dat-files/} . \par
}{
Definition at line {\b 27} of file {\b options.c}.}\par
}
{\xe \v OP_OUTPUT_DIR\:options.c}
{\xe \v options.c\:OP_OUTPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_OUTPUT_DIR = (char *)"output"}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./output/} . \par
}{
Definition at line {\b 28} of file {\b options.c}.}\par
}
{\xe \v OP_PATH_SEPARATOR\:options.c}
{\xe \v options.c\:OP_PATH_SEPARATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OP_PATH_SEPARATOR = '/'}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on the user's operating system. {\f2 \\\\}  for Windows, {\f2 /}  for *nix. \par
}{
Definition at line {\b 29} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_DAT_PROCESSING\:options.c}
{\xe \v options.c\:OP_SKIP_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_DAT_PROCESSING = false}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip primary dat file processing and go directly to processing {\f2 INDEX.00#}  files and their associated dat files. }}\par
{
Definition at line {\b 24} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_INT_DAT_PROCESSING\:options.c}
{\xe \v options.c\:OP_SKIP_INT_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_INT_DAT_PROCESSING = false}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skips extraction of dat files created from extracting primary dat files. }}\par
{
Definition at line {\b 25} of file {\b options.c}.}\par
}
{\xe \v VERSION_NUMBER_STR\:options.c}
{\xe \v options.c\:VERSION_NUMBER_STR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char VERSION_NUMBER_STR[9] = "01.00.00"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b options.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
options.c\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "options.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "utils.h"}\par
00017 \par
00018 {\cf21 #include <stdio.h>}\par
00019 {\cf21 #include <stdlib.h>}\par
00020 {\cf21 #include <string.h>}\par
00021 \par
00022 {\cf20 /* Option defaults */}\par
00023 {\cf18 bool} OP_BATCH_PROCESS = {\cf17 true};\par
00024 {\cf18 bool} OP_SKIP_DAT_PROCESSING = {\cf17 false};\par
00025 {\cf18 bool} OP_SKIP_INT_DAT_PROCESSING = {\cf17 false};\par
00026 {\cf18 bool} OP_DEBUG_MODE = {\cf17 false};\par
00027 {\cf18 char} *OP_INPUT_DIR = ({\cf18 char} *){\cf22 "dat-files"};\par
00028 {\cf18 char} *OP_OUTPUT_DIR = ({\cf18 char} *){\cf22 "output"};\par
00029 {\cf18 char} OP_PATH_SEPARATOR = {\cf23 '/'};\par
00030 uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000; \par
00031 \par
00032 {\cf20 /* Global defaults */}\par
00033 {\cf18 char} *CURRENT_DISK_NAME = NULL;\par
00034 \par
00035 {\cf17 static} {\cf17 const} {\cf18 char} VERSION_NUMBER_STR[9] = {\cf22 "01.00.00"};\par
00036 \par
00038 {\cf17 static} {\cf18 void} print_out_list_of_command_line_arguments ({\cf18 void});\par
00039 \par
00041 {\cf17 static} {\cf18 void} process_flag ({\cf18 char} *f);\par
00042 \par
00043 {\cf18 void}\par
00044 handle_command_line_args ({\cf18 int} argc, {\cf18 char} **argv)\par
00045 \{\par
00046   {\cf18 int} i;\par
00047   {\cf19 for} (i = 1; i < argc; i++)\par
00048     \{\par
00050       {\cf19 if} (strncmp (argv[i], {\cf22 "-d"}, 2) == 0)\par
00051         \{\par
00052           i++;\par
00053           {\cf18 size_t} path_len = strlen (argv[i]);\par
00054           {\cf19 if} (argv[i][path_len - 1] == {\cf23 '/'} || argv[i][path_len - 1] == {\cf23 '\\\\'})\par
00055             \{\par
00056               argv[i][path_len - 1] = {\cf23 '\\0'};\par
00057             \}\par
00058           OP_INPUT_DIR = argv[i];\par
00059         \}\par
00060       {\cf19 else} {\cf19 if} (strncmp (argv[i], {\cf22 "-o"}, 2) == 0)\par
00061         \{\par
00062           i++;\par
00063           {\cf18 size_t} path_len = strlen (argv[i]);\par
00064           {\cf19 if} (argv[i][path_len - 1] == {\cf23 '/'} || argv[i][path_len - 1] == {\cf23 '\\\\'})\par
00065             \{\par
00066               argv[i][path_len - 1] = {\cf23 '\\0'};\par
00067             \}\par
00068           OP_OUTPUT_DIR = argv[i];\par
00069         \}\par
00070       {\cf19 else} {\cf19 if} (argv[i][0] == {\cf23 '-'})\par
00071         \{\par
00072           process_flag (argv[i]);\par
00073         \}\par
00074       {\cf19 else}\par
00075         \{\par
00076           {\cf19 break};\par
00077         \}\par
00078     \}\par
00079 \par
00080   {\cf19 if} (i == argc)\par
00081     {\cf19 return};\par
00082 \par
00083   {\cf19 if} (is_string_dat_file (argv[argc - 1]))\par
00084     \{\par
00085       {\cf20 // just processing the user-provided file @ the user-provided path}\par
00086       OP_BATCH_PROCESS = {\cf17 false};\par
00087     \}\par
00088   {\cf19 else}\par
00089     \{\par
00090       handle_unknown_command_line_argument_error (argv[argc - 1]);\par
00091     \}\par
00092 \}\par
00093 \par
00094 {\cf18 void}\par
00095 print_out_list_of_command_line_arguments ({\cf18 void})\par
00096 \{\par
00097   printf (\par
00098       {\cf22 "HarvesterHarvester (HH) Version %s Copyright (C) 2024 IcePanorama\\n"},\par
00099       VERSION_NUMBER_STR);\par
00100 {\cf21 #ifdef _WIN32}\par
00101   puts ({\cf22 "Usage:\\n\\tHarvesterHarvester_[ARCH].exe [options] "}\par
00102         {\cf22 "[path_to_dat_file]\\n"});\par
00103 {\cf21 #else}\par
00104   puts ({\cf22 "Usage:\\n\\t./HarvesterHarvester [options] [path/to/dat_file.dat]\\n"});\par
00105 {\cf21 #endif}\par
00106   puts ({\cf22 "Command-line arguments:"});\par
00107   puts ({\cf22 "\\t--debug: enables debug mode, skips extracting large files."});\par
00108   puts ({\cf22 "\\t--help: displays list of command line arguments."});\par
00109   puts ({\cf22 "\\t--version: prints out the version number."});\par
00110   {\cf20 //  TODO: have some usage.md file that explains this in more detail.}\par
00111   {\cf20 //  add a note here saying to read that file for details.}\par
00112   puts ({\cf22 "\\t-d [path/to/some-dir]: specify the input directory for batch "}\par
00113         {\cf22 "processing dat files. (Default=./dat-files/)"});\par
00114   puts ({\cf22 "\\t-e: don't extract internal dat files."});\par
00115   puts ({\cf22 "\\t-i: extract internal dat files only."});\par
00116   puts ({\cf22 "\\t-o [path/to/some-dir]: extract dat files to the given "}\par
00117         {\cf22 "directory/look here for internal dat files. (Default=./output/)"});\par
00118   puts ({\cf22 "\\nOptional:"});\par
00119   puts ({\cf22 "\\tpath/to/dat_file.dat: specify the path to a dat file to be "}\par
00120         {\cf22 "processed."});\par
00121 \}\par
00122 \par
00123 {\cf18 void}\par
00124 process_flag ({\cf18 char} *f)\par
00125 \{\par
00126   {\cf19 if} (strcmp (f, {\cf22 "--debug"}) == 0)\par
00127     \{\par
00128       OP_DEBUG_MODE = {\cf17 true};\par
00129     \}\par
00130   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--help"}) == 0)\par
00131     \{\par
00132       print_out_list_of_command_line_arguments ();\par
00133       exit (0);\par
00134     \}\par
00135   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "-e"}) == 0)\par
00136     \{\par
00137       OP_SKIP_INT_DAT_PROCESSING = {\cf17 true};\par
00138     \}\par
00139   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "-i"}) == 0)\par
00140     \{\par
00141       OP_SKIP_DAT_PROCESSING = {\cf17 true};\par
00142     \}\par
00143   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--version"}) == 0)\par
00144     \{\par
00145       printf ({\cf22 "HarvesterHarvester v%s\\n"}, VERSION_NUMBER_STR);\par
00146       exit (0);\par
00147     \}\par
00148   {\cf19 else}\par
00149     \{\par
00150       handle_unknown_command_line_argument_error (f);\par
00151     \}\par
00152 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/options.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/options.h}
{\xe \v src/options.h}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_command_line_args} (int argc, char **argv)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_BATCH_PROCESS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_DAT_PROCESSING}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip primary dat file processing and go directly to processing {\f2 INDEX.00#}  files and their associated dat files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_INT_DAT_PROCESSING}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skips extraction of dat files created from extracting primary dat files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_DEBUG_MODE}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OP_DEBUG_FILE_SIZE_LIMIT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_INPUT_DIR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_OUTPUT_DIR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OP_PATH_SEPARATOR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b CURRENT_DISK_NAME}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_command_line_args\:options.h}
{\xe \v options.h\:handle_command_line_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_command_line_args (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle multi-part command-line arguments.\par
}{
Definition at line {\b 44} of file {\b options.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CURRENT_DISK_NAME\:options.h}
{\xe \v options.h\:CURRENT_DISK_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CURRENT_DISK_NAME{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not really an option, should be moved elsewhere. Stored here for the sake of convenience.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b volume_descriptor_data} \par
}}}{
Definition at line {\b 33} of file {\b options.c}.}\par
}
{\xe \v OP_BATCH_PROCESS\:options.h}
{\xe \v options.h\:OP_BATCH_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_BATCH_PROCESS{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Currently also home to some global variables until I figure out a better place for them to be stored. If true, batch process all the files in {\f2 OP_INPUT_DIR} . \par
}{
Definition at line {\b 23} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_FILE_SIZE_LIMIT\:options.h}
{\xe \v options.h\:OP_DEBUG_FILE_SIZE_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OP_DEBUG_FILE_SIZE_LIMIT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. \par
}{
Definition at line {\b 30} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_MODE\:options.h}
{\xe \v options.h\:OP_DEBUG_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_DEBUG_MODE{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }}\par
{
Definition at line {\b 26} of file {\b options.c}.}\par
}
{\xe \v OP_INPUT_DIR\:options.h}
{\xe \v options.h\:OP_INPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_INPUT_DIR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./dat-files/} . \par
}{
Definition at line {\b 27} of file {\b options.c}.}\par
}
{\xe \v OP_OUTPUT_DIR\:options.h}
{\xe \v options.h\:OP_OUTPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_OUTPUT_DIR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./output/} . \par
}{
Definition at line {\b 28} of file {\b options.c}.}\par
}
{\xe \v OP_PATH_SEPARATOR\:options.h}
{\xe \v options.h\:OP_PATH_SEPARATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OP_PATH_SEPARATOR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on the user's operating system. {\f2 \\\\}  for Windows, {\f2 /}  for *nix. \par
}{
Definition at line {\b 29} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_DAT_PROCESSING\:options.h}
{\xe \v options.h\:OP_SKIP_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_DAT_PROCESSING{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip primary dat file processing and go directly to processing {\f2 INDEX.00#}  files and their associated dat files. }}\par
{
Definition at line {\b 24} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_INT_DAT_PROCESSING\:options.h}
{\xe \v options.h\:OP_SKIP_INT_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_INT_DAT_PROCESSING{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skips extraction of dat files created from extracting primary dat files. }}\par
{
Definition at line {\b 25} of file {\b options.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
options.h\par \pard\plain 
{\tc\tcl2 \v src/options.h}
{\xe \v src/options.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00020 {\cf21 #ifndef _HH_OPTIONS_H_}\par
00021 {\cf21 #define _HH_OPTIONS_H_}\par
00022 \par
00023 {\cf21 #include <stdbool.h>}\par
00024 {\cf21 #include <stdint.h>}\par
00025 \par
00027 {\cf17 extern} {\cf18 bool} OP_BATCH_PROCESS;\par
00028 \par
00033 {\cf17 extern} {\cf18 bool} OP_SKIP_DAT_PROCESSING;\par
00034 \par
00039 {\cf17 extern} {\cf18 bool} OP_SKIP_INT_DAT_PROCESSING;\par
00040 \par
00042 {\cf17 extern} {\cf18 bool} OP_DEBUG_MODE;\par
00043 \par
00045 {\cf17 extern} uint32_t OP_DEBUG_FILE_SIZE_LIMIT;\par
00046 \par
00051 {\cf17 extern} {\cf18 char} *OP_INPUT_DIR;\par
00052 \par
00057 {\cf17 extern} {\cf18 char} *OP_OUTPUT_DIR;\par
00058 \par
00063 {\cf17 extern} {\cf18 char} OP_PATH_SEPARATOR;\par
00064 \par
00072 {\cf17 extern} {\cf18 char} *CURRENT_DISK_NAME;\par
00073 \par
00075 {\cf18 void} handle_command_line_args ({\cf18 int} argc, {\cf18 char} **argv);\par
00076 \par
00077 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/output.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "output.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_output_directory} (char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_new_output_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a subdirectory at the given path, if it doesn't already exist. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_new_output_directory\:output.c}
{\xe \v output.c\:create_new_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_new_output_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a subdirectory at the given path, if it doesn't already exist. }}\par
{
Definition at line {\b 46} of file {\b output.c}.}\par
}
{\xe \v create_output_directory\:output.c}
{\xe \v output.c\:create_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_output_directory (char * path)}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an output directory at the given path if it doesn't already exist. This function does some extra steps prior to calling {\f2 create_new_output_directory} . If you wish to create a directory, that function probably has you covered. This function is specific to its exact use case.\par
TODO: look into merging the two.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b create_new_output_directory()} \par
}}}{
Definition at line {\b 29} of file {\b output.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output.c\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "output.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "log.h"}\par
00017 {\cf21 #include "options.h"}\par
00018 {\cf21 #include "utils.h"}\par
00019 \par
00020 {\cf21 #include <stdio.h>}\par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 {\cf21 #include <sys/stat.h>}\par
00024 {\cf21 #ifdef _WIN32}\par
00025 {\cf21 #include <direct.h>}\par
00026 {\cf21 #endif}\par
00027 \par
00028 int8_t\par
00029 create_output_directory ({\cf18 char} *path)\par
00030 \{\par
00031   {\cf19 if} (CURRENT_DISK_NAME != NULL)\par
00032     \{\par
00033       {\cf19 if} (prepend_path_string (path, CURRENT_DISK_NAME) != 0)\par
00034         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00035     \}\par
00036 \par
00037   {\cf19 if} (prepend_path_string (path, OP_OUTPUT_DIR) != 0)\par
00038     {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00039 \par
00040   create_new_output_directory (path);\par
00041 \par
00042   {\cf19 return} 0;\par
00043 \}\par
00044 \par
00045 int8_t\par
00046 create_new_output_directory ({\cf17 const} {\cf18 char} *path)\par
00047 \{\par
00048   {\cf19 if} (directory_exists (path))\par
00049     {\cf19 return} 0;\par
00050 \par
00051   {\cf20 // Why +2 here? '\\0' and ?}\par
00052   {\cf18 char} *tmp = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00053   {\cf19 if} (tmp == NULL)\par
00054     \{\par
00055       {\cf19 return} handle_calloc_error (strlen (path) + 2);\par
00056     \}\par
00057 \par
00058   strcpy (tmp, path);\par
00059   {\cf18 char} *token = strtok (tmp, &OP_PATH_SEPARATOR);\par
00060 \par
00061   {\cf18 char} *dir = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00062   {\cf19 if} (dir == NULL)\par
00063     \{\par
00064       free (tmp);\par
00065       {\cf19 return} handle_calloc_error (strlen (path) + 2);\par
00066     \}\par
00067 \par
00068   {\cf19 while} (token != NULL)\par
00069     \{\par
00070       strcat (dir, token);\par
00071 \par
00072       {\cf19 if} (!directory_exists (dir))\par
00073         \{\par
00074           {\cf20 // TODO: test on Windows}\par
00075           {\cf18 int} status;\par
00076 {\cf21 #ifdef _WIN32}\par
00077           status = _mkdir (dir);\par
00078 {\cf21 #else}\par
00079           status = mkdir (dir, 0700);\par
00080 {\cf21 #endif}\par
00081           {\cf19 if} (status != 0)\par
00082             \{\par
00083               hh_log (HH_LOG_ERROR,\par
00084                       {\cf22 "Failed to create the following output directory, %s."},\par
00085                       path);\par
00086               free (dir);\par
00087               free (tmp);\par
00088               {\cf19 return} HH_CREATE_OUTPUT_DIR_ERROR;\par
00089             \}\par
00090         \}\par
00091 \par
00092       strcat (dir, &OP_PATH_SEPARATOR);\par
00093       token = strtok (NULL, &OP_PATH_SEPARATOR);\par
00094     \}\par
00095 \par
00096   free (dir);\par
00097   free (tmp);\par
00098   {\cf19 return} 0;\par
00099 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/output.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/output.h}
{\xe \v src/output.h}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_output_directory} (char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_new_output_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a subdirectory at the given path, if it doesn't already exist. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_new_output_directory\:output.h}
{\xe \v output.h\:create_new_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_new_output_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a subdirectory at the given path, if it doesn't already exist. }}\par
{
Definition at line {\b 46} of file {\b output.c}.}\par
}
{\xe \v create_output_directory\:output.h}
{\xe \v output.h\:create_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_output_directory (char * path)}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an output directory at the given path if it doesn't already exist. This function does some extra steps prior to calling {\f2 create_new_output_directory} . If you wish to create a directory, that function probably has you covered. This function is specific to its exact use case.\par
TODO: look into merging the two.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b create_new_output_directory()} \par
}}}{
Definition at line {\b 29} of file {\b output.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output.h\par \pard\plain 
{\tc\tcl2 \v src/output.h}
{\xe \v src/output.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_OUTPUT_H_}\par
00016 {\cf21 #define _HH_OUTPUT_H_}\par
00017 \par
00018 {\cf21 #include <stdbool.h>}\par
00019 {\cf21 #include <stdint.h>}\par
00020 \par
00033 int8_t create_output_directory ({\cf18 char} *path);\par
00034 \par
00036 int8_t create_new_output_directory ({\cf17 const} {\cf18 char} *path);\par
00037 \par
00038 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/path_table.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "path_table.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_path_table_entries} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_path_table_entry} ({\b path_table_entry} *e)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a {\b path_table_entry} to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b add_entry_to_path_table} ({\b path_table} *pt, {\b path_table_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 {\b path_table_entry}}  to the given {\f2 {\b path_table}} 's list of {\f2 entries} , resizing it as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_type_l_path_table} (FILE *fptr, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_STARTING_NUM_ENTRIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_path_table\:path_table.c}
{\xe \v path_table.c\:add_entry_to_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_path_table ({\b path_table} * pt, {\b path_table_entry} * entry){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 {\b path_table_entry}}  to the given {\f2 {\b path_table}} 's list of {\f2 entries} , resizing it as needed. }}\par
{
Definition at line {\b 65} of file {\b path_table.c}.}\par
}
{\xe \v create_path_table\:path_table.c}
{\xe \v path_table.c\:create_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, {\f2 entries}  is given a size of {\f2 PT_STARTING_NUM_ENTRIES} . Note that {\f2 PT_STARTING_NUM_ENTRIES}  is defined in {\f2 {\b path_table.c}} . \par
}{
Definition at line {\b 29} of file {\b path_table.c}.}\par
}
{\xe \v destroy_path_table\:path_table.c}
{\xe \v path_table.c\:destroy_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }}\par
{
Definition at line {\b 49} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table\:path_table.c}
{\xe \v path_table.c\:print_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }}\par
{
Definition at line {\b 101} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table_entry\:path_table.c}
{\xe \v path_table.c\:print_path_table_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table_entry ({\b path_table_entry} * e){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a {\b path_table_entry} to the stdout in a human-readable form. }}\par
{
Definition at line {\b 111} of file {\b path_table.c}.}\par
}
{\xe \v process_type_l_path_table\:path_table.c}
{\xe \v path_table.c\:process_type_l_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_type_l_path_table (FILE * fptr, {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 123} of file {\b path_table.c}.}\par
}
{\xe \v resize_path_table_entries\:path_table.c}
{\xe \v path_table.c\:resize_path_table_entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_path_table_entries ({\b path_table} * pt){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }}\par
{
Definition at line {\b 79} of file {\b path_table.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PT_GROWTH_RATE\:path_table.c}
{\xe \v path_table.c\:PT_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b path_table.c}.}\par
}
{\xe \v PT_STARTING_NUM_ENTRIES\:path_table.c}
{\xe \v path_table.c\:PT_STARTING_NUM_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_STARTING_NUM_ENTRIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b path_table.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table.c\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "path_table.h"}\par
00002 {\cf21 #include "data_reader.h"}\par
00003 {\cf21 #include "errors.h"}\par
00004 \par
00005 {\cf21 #include <stdint.h>}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 \par
00009 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_STARTING_NUM_ENTRIES = 10;\par
00010 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_GROWTH_RATE = 2;\par
00011 \par
00016 {\cf17 static} int8_t resize_path_table_entries (path_table *pt);\par
00017 \par
00019 {\cf17 static} {\cf18 void} print_path_table_entry (path_table_entry *e);\par
00020 \par
00025 {\cf17 static} int8_t add_entry_to_path_table (path_table *pt,\par
00026                                        path_table_entry *entry);\par
00027 \par
00028 int8_t\par
00029 create_path_table (path_table *pt)\par
00030 \{\par
00031   pt->entries = malloc ({\cf17 sizeof} (path_table_entry) * PT_STARTING_NUM_ENTRIES);\par
00032   {\cf19 if} (pt->entries == NULL)\par
00033     \{\par
00034       {\cf19 return} handle_malloc_error ({\cf22 "path table entries."});\par
00035     \}\par
00036 \par
00037   pt->size = PT_STARTING_NUM_ENTRIES;\par
00038   pt->current_entry = 0;\par
00039 \par
00040   {\cf19 for} ({\cf18 size_t} i = 0; i < PT_STARTING_NUM_ENTRIES; i++)\par
00041     \{\par
00042       pt->entries[i].directory_identifier = NULL;\par
00043     \}\par
00044 \par
00045   {\cf19 return} 0;\par
00046 \}\par
00047 \par
00048 {\cf18 void}\par
00049 destroy_path_table (path_table *pt)\par
00050 \{\par
00051   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->size; i++)\par
00052     \{\par
00053       {\cf19 if} (pt->entries[i].directory_identifier == NULL)\par
00054         {\cf19 continue};\par
00055 \par
00056       free (pt->entries[i].directory_identifier);\par
00057       pt->entries[i].directory_identifier = NULL;\par
00058     \}\par
00059 \par
00060   free (pt->entries);\par
00061   pt->entries = NULL;\par
00062 \}\par
00063 \par
00064 int8_t\par
00065 add_entry_to_path_table (path_table *pt, path_table_entry *entry)\par
00066 \{\par
00067   {\cf19 if} (pt->current_entry >= pt->size)\par
00068     \{\par
00069       {\cf19 if} (resize_path_table_entries (pt) != 0)\par
00070         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00071     \}\par
00072 \par
00073   pt->entries[pt->current_entry] = *entry;\par
00074   pt->current_entry++;\par
00075   {\cf19 return} 0;\par
00076 \}\par
00077 \par
00078 int8_t\par
00079 resize_path_table_entries (path_table *pt)\par
00080 \{\par
00081   {\cf18 size_t} new_size = (size_t)(pt->size * PT_GROWTH_RATE);\par
00082   path_table_entry *new_entries = (path_table_entry *)realloc (\par
00083       pt->entries, sizeof (path_table_entry) * new_size);\par
00084   {\cf19 if} (new_entries == NULL)\par
00085     \{\par
00086       destroy_path_table (pt);\par
00087       {\cf19 return} handle_realloc_error ({\cf22 "entries"}, pt->size, new_size);\par
00088     \}\par
00089 \par
00090   pt->entries = new_entries;\par
00091   {\cf19 for} ({\cf18 size_t} i = pt->size; i < new_size; i++)\par
00092     \{\par
00093       pt->entries[i].directory_identifier = NULL;\par
00094     \}\par
00095 \par
00096   pt->size = new_size;\par
00097   {\cf19 return} 0;\par
00098 \}\par
00099 \par
00100 {\cf18 void}\par
00101 print_path_table (path_table *pt)\par
00102 \{\par
00103   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->current_entry; i++)\par
00104     \{\par
00105       printf ({\cf22 "Entry %zu:\\n"}, i + 1);\par
00106       print_path_table_entry (&pt->entries[i]);\par
00107     \}\par
00108 \}\par
00109 \par
00110 {\cf18 void}\par
00111 print_path_table_entry (path_table_entry *e)\par
00112 \{\par
00113   printf ({\cf22 "\\tDirectory identifier length: %02X\\n"},\par
00114           e->directory_identifier_length);\par
00115   printf ({\cf22 "\\tExtended attribute record length: %02X\\n"},\par
00116           e->extended_attribute_record_length);\par
00117   printf ({\cf22 "\\tLocation of extant: %08X\\n"}, e->location_of_extent);\par
00118   printf ({\cf22 "\\tParent directory number: %04X\\n"}, e->parent_directory_number);\par
00119   printf ({\cf22 "\\tDirectory identifier: %s\\n"}, e->directory_identifier);\par
00120 \}\par
00121 \par
00122 int8_t\par
00123 process_type_l_path_table (FILE *fptr, path_table *pt)\par
00124 \{\par
00125   uint8_t dir_identifier_length;\par
00126   {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00127     {\cf19 return} HH_FREAD_ERROR;\par
00128 \par
00129   {\cf19 do}\par
00130     \{\par
00131       path_table_entry curr;\par
00132       curr.directory_identifier_length = dir_identifier_length;\par
00133 \par
00134       {\cf19 if} (curr.directory_identifier_length != 1)\par
00135         curr.directory_identifier_length += 1;\par
00136 \par
00137       {\cf20 /* clang-format off */}\par
00138       {\cf19 if} ((read_single_uint8 (fptr, &curr.extended_attribute_record_length) != 0)\par
00139           || (read_little_endian_data_uint32_t (fptr, &curr.location_of_extent) != 0)\par
00140           || (read_little_endian_data_uint16_t (fptr, &curr.parent_directory_number)) != 0)\par
00141         \{\par
00142           {\cf19 return} HH_FREAD_ERROR;\par
00143         \}\par
00144       {\cf20 /* clang-format on */}\par
00145 \par
00146       curr.directory_identifier\par
00147           = ({\cf18 char} *)calloc (curr.directory_identifier_length, sizeof ({\cf18 char}));\par
00148 \par
00149       {\cf19 if} (curr.directory_identifier_length != 1)\par
00150         \{\par
00151           {\cf18 size_t} bytes_read\par
00152               = fread (curr.directory_identifier, sizeof ({\cf18 char}),\par
00153                        curr.directory_identifier_length - 1, fptr);\par
00154           curr.directory_identifier[curr.directory_identifier_length - 1]\par
00155               = {\cf23 '\\0'};\par
00156           {\cf19 if} (bytes_read\par
00157               != {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1))\par
00158             \{\par
00159               handle_fread_error (\par
00160                   bytes_read,\par
00161                   {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1));\par
00162               {\cf19 return} HH_FREAD_ERROR;\par
00163             \}\par
00164         \}\par
00165       {\cf19 else}\par
00166         \{\par
00167           fseek (fptr, 1, SEEK_CUR);\par
00168         \}\par
00169 \par
00170       {\cf19 if} (add_entry_to_path_table (pt, &curr) != 0)\par
00171         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00172 \par
00173       {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00174         {\cf19 return} HH_FREAD_ERROR;\par
00175 \par
00176       {\cf19 if} (dir_identifier_length == 0) {\cf20 // handle padding field}\par
00177         \{\par
00178           {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00179             {\cf19 return} HH_FREAD_ERROR;\par
00180         \}\par
00181     \}\par
00182   {\cf19 while} (dir_identifier_length != 0);\par
00183 \par
00184   {\cf19 return} 0;\par
00185 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/path_table.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/path_table.h}
{\xe \v src/path_table.h}
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b path_table_entry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b path_table}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_type_l_path_table} (FILE *fptr, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_path_table\:path_table.h}
{\xe \v path_table.h\:create_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, {\f2 entries}  is given a size of {\f2 PT_STARTING_NUM_ENTRIES} . Note that {\f2 PT_STARTING_NUM_ENTRIES}  is defined in {\f2 {\b path_table.c}} . \par
}{
Definition at line {\b 29} of file {\b path_table.c}.}\par
}
{\xe \v destroy_path_table\:path_table.h}
{\xe \v path_table.h\:destroy_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }}\par
{
Definition at line {\b 49} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table\:path_table.h}
{\xe \v path_table.h\:print_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }}\par
{
Definition at line {\b 101} of file {\b path_table.c}.}\par
}
{\xe \v process_type_l_path_table\:path_table.h}
{\xe \v path_table.h\:process_type_l_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_type_l_path_table (FILE * fptr, {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 123} of file {\b path_table.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table.h\par \pard\plain 
{\tc\tcl2 \v src/path_table.h}
{\xe \v src/path_table.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_PATH_TABLE_H_}\par
00022 {\cf21 #define _HH_PATH_TABLE_H_}\par
00023 \par
00024 {\cf21 #include <stdint.h>}\par
00025 {\cf21 #include <stdio.h>}\par
00026 \par
00032 {\cf17 typedef} {\cf17 struct }path_table_entry\par
00033 \{\par
00034   uint8_t directory_identifier_length;\par
00035   uint8_t extended_attribute_record_length;\par
00036   uint32_t location_of_extent;\par
00037   uint16_t parent_directory_number; \par
00038   {\cf18 char} *directory_identifier;\par
00039 \} path_table_entry;\par
00040 \par
00042 {\cf17 typedef} {\cf17 struct }path_table\par
00043 \{\par
00044   path_table_entry *entries;\par
00045   {\cf18 size_t} size;          \par
00046   {\cf18 size_t} current_entry; \par
00047 \} path_table;\par
00048 \par
00054 int8_t create_path_table (path_table *pt);\par
00055 \par
00060 {\cf18 void} destroy_path_table (path_table *pt);\par
00061 \par
00066 {\cf18 void} print_path_table (path_table *pt);\par
00067 \par
00072 int8_t process_type_l_path_table (FILE *fptr, path_table *pt);\par
00073 \par
00074 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utils.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "log.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b prepend_path_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b prepend_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string_dat_file} (char *str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directory_exists} (const char *dir)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b file_exists} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_char_is} (FILE *fptr, uint8_t expected_ch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_eof} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b change_endianness_uint16} (uint16_t value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_endianness_uint16\:utils.c}
{\xe \v utils.c\:change_endianness_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t change_endianness_uint16 (uint16_t value)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps a {\f2 uint16_t}  from little endian to big endian or vice-versa. \par
}{
Definition at line {\b 144} of file {\b utils.c}.}\par
}
{\xe \v directory_exists\:utils.c}
{\xe \v utils.c\:directory_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool directory_exists (const char * dir)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 dir}  is a string containing the path to said directory. \par
}{
Definition at line {\b 92} of file {\b utils.c}.}\par
}
{\xe \v file_exists\:utils.c}
{\xe \v utils.c\:file_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_exists (const char * filename)}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 filename}  is a string containing the path to said file. \par
}{
Definition at line {\b 104} of file {\b utils.c}.}\par
}
{\xe \v is_string_dat_file\:utils.c}
{\xe \v utils.c\:is_string_dat_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_string_dat_file (char * str)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }}\par
{
Definition at line {\b 81} of file {\b utils.c}.}\par
}
{\xe \v peek_char_is\:utils.c}
{\xe \v utils.c\:peek_char_is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_char_is (FILE * fptr, uint8_t expected_ch)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . \par
}{
Definition at line {\b 117} of file {\b utils.c}.}\par
}
{\xe \v peek_eof\:utils.c}
{\xe \v utils.c\:peek_eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_eof (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker.\par
TODO: implement better err handling. \par
}{
Definition at line {\b 135} of file {\b utils.c}.}\par
}
{\xe \v prepend_path_string\:utils.c}
{\xe \v utils.c\:prepend_path_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t prepend_path_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }}\par
{
Definition at line {\b 33} of file {\b utils.c}.}\par
}
{\xe \v prepend_string\:utils.c}
{\xe \v utils.c\:prepend_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void prepend_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }}\par
{
Definition at line {\b 59} of file {\b utils.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.c\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "utils.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "log.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 \par
00020 {\cf21 #include <stdio.h>}\par
00021 {\cf21 #include <stdlib.h>}\par
00022 {\cf21 #include <string.h>}\par
00023 {\cf21 #include <sys/stat.h>}\par
00024 \par
00025 {\cf21 #ifdef _WIN32}\par
00026 {\cf21 #include <direct.h>}\par
00027 {\cf21 #include <windows.h>}\par
00028 {\cf21 #else}\par
00029 {\cf21 #include <unistd.h>}\par
00030 {\cf21 #endif}\par
00031 \par
00032 int8_t\par
00033 prepend_path_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00034 \{\par
00035   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00036       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00037     \{\par
00038       {\cf19 return} 0;\par
00039     \}\par
00040 \par
00041   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00042   {\cf19 if} (tmp == NULL)\par
00043     \{\par
00044       hh_log (HH_LOG_ERROR, {\cf22 "Unable to calloc string of size %zu."},\par
00045               strlen (str) + strlen (prefix) + 2);\par
00046       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00047     \}\par
00048 \par
00049   strcpy (tmp, str);\par
00050   strcpy (str, prefix);\par
00051   strcat (str, &OP_PATH_SEPARATOR);\par
00052   strcat (str, tmp);\par
00053   free (tmp);\par
00054 \par
00055   {\cf19 return} 0;\par
00056 \}\par
00057 \par
00058 {\cf18 void}\par
00059 prepend_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00060 \{\par
00061   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00062       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00063     \{\par
00064       {\cf19 return};\par
00065     \}\par
00066 \par
00067   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00068   {\cf19 if} (tmp == NULL)\par
00069     \{\par
00070       hh_log (HH_LOG_ERROR, {\cf22 "Unable to calloc string of size %zu."},\par
00071               strlen (str) + strlen (prefix) + 2);\par
00072       exit (1);\par
00073     \}\par
00074   strcpy (tmp, str);\par
00075   strcpy (str, prefix);\par
00076   strcat (str, tmp);\par
00077   free (tmp);\par
00078 \}\par
00079 \par
00080 {\cf18 bool}\par
00081 is_string_dat_file ({\cf18 char} *str)\par
00082 \{\par
00083   {\cf17 const} {\cf18 char} *EXPECTED_EXTENSION = {\cf22 ".DAT"};\par
00084   {\cf17 const} uint8_t EXTENSION_LEN = 5; {\cf20 // +1 for null terminator}\par
00085 \par
00086   {\cf18 size_t} len = strlen (str) + 1;\par
00087   {\cf19 return} (len > EXTENSION_LEN\par
00088           && strcmp (str + (len - EXTENSION_LEN), EXPECTED_EXTENSION) == 0);\par
00089 \}\par
00090 \par
00091 {\cf18 bool}\par
00092 directory_exists ({\cf17 const} {\cf18 char} *dir)\par
00093 \{\par
00094 {\cf21 #ifdef _WIN32}\par
00095   {\cf17 struct }_stat st;\par
00096   {\cf19 return} (_stat (dir, &st) == 0 && (st.st_mode & _S_IFDIR));\par
00097 {\cf21 #else}\par
00098   {\cf17 struct }stat st;\par
00099   {\cf19 return} (stat (dir, &st) == 0 && S_ISDIR (st.st_mode));\par
00100 {\cf21 #endif}\par
00101 \}\par
00102 \par
00103 {\cf18 bool}\par
00104 file_exists ({\cf17 const} {\cf18 char} *filename)\par
00105 \{\par
00106 {\cf21 #ifdef _WIN32}\par
00107   DWORD attribs = GetFileAttributes (filename);\par
00108   {\cf19 return} attribs != INVALID_FILE_ATTRIBUTES\par
00109          && !(attribs & FILE_ATTRIBUTE_DIRECTORY);\par
00110 {\cf21 #else}\par
00111   {\cf19 return} access (filename, F_OK) != -1;\par
00112 {\cf21 #endif}\par
00113 \}\par
00114 \par
00116 {\cf18 bool}\par
00117 peek_char_is (FILE *fptr, uint8_t expected_ch)\par
00118 \{\par
00119   uint8_t byte;\par
00120   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00121     \{\par
00122       {\cf19 return} {\cf17 false};\par
00123     \}\par
00124   {\cf19 else} {\cf19 if} ({\cf18 byte} == expected_ch)\par
00125     \{\par
00126       {\cf19 return} {\cf17 true};\par
00127     \}\par
00128 \par
00129   fseek (fptr, -1, SEEK_CUR);\par
00130   {\cf19 return} {\cf17 false};\par
00131 \}\par
00132 \par
00134 {\cf18 bool}\par
00135 peek_eof (FILE *fptr)\par
00136 \{\par
00137   uint8_t value;\par
00138   {\cf18 size_t} bytes_read = fread (&value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00139   fseek (fptr, -1, SEEK_CUR);\par
00140   {\cf19 return} bytes_read == 0;\par
00141 \}\par
00142 \par
00143 uint16_t\par
00144 change_endianness_uint16 (uint16_t value)\par
00145 \{\par
00146   {\cf19 return} (value << 8) | (value >> 8);\par
00147 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/utils.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/utils.h}
{\xe \v src/utils.h}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "file_flags.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b change_endianness_uint16} (uint16_t value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b prepend_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b prepend_path_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string_dat_file} (char *str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directory_exists} (const char *dir)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b file_exists} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_char_is} (FILE *fptr, uint8_t expected_ch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_eof} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_endianness_uint16\:utils.h}
{\xe \v utils.h\:change_endianness_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t change_endianness_uint16 (uint16_t value)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps a {\f2 uint16_t}  from little endian to big endian or vice-versa. \par
}{
Definition at line {\b 144} of file {\b utils.c}.}\par
}
{\xe \v directory_exists\:utils.h}
{\xe \v utils.h\:directory_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool directory_exists (const char * dir)}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 dir}  is a string containing the path to said directory. \par
}{
Definition at line {\b 92} of file {\b utils.c}.}\par
}
{\xe \v file_exists\:utils.h}
{\xe \v utils.h\:file_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_exists (const char * filename)}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 filename}  is a string containing the path to said file. \par
}{
Definition at line {\b 104} of file {\b utils.c}.}\par
}
{\xe \v is_string_dat_file\:utils.h}
{\xe \v utils.h\:is_string_dat_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_string_dat_file (char * str)}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }}\par
{
Definition at line {\b 81} of file {\b utils.c}.}\par
}
{\xe \v peek_char_is\:utils.h}
{\xe \v utils.h\:peek_char_is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_char_is (FILE * fptr, uint8_t expected_ch)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . \par
}{
Definition at line {\b 117} of file {\b utils.c}.}\par
}
{\xe \v peek_eof\:utils.h}
{\xe \v utils.h\:peek_eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_eof (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker.\par
TODO: implement better err handling. \par
}{
Definition at line {\b 135} of file {\b utils.c}.}\par
}
{\xe \v prepend_path_string\:utils.h}
{\xe \v utils.h\:prepend_path_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t prepend_path_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }}\par
{
Definition at line {\b 33} of file {\b utils.c}.}\par
}
{\xe \v prepend_string\:utils.h}
{\xe \v utils.h\:prepend_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void prepend_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }}\par
{
Definition at line {\b 59} of file {\b utils.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.h\par \pard\plain 
{\tc\tcl2 \v src/utils.h}
{\xe \v src/utils.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_UTILS_H_}\par
00016 {\cf21 #define _HH_UTILS_H_}\par
00017 \par
00018 {\cf21 #include "file_flags.h"}\par
00019 \par
00020 {\cf21 #include <stdbool.h>}\par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <stdio.h>}\par
00023 \par
00025 uint16_t change_endianness_uint16 (uint16_t value);\par
00026 \par
00028 {\cf18 void} prepend_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix);\par
00029 \par
00034 int8_t prepend_path_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix);\par
00035 \par
00037 {\cf18 bool} is_string_dat_file ({\cf18 char} *str);\par
00038 \par
00043 {\cf18 bool} directory_exists ({\cf17 const} {\cf18 char} *dir);\par
00044 \par
00049 {\cf18 bool} file_exists ({\cf17 const} {\cf18 char} *filename);\par
00050 \par
00052 {\cf18 bool} peek_char_is (FILE *fptr, uint8_t expected_ch);\par
00053 \par
00055 {\cf18 bool} peek_eof (FILE *fptr);\par
00056 \par
00057 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/volume_descriptor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "volume_descriptor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_volume_descriptor} ({\b volume_descriptor} *vd, uint8_t type_code, uint8_t version)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_header} ({\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_data} ({\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_header} (FILE *fptr, {\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_data} (FILE *fptr, {\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_volume_descriptor\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:create_volume_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_volume_descriptor ({\b volume_descriptor} * vd, uint8_t type_code, uint8_t version)}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }}\par
{
Definition at line {\b 22} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_data ({\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }}\par
{
Definition at line {\b 40} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_header ({\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The header includes every field except for {\f2 data} , which can be printed using the {\f2 {\b print_volume_descriptor_data()}}  function. \par
}{
Definition at line {\b 32} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_data (FILE * fptr, {\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 99} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_header (FILE * fptr, {\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 81} of file {\b volume_descriptor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor.c\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "volume_descriptor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <string.h>}\par
00020 \par
00021 {\cf18 void}\par
00022 create_volume_descriptor (volume_descriptor *vd, uint8_t type_code,\par
00023                           uint8_t version)\par
00024 \{\par
00025   vd->type_code = type_code;\par
00026   strncpy (vd->identifier, {\cf22 "CD001"}, sizeof (vd->identifier));\par
00027   vd->identifier[{\cf17 sizeof} (vd->identifier) - 1] = {\cf23 '\\0'};\par
00028   vd->version = version;\par
00029 \}\par
00030 \par
00031 {\cf18 void}\par
00032 print_volume_descriptor_header (volume_descriptor *vd)\par
00033 \{\par
00034   printf ({\cf22 "Volume descriptor type code: %02x\\n"}, vd->type_code);\par
00035   printf ({\cf22 "Volume descriptor identifier: %s\\n"}, vd->identifier);\par
00036   printf ({\cf22 "Volume descriptor version: %02x\\n"}, vd->version);\par
00037 \}\par
00038 \par
00039 {\cf18 void}\par
00040 print_volume_descriptor_data (volume_descriptor_data *vdd)\par
00041 \{\par
00042   printf ({\cf22 "System identifier: %s\\n"}, vdd->system_identifier);\par
00043   printf ({\cf22 "Volume identifier: %s\\n"}, vdd->volume_identifier);\par
00044   printf ({\cf22 "Vol space size: %08X\\n"}, vdd->volume_space_size);\par
00045   printf ({\cf22 "Vol set size: %04X\\n"}, vdd->volume_set_size);\par
00046   printf ({\cf22 "Vol sequence size: %04X\\n"}, vdd->volume_sequence_number);\par
00047   printf ({\cf22 "Logical block size: %04X\\n"}, vdd->logical_block_size);\par
00048   printf ({\cf22 "Path table size: %08X\\n"}, vdd->path_table_size);\par
00049   printf ({\cf22 "Type-L path table location: %08X\\n"},\par
00050           vdd->type_l_path_table_location);\par
00051   printf ({\cf22 "Optional Type-L path table location: %08X\\n"},\par
00052           vdd->optional_type_l_path_table_location);\par
00053   printf ({\cf22 "Type-M path table location: %08X\\n"},\par
00054           vdd->type_m_path_table_location);\par
00055   printf ({\cf22 "Optional Type-M path table location: %08X\\n"},\par
00056           vdd->optional_type_m_path_table_location);\par
00057   printf ({\cf22 "Volume set identifier: %s\\n"}, vdd->volume_set_identifier);\par
00058   printf ({\cf22 "Publisher identifier: %s\\n"}, vdd->publisher_identifier);\par
00059   printf ({\cf22 "Data preparer identifier: %s\\n"}, vdd->data_preparer_identifier);\par
00060   printf ({\cf22 "Application identifier: %s\\n"}, vdd->application_identifier);\par
00061   printf ({\cf22 "Copyright file identifier: %s\\n"}, vdd->copyright_file_identifier);\par
00062   printf ({\cf22 "Abstract file identifier: %s\\n"}, vdd->abstract_file_identifier);\par
00063   printf ({\cf22 "Bibliographic file identifier: %s\\n"},\par
00064           vdd->bibliographic_file_identifier);\par
00065   printf ({\cf22 "Volume creation date and time: "});\par
00066   print_dec_datetime (vdd->volume_creation_date_and_time);\par
00067   printf ({\cf22 "Volume modification date and time: "});\par
00068   print_dec_datetime (vdd->volume_modification_date_and_time);\par
00069   printf ({\cf22 "Volume expiration date and time: "});\par
00070   print_dec_datetime (vdd->volume_expiration_date_and_time);\par
00071   printf ({\cf22 "Volume effective date and time: "});\par
00072   print_dec_datetime (vdd->volume_effective_date_and_time);\par
00073   printf ({\cf22 "File structure version: %02X\\n"}, vdd->file_structure_version);\par
00074   printf ({\cf22 "DAT file creation software identifier: %s\\n"},\par
00075           vdd->DAT_file_creation_software_identifier);\par
00076   printf ({\cf22 "DAT file creation software version number: %s\\n"},\par
00077           vdd->DAT_file_creation_software_version_number);\par
00078 \}\par
00079 \par
00080 int8_t\par
00081 process_volume_descriptor_header (FILE *fptr, volume_descriptor *vd)\par
00082 \{\par
00083   uint8_t descriptor_type;\par
00084   {\cf19 if} (read_single_uint8 (fptr, &descriptor_type) != 0)\par
00085     {\cf19 return} HH_FREAD_ERROR;\par
00086 \par
00087   fseek (fptr, 5, SEEK_CUR);\par
00088 \par
00089   uint8_t descriptor_ver;\par
00090   {\cf19 if} (read_single_uint8 (fptr, &descriptor_ver) != 0)\par
00091     {\cf19 return} HH_FREAD_ERROR;\par
00092 \par
00093   create_volume_descriptor (vd, descriptor_type, descriptor_ver);\par
00094 \par
00095   {\cf19 return} 0;\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 process_volume_descriptor_data (FILE *fptr, volume_descriptor_data *vdd)\par
00100 \{\par
00101   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00102 \par
00103   {\cf19 if} ((read_string (fptr, vdd->system_identifier, SYSTEM_IDENTIFIER_LEN) != 0)\par
00104       || (read_string (fptr, vdd->volume_identifier, VOLUME_IDENTIFIER_LEN)\par
00105           != 0))\par
00106     \{\par
00107       {\cf19 return} HH_FREAD_ERROR;\par
00108     \}\par
00109 \par
00110   fseek (fptr, 8, SEEK_CUR); {\cf20 // Unused field}\par
00111 \par
00112   {\cf19 if} (read_both_endian_data_uint32 (fptr, &vdd->volume_space_size) != 0)\par
00113     {\cf19 return} HH_FREAD_ERROR;\par
00114 \par
00115   fseek (fptr, 32, SEEK_CUR); {\cf20 // Unused field}\par
00116 \par
00117   {\cf20 /* clang-format off */}\par
00118   {\cf19 if} ((read_both_endian_data_uint16 (fptr, &vdd->volume_set_size) != 0)\par
00119       || (read_both_endian_data_uint16 (fptr, &vdd->volume_sequence_number) != 0)\par
00120       || (read_both_endian_data_uint16 (fptr, &vdd->logical_block_size) != 0))\par
00121   \{\par
00122     {\cf19 return} HH_FREAD_ERROR;\par
00123   \}\par
00124   {\cf20 /* clang-format on */}\par
00125 \par
00126   {\cf19 if} ((read_both_endian_data_uint32 (fptr, &vdd->path_table_size) != 0)\par
00127       || (read_little_endian_data_uint32_t (fptr,\par
00128                                             &vdd->type_l_path_table_location)\par
00129           != 0)\par
00130       || (read_little_endian_data_uint32_t (\par
00131               fptr, &vdd->optional_type_l_path_table_location)\par
00132           != 0)\par
00133       || (read_little_endian_data_uint32_t (fptr,\par
00134                                             &vdd->type_m_path_table_location)\par
00135           != 0)\par
00136       || (read_little_endian_data_uint32_t (\par
00137               fptr, &vdd->optional_type_m_path_table_location)\par
00138           != 0))\par
00139     \{\par
00140       {\cf19 return} HH_FREAD_ERROR;\par
00141     \}\par
00142 \par
00143   {\cf19 if} (read_array_uint8 (fptr, vdd->root_directory_entry,\par
00144                         ROOT_DIRECTORY_ENTRY_LEN)\par
00145       != 0)\par
00146     \{\par
00147       {\cf19 return} HH_FREAD_ERROR;\par
00148     \}\par
00149 \par
00150   {\cf20 /* clang-format off */}\par
00151   {\cf19 if} ((read_string (fptr, vdd->volume_set_identifier, VOLUME_SET_IDENTIFIER_LEN) != 0)\par
00152       || (read_string (fptr, vdd->publisher_identifier, PUBLISHER_IDENTIFIER_LEN) != 0)\par
00153       || (read_string (fptr, vdd->data_preparer_identifier, DATA_PREPARER_IDENTIFIER_LEN) != 0)\par
00154       || (read_string (fptr, vdd->application_identifier, APPLICATION_IDENTIFIER_LEN) != 0)\par
00155       || (read_string (fptr, vdd->copyright_file_identifier, COPYRIGHT_FILE_IDENTIFIER_LEN) != 0)\par
00156       || (read_string (fptr, vdd->abstract_file_identifier, ABSTRACT_FILE_IDENTIFIER_LEN) != 0)\par
00157       || (read_string (fptr, vdd->bibliographic_file_identifier, BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN) != 0))\par
00158   \{\par
00159     {\cf19 return} HH_FREAD_ERROR;\par
00160   \}\par
00161   {\cf20 /* clang-format on */}\par
00162 \par
00163   {\cf19 if} ((read_dec_datetime (fptr, &vdd->volume_creation_date_and_time) != 0)\par
00164       || (read_dec_datetime (fptr, &vdd->volume_modification_date_and_time)\par
00165           != 0)\par
00166       || (read_dec_datetime (fptr, &vdd->volume_expiration_date_and_time) != 0)\par
00167       || (read_dec_datetime (fptr, &vdd->volume_effective_date_and_time) != 0))\par
00168     \{\par
00169       {\cf19 return} HH_FREAD_ERROR;\par
00170     \}\par
00171 \par
00172   {\cf19 if} (read_single_uint8 (fptr, &vdd->file_structure_version) != 0)\par
00173     {\cf19 return} HH_FREAD_ERROR;\par
00174 \par
00175   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00176 \par
00177   read_string (fptr, vdd->DAT_file_creation_software_identifier,\par
00178                DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN);\par
00179 \par
00180   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00181 \par
00182   read_string (fptr, vdd->DAT_file_creation_software_version_number,\par
00183                DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN);\par
00184 \par
00185   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00186 \par
00187   fseek (fptr, 0x1EC, SEEK_CUR); {\cf20 // Unknown data (492 bytes)}\par
00188 \par
00189   fseek (fptr, 0x28D, SEEK_CUR); {\cf20 // Reserved by ISO}\par
00190 \par
00191   {\cf19 return} 0;\par
00192 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/volume_descriptor.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.h}
{\xe \v src/volume_descriptor.h}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b volume_descriptor_data}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b volume_descriptor}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSTEM_IDENTIFIER_LEN}\~ 33\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b volume_descriptor.h} - the {\f2 {\b volume_descriptor}}  and {\f2 {\b volume_descriptor_data}}  data types and their related functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VOLUME_IDENTIFIER_LEN}\~ 33\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ROOT_DIRECTORY_ENTRY_LEN}\~ 34\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VOLUME_SET_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PUBLISHER_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATA_PREPARER_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APPLICATION_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COPYRIGHT_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ABSTRACT_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}\~ 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}\~ 11\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_volume_descriptor} ({\b volume_descriptor} *vd, uint8_t type, uint8_t version)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_header} ({\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_data} ({\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_header} (FILE *fptr, {\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_data} (FILE *fptr, {\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ABSTRACT_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:ABSTRACT_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ABSTRACT_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b volume_descriptor.h}.}\par
}
{\xe \v APPLICATION_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:APPLICATION_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APPLICATION_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b volume_descriptor.h}.}\par
}
{\xe \v BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b volume_descriptor.h}.}\par
}
{\xe \v COPYRIGHT_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:COPYRIGHT_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COPYRIGHT_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN\~ 9}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN\~ 11}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DATA_PREPARER_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DATA_PREPARER_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATA_PREPARER_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b volume_descriptor.h}.}\par
}
{\xe \v PUBLISHER_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:PUBLISHER_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PUBLISHER_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b volume_descriptor.h}.}\par
}
{\xe \v ROOT_DIRECTORY_ENTRY_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:ROOT_DIRECTORY_ENTRY_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ROOT_DIRECTORY_ENTRY_LEN\~ 34}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b volume_descriptor.h}.}\par
}
{\xe \v SYSTEM_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:SYSTEM_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSTEM_IDENTIFIER_LEN\~ 33}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b volume_descriptor.h} - the {\f2 {\b volume_descriptor}}  and {\f2 {\b volume_descriptor_data}}  data types and their related functions. }}\par
{
Definition at line {\b 26} of file {\b volume_descriptor.h}.}\par
}
{\xe \v VOLUME_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:VOLUME_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VOLUME_IDENTIFIER_LEN\~ 33}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b volume_descriptor.h}.}\par
}
{\xe \v VOLUME_SET_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:VOLUME_SET_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VOLUME_SET_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_volume_descriptor\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:create_volume_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_volume_descriptor ({\b volume_descriptor} * vd, uint8_t type, uint8_t version)}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }}\par
{
Definition at line {\b 22} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_data\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:print_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_data ({\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }}\par
{
Definition at line {\b 40} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_header\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:print_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_header ({\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The header includes every field except for {\f2 data} , which can be printed using the {\f2 {\b print_volume_descriptor_data()}}  function. \par
}{
Definition at line {\b 32} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_data\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:process_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_data (FILE * fptr, {\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 99} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_header\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:process_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_header (FILE * fptr, {\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 81} of file {\b volume_descriptor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor.h\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.h}
{\xe \v src/volume_descriptor.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00018 {\cf21 #ifndef _HH_VOLUME_DESCRIPTOR_H_}\par
00019 {\cf21 #define _HH_VOLUME_DESCRIPTOR_H_}\par
00020 \par
00021 {\cf21 #include "datetime.h"}\par
00022 \par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stdio.h>}\par
00025 \par
00026 {\cf21 #define SYSTEM_IDENTIFIER_LEN 33}\par
00027 {\cf21 #define VOLUME_IDENTIFIER_LEN 33}\par
00028 {\cf21 #define ROOT_DIRECTORY_ENTRY_LEN 34}\par
00029 {\cf21 #define VOLUME_SET_IDENTIFIER_LEN 129}\par
00030 {\cf21 #define PUBLISHER_IDENTIFIER_LEN 129}\par
00031 {\cf21 #define DATA_PREPARER_IDENTIFIER_LEN 129}\par
00032 {\cf21 #define APPLICATION_IDENTIFIER_LEN 129}\par
00033 {\cf21 #define COPYRIGHT_FILE_IDENTIFIER_LEN 38}\par
00034 {\cf21 #define ABSTRACT_FILE_IDENTIFIER_LEN 38}\par
00035 {\cf21 #define BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN 38}\par
00036 {\cf21 #define DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN 9}\par
00037 {\cf21 #define DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN 11}\par
00038 \par
00044 {\cf17 typedef} {\cf17 struct }volume_descriptor_data\par
00045 \{\par
00046   {\cf18 char} system_identifier[SYSTEM_IDENTIFIER_LEN];\par
00047   {\cf18 char} volume_identifier[VOLUME_IDENTIFIER_LEN];\par
00048   uint32_t volume_space_size;\par
00049   uint16_t volume_set_size;\par
00050   uint16_t volume_sequence_number;\par
00051   uint16_t logical_block_size;\par
00052   uint32_t path_table_size;\par
00053   uint32_t type_l_path_table_location;\par
00054   uint32_t optional_type_l_path_table_location;\par
00055   uint32_t type_m_path_table_location;\par
00056   uint32_t optional_type_m_path_table_location;\par
00057   uint8_t root_directory_entry[ROOT_DIRECTORY_ENTRY_LEN];\par
00058   {\cf18 char} volume_set_identifier[VOLUME_SET_IDENTIFIER_LEN];\par
00059   {\cf18 char} publisher_identifier[PUBLISHER_IDENTIFIER_LEN];\par
00060   {\cf18 char} data_preparer_identifier[DATA_PREPARER_IDENTIFIER_LEN];\par
00061   {\cf18 char} application_identifier[APPLICATION_IDENTIFIER_LEN];\par
00062   {\cf18 char} copyright_file_identifier[COPYRIGHT_FILE_IDENTIFIER_LEN];\par
00063   {\cf18 char} abstract_file_identifier[ABSTRACT_FILE_IDENTIFIER_LEN];\par
00064   {\cf18 char} bibliographic_file_identifier[BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN];\par
00065   dec_datetime volume_creation_date_and_time;\par
00066   dec_datetime volume_modification_date_and_time;\par
00067   dec_datetime volume_expiration_date_and_time;\par
00068   dec_datetime volume_effective_date_and_time;\par
00069   uint8_t file_structure_version; \par
00070   {\cf18 char} DAT_file_creation_software_identifier\par
00071       [DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN];\par
00072   {\cf18 char} DAT_file_creation_software_version_number\par
00073       [DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN];\par
00074 \} volume_descriptor_data;\par
00075 \par
00081 {\cf17 typedef} {\cf17 struct }volume_descriptor\par
00082 \{\par
00083   uint8_t type_code;\par
00084   {\cf18 char} identifier[6]; \par
00085   uint8_t version;\par
00086   volume_descriptor_data data;\par
00087 \} volume_descriptor;\par
00088 \par
00093 {\cf18 void} create_volume_descriptor (volume_descriptor *vd, uint8_t type,\par
00094                                uint8_t version);\par
00101 {\cf18 void} print_volume_descriptor_header (volume_descriptor *vd);\par
00102 \par
00107 {\cf18 void} print_volume_descriptor_data (volume_descriptor_data *vdd);\par
00108 \par
00113 int8_t process_volume_descriptor_header (FILE *fptr, volume_descriptor *vd);\par
00114 \par
00119 int8_t process_volume_descriptor_data (FILE *fptr,\par
00120                                        volume_descriptor_data *vdd);\par
00121 \par
00122 {\cf21 #endif}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
