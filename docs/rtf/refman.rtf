{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment HarvesterHarvester  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
00.00.00 \par
}}HarvesterHarvester}
{\comment Generated by doxygen 1.11.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt HarvesterHarvester}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 00.00.00\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
HarvesterHarvester\par \pard\plain 
{\tc\tcl1 \v HarvesterHarvester}
{\xe \v HarvesterHarvester}
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
A tool for harvesting data out of {\f2 {\i Harvester} 's (DigiFX Interactive, 1996)} DAT files.\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Easiest Way
\par}
{\tc\tcl3 \v Easiest Way}
Navigate to the {\f2 releases} page and download the latest zip file. Once downloaded, simply extract the zip file and run the appropriate executable given your operating system/architecture.\par
If you're on a modern Windows machine and you're unsure of which file to run, your best bet is likely the one ending in {\f2 x86_64} ; that executable should run on most Windows machines made in the past 15 years.\par
{\b NOTE} : {\i if you're reading this in the present, you'll notice that there currently aren't any available releases. I'm writing this README in advance \'96 this project isn't quite done yet, sorry!} \par}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Building from source (Linux/MacOS/Unix)
\par}
{\tc\tcl3 \v Building from source (Linux/MacOS/Unix)}
1) Install the following dependencies: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gcc make mingw32-gcc clang-tools-extra valgrind doxygen\par
}
 2) Clone the repo: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ git clone https://github.com/IcePanorama/HarvesterHarvester/ && cd HarvesterHarvester\par
}
 3) Build using make: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ make release # for *nix, x86_64, and i686 executables\par
# ... or, alternatively ...\par
$ make full    # for just the *nix executable\par
}
 Running {\f2 make release}  is strongly recommended as the build process for the release target makes use of every single dependency listed above, thus ensuring that you have all the correct packages installed on your machine.\par}
\par}
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
1) Install Harvester onto your machine if you haven't already done so. 2) Copy the following files from your harvester installation to the {\f2 dat-files/}  folder: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid HARVEST.DAT\par
HARVEST3.DAT\par
HARVEST4.DAT\par
}
 4) Run the {\f2 HarvesterHarvester}  executable.\par}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
To Do
\par}
{\tc\tcl2 \v To Do}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Handle SIGINT/Windows-equivalent of SIGINT gracefully{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Currently, if a user presses {\f2 CTRL+C}  while the program is executing, this causes a memory leak.{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
To see this in action, run {\f2 make test}  and then press {\f2 CTRL+C} .\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
An ideal solution would free any outstanding, allocated memory and close open file handlers before exiting\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Ideally, this solution should also be cross-platform, if at all possible.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Could possibly be worth converting the program to use an arena and a custom malloc just for the ease of freeing memory in a case such as this.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Create a guide for building the project from source for Windows users.\par}
\par
\par}
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A note on piracy
\par}
{\tc\tcl2 \v A note on piracy}
This program requires that you legally own a copy of {\i Harvester}  in order to source the necessary .DAT files.\par
The GOG version (which this project was built around) {\f2 is available here for $5.99}, although it's worth noting that it does go on sale rather often.\par
{\f2 Alternatively, visit any of the retailers on this link if you'd rather shop elsewhere}.\par
This project in no way intends to encourage the piracy of DigiFX' software. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b dec_datetime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dir_datetime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b directory} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b directory_record} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory.h - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b file_flags} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File_flags.h - {\b file_flags} data type and its associated functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b index_entry} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entry of the associated {\f2 {\b index_file}}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b index_file} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b path_table} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b path_table_entry} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Path_table.h - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b volume_descriptor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b volume_descriptor_data} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/{\b data_reader.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b data_reader.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b datetime.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b datetime.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b directory.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b directory.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b errors.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b errors.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b extractor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b extractor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_flags.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_flags.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b hh.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b hh.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b index_file.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b index_file.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b options.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b options.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b output.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b output.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b path_table.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b path_table.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b utils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b volume_descriptor.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b volume_descriptor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dec_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v dec_datetime}
{\xe \v dec_datetime}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. }}\par
{
{\f2 #include <datetime.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b year} [{\b YEAR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b month} [{\b MONTH_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b day} [{\b HOUR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b hour} [{\b HOUR_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b minute} [{\b MINUTE_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b second} [{\b SECOND_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b hundredths_of_a_second} [{\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b time_zone_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses ASCII digits to represent the main parts of the date/time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Date/time_format} \par
{\b volume_descriptor} \par
}}}{
Definition at line {\b 38} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:dec_datetime}
{\xe \v dec_datetime\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::day[{\b HOUR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b datetime.h}.}\par
}
{\xe \v hour\:dec_datetime}
{\xe \v dec_datetime\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::hour[{\b HOUR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b datetime.h}.}\par
}
{\xe \v hundredths_of_a_second\:dec_datetime}
{\xe \v dec_datetime\:hundredths_of_a_second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::hundredths_of_a_second[{\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b datetime.h}.}\par
}
{\xe \v minute\:dec_datetime}
{\xe \v dec_datetime\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::minute[{\b MINUTE_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b datetime.h}.}\par
}
{\xe \v month\:dec_datetime}
{\xe \v dec_datetime\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::month[{\b MONTH_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b datetime.h}.}\par
}
{\xe \v second\:dec_datetime}
{\xe \v dec_datetime\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::second[{\b SECOND_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b datetime.h}.}\par
}
{\xe \v time_zone_offset\:dec_datetime}
{\xe \v dec_datetime\:time_zone_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dec_datetime::time_zone_offset}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b datetime.h}.}\par
}
{\xe \v year\:dec_datetime}
{\xe \v dec_datetime\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dec_datetime::year[{\b YEAR_FIELD_LEN}]}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b datetime.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dir_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v dir_datetime}
{\xe \v dir_datetime}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. }}\par
{
{\f2 #include <datetime.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b year}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of years since 1900. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b month}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b day}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b minute}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b second}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b time_zone_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This format is presumably used to save disc space over a large number of entries.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
{\b directory_record} \par
}}}{
Definition at line {\b 57} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:dir_datetime}
{\xe \v dir_datetime\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::day}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b datetime.h}.}\par
}
{\xe \v hour\:dir_datetime}
{\xe \v dir_datetime\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::hour}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b datetime.h}.}\par
}
{\xe \v minute\:dir_datetime}
{\xe \v dir_datetime\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::minute}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b datetime.h}.}\par
}
{\xe \v month\:dir_datetime}
{\xe \v dir_datetime\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::month}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b datetime.h}.}\par
}
{\xe \v second\:dir_datetime}
{\xe \v dir_datetime\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::second}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b datetime.h}.}\par
}
{\xe \v time_zone_offset\:dir_datetime}
{\xe \v dir_datetime\:time_zone_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::time_zone_offset}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b datetime.h}.}\par
}
{\xe \v year\:dir_datetime}
{\xe \v dir_datetime\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t dir_datetime::year}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of years since 1900. }}\par
{
Definition at line {\b 59} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b datetime.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory Struct Reference\par \pard\plain 
{\tc\tcl2 \v directory}
{\xe \v directory}
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. }}\par
{
{\f2 #include <directory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b directory_record} * {\b records}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the max capacity of {\f2 records} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_record}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last record in {\f2 records} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b directory_record} \par
}}}{
Definition at line {\b 60} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_record\:directory}
{\xe \v directory\:current_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t directory::current_record}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last record in {\f2 records} . }}\par
{
Definition at line {\b 64} of file {\b directory.h}.}\par
}
{\xe \v records\:directory}
{\xe \v directory\:records}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b directory_record}* directory::records}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b directory.h}.}\par
}
{\xe \v size\:directory}
{\xe \v directory\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t directory::size}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the max capacity of {\f2 records} . }}\par
{
Definition at line {\b 63} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b directory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory_record Struct Reference\par \pard\plain 
{\tc\tcl2 \v directory_record}
{\xe \v directory_record}
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. }}\par
{
{\f2 #include <directory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b extended_attribute_record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b location_of_extent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b data_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dir_datetime} {\b recording_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b file_flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_unit_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b interleave_gap_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_sequence_number}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_identifier_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b file_identifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions, except those with a return value of void, return zero on success and non-zero on failure. A directory record. It's perhaps easier to think of this as a {\f2 file} . It is worth noting, however, that we don't differentiate betewen files and subdirectories.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
}}}{
Definition at line {\b 38} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data_length\:directory_record}
{\xe \v directory_record\:data_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t directory_record::data_length}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b directory.h}.}\par
}
{\xe \v extended_attribute_record_length\:directory_record}
{\xe \v directory_record\:extended_attribute_record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::extended_attribute_record_length}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b directory.h}.}\par
}
{\xe \v file_flags\:directory_record}
{\xe \v directory_record\:file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} directory_record::file_flags}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b directory.h}.}\par
}
{\xe \v file_identifier\:directory_record}
{\xe \v directory_record\:file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* directory_record::file_identifier}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b directory.h}.}\par
}
{\xe \v file_identifier_length\:directory_record}
{\xe \v directory_record\:file_identifier_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::file_identifier_length}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b directory.h}.}\par
}
{\xe \v file_unit_size\:directory_record}
{\xe \v directory_record\:file_unit_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::file_unit_size}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }}\par
{
Definition at line {\b 47} of file {\b directory.h}.}\par
}
{\xe \v interleave_gap_size\:directory_record}
{\xe \v directory_record\:interleave_gap_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::interleave_gap_size}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only used by files recorded in interleaved mode. }}\par
{
Definition at line {\b 49} of file {\b directory.h}.}\par
}
{\xe \v location_of_extent\:directory_record}
{\xe \v directory_record\:location_of_extent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t directory_record::location_of_extent}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b directory.h}.}\par
}
{\xe \v record_length\:directory_record}
{\xe \v directory_record\:record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t directory_record::record_length}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b directory.h}.}\par
}
{\xe \v recording_datetime\:directory_record}
{\xe \v directory_record\:recording_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dir_datetime} directory_record::recording_datetime}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b directory.h}.}\par
}
{\xe \v volume_sequence_number\:directory_record}
{\xe \v directory_record\:volume_sequence_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t directory_record::volume_sequence_number}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b directory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b directory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags Struct Reference\par \pard\plain 
{\tc\tcl2 \v file_flags}
{\xe \v file_flags}
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. }}\par
{
{\f2 #include <file_flags.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hidden}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subdirectory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b associated_file}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No clue what this means. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b extended_attribute_record_contains_owner_and_group_permissions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b final_directory_record}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If false, this directory record is not the file's final resting place; the file spans over multiple extents. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The file flags for a directory record.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Directories} \par
{\b directory_record} \par
}}}{
Definition at line {\b 27} of file {\b file_flags.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v associated_file\:file_flags}
{\xe \v file_flags\:associated_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::associated_file}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No clue what this means. }}\par
{
Definition at line {\b 31} of file {\b file_flags.h}.}\par
}
{\xe \v extended_attribute_record_contains_owner_and_group_permissions\:file_flags}
{\xe \v file_flags\:extended_attribute_record_contains_owner_and_group_permissions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::extended_attribute_record_contains_owner_and_group_permissions}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b file_flags.h}.}\par
}
{\xe \v final_directory_record\:file_flags}
{\xe \v file_flags\:final_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::final_directory_record}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If false, this directory record is not the file's final resting place; the file spans over multiple extents. }}\par
{
Definition at line {\b 37} of file {\b file_flags.h}.}\par
}
{\xe \v hidden\:file_flags}
{\xe \v file_flags\:hidden}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::hidden}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b file_flags.h}.}\par
}
{\xe \v subdirectory\:file_flags}
{\xe \v file_flags\:subdirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_flags::subdirectory}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b file_flags.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b file_flags.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v index_entry}
{\xe \v index_entry}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entry of the associated {\f2 {\b index_file}} . }}\par
{
{\f2 #include <index_file.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b entry_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b full_path} [{\b FULL_PATH_MAX_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b filename} [{\b FILENAME_MAX_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b file_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b file_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entry of the associated {\f2 {\b index_file}} . \par
}{
Definition at line {\b 43} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v entry_start\:index_entry}
{\xe \v index_entry\:entry_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::entry_start}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b index_file.h}.}\par
}
{\xe \v file_offset\:index_entry}
{\xe \v index_entry\:file_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::file_offset}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b index_file.h}.}\par
}
{\xe \v file_start\:index_entry}
{\xe \v index_entry\:file_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t index_entry::file_start}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b index_file.h}.}\par
}
{\xe \v filename\:index_entry}
{\xe \v index_entry\:filename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char index_entry::filename[{\b FILENAME_MAX_LEN}]}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b index_file.h}.}\par
}
{\xe \v full_path\:index_entry}
{\xe \v index_entry\:full_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char index_entry::full_path[{\b FULL_PATH_MAX_LEN}]}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b index_file.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file Struct Reference\par \pard\plain 
{\tc\tcl2 \v index_file}
{\xe \v index_file}
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. }}\par
{
{\f2 #include <index_file.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b index_entry} * {\b indicies}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 indicies} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_index}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to last item in {\f2 indicies} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. \par
}{
Definition at line {\b 53} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_index\:index_file}
{\xe \v index_file\:current_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t index_file::current_index}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to last item in {\f2 indicies} . }}\par
{
Definition at line {\b 57} of file {\b index_file.h}.}\par
}
{\xe \v indicies\:index_file}
{\xe \v index_file\:indicies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b index_entry}* index_file::indicies}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b index_file.h}.}\par
}
{\xe \v size\:index_file}
{\xe \v index_file\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t index_file::size}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 indicies} . }}\par
{
Definition at line {\b 56} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b index_file.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table Struct Reference\par \pard\plain 
{\tc\tcl2 \v path_table}
{\xe \v path_table}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. }}\par
{
{\f2 #include <path_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b path_table_entry} * {\b entries}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b current_entry}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to most recent item in {\f2 entries} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. \par
}{
Definition at line {\b 42} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_entry\:path_table}
{\xe \v path_table\:current_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t path_table::current_entry}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pointer to most recent item in {\f2 entries} . }}\par
{
Definition at line {\b 46} of file {\b path_table.h}.}\par
}
{\xe \v entries\:path_table}
{\xe \v path_table\:entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b path_table_entry}* path_table::entries}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b path_table.h}.}\par
}
{\xe \v size\:path_table}
{\xe \v path_table\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t path_table::size}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max size of {\f2 entries} . }}\par
{
Definition at line {\b 45} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b path_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v path_table_entry}
{\xe \v path_table_entry}
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. }}\par
{
{\f2 #include <path_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b directory_identifier_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b extended_attribute_record_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b location_of_extent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b parent_directory_number}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indexed from 1 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b directory_identifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions, except those which are void, return zero on success and non-zero on failure. An entry of some path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#The_Path_Table} \par
}}}{
Definition at line {\b 32} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v directory_identifier\:path_table_entry}
{\xe \v path_table_entry\:directory_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* path_table_entry::directory_identifier}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b path_table.h}.}\par
}
{\xe \v directory_identifier_length\:path_table_entry}
{\xe \v path_table_entry\:directory_identifier_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t path_table_entry::directory_identifier_length}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b path_table.h}.}\par
}
{\xe \v extended_attribute_record_length\:path_table_entry}
{\xe \v path_table_entry\:extended_attribute_record_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t path_table_entry::extended_attribute_record_length}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b path_table.h}.}\par
}
{\xe \v location_of_extent\:path_table_entry}
{\xe \v path_table_entry\:location_of_extent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t path_table_entry::location_of_extent}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b path_table.h}.}\par
}
{\xe \v parent_directory_number\:path_table_entry}
{\xe \v path_table_entry\:parent_directory_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t path_table_entry::parent_directory_number}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indexed from 1 }}\par
{
Definition at line {\b 37} of file {\b path_table.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b path_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor Struct Reference\par \pard\plain 
{\tc\tcl2 \v volume_descriptor}
{\xe \v volume_descriptor}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. }}\par
{
{\f2 #include <volume_descriptor.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b type_code}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b identifier} [6]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 CD001} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b version}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b volume_descriptor_data} {\b data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#Volume_Descriptors} \par
}}}{
Definition at line {\b 81} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:volume_descriptor}
{\xe \v volume_descriptor\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b volume_descriptor_data} volume_descriptor::data}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b volume_descriptor.h}.}\par
}
{\xe \v identifier\:volume_descriptor}
{\xe \v volume_descriptor\:identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor::identifier[6]}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 CD001} . }}\par
{
Definition at line {\b 84} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_code\:volume_descriptor}
{\xe \v volume_descriptor\:type_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor::type_code}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b volume_descriptor.h}.}\par
}
{\xe \v version\:volume_descriptor}
{\xe \v volume_descriptor\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor::version}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b volume_descriptor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v volume_descriptor_data}
{\xe \v volume_descriptor_data}
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. }}\par
{
{\f2 #include <volume_descriptor.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b system_identifier} [{\b SYSTEM_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volume_identifier} [{\b VOLUME_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b volume_space_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_set_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b volume_sequence_number}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b logical_block_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b path_table_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b type_l_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b optional_type_l_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b type_m_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b optional_type_m_path_table_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b root_directory_entry} [{\b ROOT_DIRECTORY_ENTRY_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volume_set_identifier} [{\b VOLUME_SET_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b publisher_identifier} [{\b PUBLISHER_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b data_preparer_identifier} [{\b DATA_PREPARER_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b application_identifier} [{\b APPLICATION_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b copyright_file_identifier} [{\b COPYRIGHT_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b abstract_file_identifier} [{\b ABSTRACT_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bibliographic_file_identifier} [{\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_creation_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_modification_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_expiration_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dec_datetime} {\b volume_effective_date_and_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b file_structure_version}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 0x01}  }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b DAT_file_creation_software_identifier} [{\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b DAT_file_creation_software_version_number} [{\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor} \par
}}}{
Definition at line {\b 44} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v abstract_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:abstract_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::abstract_file_identifier[{\b ABSTRACT_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b volume_descriptor.h}.}\par
}
{\xe \v application_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:application_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::application_identifier[{\b APPLICATION_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b volume_descriptor.h}.}\par
}
{\xe \v bibliographic_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:bibliographic_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::bibliographic_file_identifier[{\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b volume_descriptor.h}.}\par
}
{\xe \v copyright_file_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:copyright_file_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::copyright_file_identifier[{\b COPYRIGHT_FILE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_file_creation_software_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:DAT_file_creation_software_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::DAT_file_creation_software_identifier[{\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_file_creation_software_version_number\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:DAT_file_creation_software_version_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::DAT_file_creation_software_version_number[{\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}]}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b volume_descriptor.h}.}\par
}
{\xe \v data_preparer_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:data_preparer_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::data_preparer_identifier[{\b DATA_PREPARER_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b volume_descriptor.h}.}\par
}
{\xe \v file_structure_version\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:file_structure_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor_data::file_structure_version}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always {\f2 0x01}  }}\par
{
Definition at line {\b 69} of file {\b volume_descriptor.h}.}\par
}
{\xe \v logical_block_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:logical_block_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::logical_block_size}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b volume_descriptor.h}.}\par
}
{\xe \v optional_type_l_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:optional_type_l_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::optional_type_l_path_table_location}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b volume_descriptor.h}.}\par
}
{\xe \v optional_type_m_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:optional_type_m_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::optional_type_m_path_table_location}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b volume_descriptor.h}.}\par
}
{\xe \v path_table_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:path_table_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::path_table_size}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b volume_descriptor.h}.}\par
}
{\xe \v publisher_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:publisher_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::publisher_identifier[{\b PUBLISHER_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b volume_descriptor.h}.}\par
}
{\xe \v root_directory_entry\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:root_directory_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t volume_descriptor_data::root_directory_entry[{\b ROOT_DIRECTORY_ENTRY_LEN}]}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b volume_descriptor.h}.}\par
}
{\xe \v system_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:system_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::system_identifier[{\b SYSTEM_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_l_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:type_l_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::type_l_path_table_location}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b volume_descriptor.h}.}\par
}
{\xe \v type_m_path_table_location\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:type_m_path_table_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::type_m_path_table_location}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_creation_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_creation_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_creation_date_and_time}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_effective_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_effective_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_effective_date_and_time}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_expiration_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_expiration_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_expiration_date_and_time}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::volume_identifier[{\b VOLUME_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_modification_date_and_time\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_modification_date_and_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b dec_datetime} volume_descriptor_data::volume_modification_date_and_time}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_sequence_number\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_sequence_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::volume_sequence_number}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_set_identifier\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_set_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volume_descriptor_data::volume_set_identifier[{\b VOLUME_SET_IDENTIFIER_LEN}]}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_set_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_set_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t volume_descriptor_data::volume_set_size}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b volume_descriptor.h}.}\par
}
{\xe \v volume_space_size\:volume_descriptor_data}
{\xe \v volume_descriptor_data\:volume_space_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t volume_descriptor_data::volume_space_size}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b volume_descriptor.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/data_reader.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b read_big_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint32} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint16} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_string} (FILE *fptr, char *output, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_array_uint8} (FILE *fptr, uint8_t *arr, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dec_datetime} (FILE *fptr, {\b dec_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_single_uint8} (FILE *fptr, uint8_t *value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dir_datetime} (FILE *fptr, {\b dir_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_file_flags} (FILE *fptr, {\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v read_array_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_array_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_array_uint8 (FILE * fptr, uint8_t * arr, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 154} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint16_t (FILE * fptr, uint16_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 125} of file {\b data_reader.c}.}\par
}
{\xe \v read_big_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_big_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_big_endian_data_uint32_t (FILE * fptr, uint32_t * output){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in big endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 94} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint16\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint16 (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint32() \par
}}}{
Definition at line {\b 55} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint32\:data_reader.c}
{\xe \v data_reader.c\:read_both_endian_data_uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint32 (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint16() \par
}}}{
Definition at line {\b 34} of file {\b data_reader.c}.}\par
}
{\xe \v read_dec_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dec_datetime (FILE * fptr, {\b dec_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 167} of file {\b data_reader.c}.}\par
}
{\xe \v read_dir_datetime\:data_reader.c}
{\xe \v data_reader.c\:read_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dir_datetime (FILE * fptr, {\b dir_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 200} of file {\b data_reader.c}.}\par
}
{\xe \v read_file_flags\:data_reader.c}
{\xe \v data_reader.c\:read_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_file_flags (FILE * fptr, {\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b file_flags} \par
}}}{
Definition at line {\b 217} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint16_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint16_t (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 110} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint32_t\:data_reader.c}
{\xe \v data_reader.c\:read_little_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint32_t (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 76} of file {\b data_reader.c}.}\par
}
{\xe \v read_single_uint8\:data_reader.c}
{\xe \v data_reader.c\:read_single_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_single_uint8 (FILE * fptr, uint8_t * value)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All of these functions return zero on success, non-zero on failure. The caller is responsible for freeing any memory which may or may not have been allocated during the use of these functions. Reads in a single uint8_t from a given file, storing the output in {\f2 value} . \par
}{
Definition at line {\b 187} of file {\b data_reader.c}.}\par
}
{\xe \v read_string\:data_reader.c}
{\xe \v data_reader.c\:read_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_string (FILE * fptr, char * output, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 140} of file {\b data_reader.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_reader.c\par \pard\plain 
{\tc\tcl2 \v src/data_reader.c}
{\xe \v src/data_reader.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "data_reader.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "file_flags.h"}\par
00017 \par
00018 {\cf21 #include <stdbool.h>}\par
00019 {\cf21 #include <stdint.h>}\par
00020 \par
00025 {\cf17 static} int8_t read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output);\par
00026 \par
00031 {\cf17 static} int8_t read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output);\par
00032 \par
00033 int8_t\par
00034 read_both_endian_data_uint32 (FILE *fptr, uint32_t *output)\par
00035 \{\par
00036   uint32_t value;\par
00037   {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00038     {\cf19 return} HH_FREAD_ERROR;\par
00039 \par
00040   uint32_t expected_value;\par
00041   read_big_endian_data_uint32_t (fptr, &expected_value);\par
00042 \par
00043   {\cf19 if} (value != expected_value)\par
00044     \{\par
00045       printf ({\cf22 "ERROR: Incorrect endian conversion (uint32_t).\\n\\tExpected "}\par
00046               {\cf22 "%08X, got %08X.\\n"},\par
00047               expected_value, value);\par
00048     \}\par
00049 \par
00050   *output = value;\par
00051   {\cf19 return} 0;\par
00052 \}\par
00053 \par
00054 int8_t\par
00055 read_both_endian_data_uint16 (FILE *fptr, uint16_t *output)\par
00056 \{\par
00057   {\cf19 if} (read_little_endian_data_uint16_t (fptr, output) != 0)\par
00058     {\cf19 return} HH_FREAD_ERROR;\par
00059 \par
00060   uint16_t expected_value;\par
00061   {\cf19 if} (read_big_endian_data_uint16_t (fptr, &expected_value) != 0)\par
00062     {\cf19 return} HH_FREAD_ERROR;\par
00063 \par
00064   {\cf19 if} (*output != expected_value)\par
00065     \{\par
00066       printf ({\cf22 "ERROR: Incorrect endian conversion (uint16_t).\\n\\tExpected "}\par
00067               {\cf22 "%04X, got %04X.\\n"},\par
00068               expected_value, *output);\par
00069       {\cf19 return} -1;\par
00070     \}\par
00071 \par
00072   {\cf19 return} 0;\par
00073 \}\par
00074 \par
00075 int8_t\par
00076 read_little_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00077 \{\par
00078   uint8_t bytes[4];\par
00079   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00080   {\cf19 if} (bytes_read != 4)\par
00081     \{\par
00082       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00083 \par
00084       {\cf19 return} HH_FREAD_ERROR;\par
00085     \}\par
00086 \par
00087   *output = ((uint32_t)bytes[3] << 24) | ((uint32_t)bytes[2] << 16)\par
00088             | ((uint32_t)bytes[1] << 8) | (uint32_t)bytes[0];\par
00089 \par
00090   {\cf19 return} 0;\par
00091 \}\par
00092 \par
00093 int8_t\par
00094 read_big_endian_data_uint32_t (FILE *fptr, uint32_t *output)\par
00095 \{\par
00096   uint8_t bytes[4];\par
00097   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 4, fptr);\par
00098   {\cf19 if} (bytes_read != 4)\par
00099     \{\par
00100       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00101       {\cf19 return} HH_FREAD_ERROR;\par
00102     \}\par
00103 \par
00104   *output = ((uint32_t)bytes[0] << 24) | ((uint32_t)bytes[1] << 16)\par
00105             | ((uint32_t)bytes[2] << 8) | (uint32_t)bytes[3];\par
00106   {\cf19 return} 0;\par
00107 \}\par
00108 \par
00109 int8_t\par
00110 read_little_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00111 \{\par
00112   uint8_t bytes[2];\par
00113   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00114   {\cf19 if} (bytes_read != 2)\par
00115     \{\par
00116       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00117       {\cf19 return} HH_FREAD_ERROR;\par
00118     \}\par
00119 \par
00120   *output = ((uint16_t)bytes[0] << 8) | (uint16_t)bytes[1];\par
00121   {\cf19 return} 0;\par
00122 \}\par
00123 \par
00124 int8_t\par
00125 read_big_endian_data_uint16_t (FILE *fptr, uint16_t *output)\par
00126 \{\par
00127   uint8_t bytes[2];\par
00128   {\cf18 size_t} bytes_read = fread (bytes, {\cf17 sizeof} (uint8_t), 2, fptr);\par
00129   {\cf19 if} (bytes_read != 2)\par
00130     \{\par
00131       handle_fread_error (bytes_read, {\cf17 sizeof} (bytes));\par
00132       {\cf19 return} HH_FREAD_ERROR;\par
00133     \}\par
00134 \par
00135   *output = ((uint16_t)bytes[1] << 8) | (uint16_t)bytes[0];\par
00136   {\cf19 return} 0;\par
00137 \}\par
00138 \par
00139 int8_t\par
00140 read_string (FILE *fptr, {\cf18 char} *output, uint8_t length)\par
00141 \{\par
00142   {\cf18 size_t} bytes_read = fread (output, {\cf17 sizeof} ({\cf18 char}), length - 1, fptr);\par
00143   output[length - 1] = {\cf23 '\\0'};\par
00144   {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * length - 1)\par
00145     \{\par
00146       handle_fread_error (bytes_read, {\cf17 sizeof} ({\cf18 char}) * length - 1);\par
00147       {\cf19 return} HH_FREAD_ERROR;\par
00148     \}\par
00149 \par
00150   {\cf19 return} 0;\par
00151 \}\par
00152 \par
00153 int8_t\par
00154 read_array_uint8 (FILE *fptr, uint8_t *arr, uint8_t length)\par
00155 \{\par
00156   {\cf18 size_t} bytes_read = fread (arr, {\cf17 sizeof} (uint8_t), length, fptr);\par
00157   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t) * length)\par
00158     \{\par
00159       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t) * length);\par
00160       {\cf19 return} HH_FREAD_ERROR;\par
00161     \}\par
00162 \par
00163   {\cf19 return} 0;\par
00164 \}\par
00165 \par
00166 int8_t\par
00167 read_dec_datetime (FILE *fptr, dec_datetime *dt)\par
00168 \{\par
00169   {\cf19 if} ((read_string (fptr, dt->year, YEAR_FIELD_LEN) != 0)\par
00170       || (read_string (fptr, dt->month, MONTH_FIELD_LEN) != 0)\par
00171       || (read_string (fptr, dt->day, DAY_FIELD_LEN) != 0)\par
00172       || (read_string (fptr, dt->hour, HOUR_FIELD_LEN) != 0)\par
00173       || (read_string (fptr, dt->minute, MINUTE_FIELD_LEN) != 0)\par
00174       || (read_string (fptr, dt->second, SECOND_FIELD_LEN) != 0)\par
00175       || (read_string (fptr, dt->hundredths_of_a_second,\par
00176                        HUNDREDTHS_OF_A_SECOND_FIELD_LEN)\par
00177           != 0)\par
00178       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00179     \{\par
00180       {\cf19 return} HH_FREAD_ERROR;\par
00181     \}\par
00182 \par
00183   {\cf19 return} 0;\par
00184 \}\par
00185 \par
00186 int8_t\par
00187 read_single_uint8 (FILE *fptr, uint8_t *value)\par
00188 \{\par
00189   {\cf18 size_t} bytes_read = fread (value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00190   {\cf19 if} (bytes_read != {\cf17 sizeof} (uint8_t))\par
00191     \{\par
00192       handle_fread_error (bytes_read, {\cf17 sizeof} (uint8_t));\par
00193       {\cf19 return} HH_FREAD_ERROR;\par
00194     \}\par
00195 \par
00196   {\cf19 return} 0;\par
00197 \}\par
00198 \par
00199 int8_t\par
00200 read_dir_datetime (FILE *fptr, dir_datetime *dt)\par
00201 \{\par
00202   {\cf19 if} ((read_single_uint8 (fptr, &dt->year) != 0)\par
00203       || (read_single_uint8 (fptr, &dt->month) != 0)\par
00204       || (read_single_uint8 (fptr, &dt->day) != 0)\par
00205       || (read_single_uint8 (fptr, &dt->hour) != 0)\par
00206       || (read_single_uint8 (fptr, &dt->minute) != 0)\par
00207       || (read_single_uint8 (fptr, &dt->second) != 0)\par
00208       || (read_single_uint8 (fptr, &dt->time_zone_offset) != 0))\par
00209     \{\par
00210       {\cf19 return} HH_FREAD_ERROR;\par
00211     \}\par
00212 \par
00213   {\cf19 return} 0;\par
00214 \}\par
00215 \par
00216 int8_t\par
00217 read_file_flags (FILE *fptr, file_flags *ff)\par
00218 \{\par
00219   uint8_t byte;\par
00220   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00221     {\cf19 return} HH_FREAD_ERROR;\par
00222 \par
00223   {\cf19 if} ({\cf18 byte} & 0x1)\par
00224     \{\par
00225       ff->hidden = {\cf17 true};\par
00226     \}\par
00227   {\cf19 if} ({\cf18 byte} & 0x2)\par
00228     \{\par
00229       ff->subdirectory = {\cf17 true};\par
00230     \}\par
00231   {\cf19 if} ({\cf18 byte} & 0x4)\par
00232     \{\par
00233       ff->associated_file = {\cf17 true};\par
00234     \}\par
00235   {\cf19 if} ({\cf18 byte} & 0x8)\par
00236     \{\par
00237       ff->extended_attribute_record_contains_owner_and_group_permissions\par
00238           = {\cf17 true};\par
00239     \}\par
00240   {\cf19 if} ({\cf18 byte} & 0x10)\par
00241     \{\par
00242       ff->final_directory_record = {\cf17 true};\par
00243     \}\par
00244 \par
00245   {\cf19 return} 0;\par
00246 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/data_reader.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/data_reader.h}
{\xe \v src/data_reader.h}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_single_uint8} (FILE *fptr, uint8_t *value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint16_t} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_little_endian_data_uint32_t} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint16} (FILE *fptr, uint16_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_both_endian_data_uint32} (FILE *fptr, uint32_t *output)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_string} (FILE *fptr, char *output, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_array_uint8} (FILE *fptr, uint8_t *arr, uint8_t length)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dec_datetime} (FILE *fptr, {\b dec_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_dir_datetime} (FILE *fptr, {\b dir_datetime} *dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b read_file_flags} (FILE *fptr, {\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v read_array_uint8\:data_reader.h}
{\xe \v data_reader.h\:read_array_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_array_uint8 (FILE * fptr, uint8_t * arr, uint8_t length)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads an array of uint8_t's, of a given length, from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 154} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint16\:data_reader.h}
{\xe \v data_reader.h\:read_both_endian_data_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint16 (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint32() \par
}}}{
Definition at line {\b 55} of file {\b data_reader.c}.}\par
}
{\xe \v read_both_endian_data_uint32\:data_reader.h}
{\xe \v data_reader.h\:read_both_endian_data_uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_both_endian_data_uint32 (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When data in a given file is presented first in little endian form and then repeated in big endian form, this function will read both values, double checking that the first matches the second, and and storing the result into {\f2 output} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is almost certainly unnecessary, but it makes me feel better :).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
read_both_endian_data_unint16() \par
}}}{
Definition at line {\b 34} of file {\b data_reader.c}.}\par
}
{\xe \v read_dec_datetime\:data_reader.h}
{\xe \v data_reader.h\:read_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dec_datetime (FILE * fptr, {\b dec_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dec_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 167} of file {\b data_reader.c}.}\par
}
{\xe \v read_dir_datetime\:data_reader.h}
{\xe \v data_reader.h\:read_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_dir_datetime (FILE * fptr, {\b dir_datetime} * dt)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 {\b dir_datetime}}  data from a given file, storing the output in {\f2 dt} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 200} of file {\b data_reader.c}.}\par
}
{\xe \v read_file_flags\:data_reader.h}
{\xe \v data_reader.h\:read_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_file_flags (FILE * fptr, {\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in {\f2 file_flag}  data from a given file, storing the output in {\f2 ff} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b file_flags} \par
}}}{
Definition at line {\b 217} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint16_t\:data_reader.h}
{\xe \v data_reader.h\:read_little_endian_data_uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint16_t (FILE * fptr, uint16_t * output)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint16_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 110} of file {\b data_reader.c}.}\par
}
{\xe \v read_little_endian_data_uint32_t\:data_reader.h}
{\xe \v data_reader.h\:read_little_endian_data_uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_little_endian_data_uint32_t (FILE * fptr, uint32_t * output)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a uint32_t stored in little endian format from the file pointed to by {\f2 fptr}  and stores the result in {\f2 output} . }}\par
{
Definition at line {\b 76} of file {\b data_reader.c}.}\par
}
{\xe \v read_single_uint8\:data_reader.h}
{\xe \v data_reader.h\:read_single_uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_single_uint8 (FILE * fptr, uint8_t * value)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data_header.h - container for various data access functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All of these functions return zero on success, non-zero on failure. The caller is responsible for freeing any memory which may or may not have been allocated during the use of these functions. Reads in a single uint8_t from a given file, storing the output in {\f2 value} . \par
}{
Definition at line {\b 187} of file {\b data_reader.c}.}\par
}
{\xe \v read_string\:data_reader.h}
{\xe \v data_reader.h\:read_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t read_string (FILE * fptr, char * output, uint8_t length)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a string of a given length from a given file, storing the result in {\f2 output} . }}\par
{
Definition at line {\b 140} of file {\b data_reader.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_reader.h\par \pard\plain 
{\tc\tcl2 \v src/data_reader.h}
{\xe \v src/data_reader.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_DATA_READER_H_}\par
00022 {\cf21 #define _HH_DATA_READER_H_}\par
00023 \par
00024 {\cf21 #include "datetime.h"}\par
00025 {\cf21 #include "file_flags.h"}\par
00026 \par
00027 {\cf21 #include <stdint.h>}\par
00028 {\cf21 #include <stdio.h>}\par
00029 \par
00033 int8_t read_single_uint8 (FILE *fptr, uint8_t *value);\par
00034 \par
00039 int8_t read_little_endian_data_uint16_t (FILE *fptr, uint16_t *output);\par
00040 \par
00045 int8_t read_little_endian_data_uint32_t (FILE *fptr, uint32_t *output);\par
00046 \par
00056 int8_t read_both_endian_data_uint16 (FILE *fptr, uint16_t *output);\par
00057 \par
00067 int8_t read_both_endian_data_uint32 (FILE *fptr, uint32_t *output);\par
00068 \par
00073 int8_t read_string (FILE *fptr, {\cf18 char} *output, uint8_t length);\par
00074 \par
00079 int8_t read_array_uint8 (FILE *fptr, uint8_t *arr, uint8_t length);\par
00080 \par
00086 int8_t read_dec_datetime (FILE *fptr, dec_datetime *dt);\par
00087 \par
00093 int8_t read_dir_datetime (FILE *fptr, dir_datetime *dt);\par
00094 \par
00100 int8_t read_file_flags (FILE *fptr, file_flags *ff);\par
00101 \par
00102 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/datetime.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dec_datetime} ({\b dec_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dir_datetime} ({\b dir_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_dec_datetime\:datetime.c}
{\xe \v datetime.c\:print_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dec_datetime ({\b dec_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 6} of file {\b datetime.c}.}\par
}
{\xe \v print_dir_datetime\:datetime.c}
{\xe \v datetime.c\:print_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dir_datetime ({\b dir_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 14} of file {\b datetime.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.c\par \pard\plain 
{\tc\tcl2 \v src/datetime.c}
{\xe \v src/datetime.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "datetime.h"}\par
00002 \par
00003 {\cf21 #include <stdio.h>}\par
00004 \par
00005 {\cf18 void}\par
00006 print_dec_datetime (dec_datetime dt)\par
00007 \{\par
00008   printf ({\cf22 "%s-%s-%s @ %s:%s:%s.%s (%02X)\\n"}, dt.year, dt.month, dt.day,\par
00009           dt.hour, dt.minute, dt.second, dt.hundredths_of_a_second,\par
00010           dt.time_zone_offset);\par
00011 \}\par
00012 \par
00013 {\cf18 void}\par
00014 print_dir_datetime (dir_datetime dt)\par
00015 \{\par
00016   printf ({\cf22 "%02X-%02X-%02X @ %02X:%02X:%02X (%02X)\\n"}, dt.year, dt.month,\par
00017           dt.day, dt.hour, dt.minute, dt.second, dt.time_zone_offset);\par
00018 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/datetime.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/datetime.h}
{\xe \v src/datetime.h}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dec_datetime}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by Primary Volume Descriptors. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dir_datetime}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The date/time format used by directory records. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YEAR_FIELD_LEN}\~ 5\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b datetime.h} - contains the {\f2 {\b dec_datetime}}  and {\f2 {\b dir_datetime}}  data types and their associated functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MONTH_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAY_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HOUR_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MINUTE_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECOND_FIELD_LEN}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HUNDREDTHS_OF_A_SECOND_FIELD_LEN}\~ 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dec_datetime} ({\b dec_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_dir_datetime} ({\b dir_datetime} dt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DAY_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:DAY_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAY_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b datetime.h}.}\par
}
{\xe \v HOUR_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:HOUR_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HOUR_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b datetime.h}.}\par
}
{\xe \v HUNDREDTHS_OF_A_SECOND_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:HUNDREDTHS_OF_A_SECOND_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HUNDREDTHS_OF_A_SECOND_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b datetime.h}.}\par
}
{\xe \v MINUTE_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:MINUTE_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MINUTE_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b datetime.h}.}\par
}
{\xe \v MONTH_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:MONTH_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MONTH_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b datetime.h}.}\par
}
{\xe \v SECOND_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:SECOND_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECOND_FIELD_LEN\~ 3}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b datetime.h}.}\par
}
{\xe \v YEAR_FIELD_LEN\:datetime.h}
{\xe \v datetime.h\:YEAR_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YEAR_FIELD_LEN\~ 5}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b datetime.h} - contains the {\f2 {\b dec_datetime}}  and {\f2 {\b dir_datetime}}  data types and their associated functions. }}\par
{
Definition at line {\b 23} of file {\b datetime.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_dec_datetime\:datetime.h}
{\xe \v datetime.h\:print_dec_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dec_datetime ({\b dec_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dec_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dec_datetime} \par
}}}{
Definition at line {\b 6} of file {\b datetime.c}.}\par
}
{\xe \v print_dir_datetime\:datetime.h}
{\xe \v datetime.h\:print_dir_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_dir_datetime ({\b dir_datetime} dt)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the attributes of a {\f2 {\b dir_datetime}}  to the console in a human-readable form. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b dir_datetime} \par
}}}{
Definition at line {\b 14} of file {\b datetime.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.h\par \pard\plain 
{\tc\tcl2 \v src/datetime.h}
{\xe \v src/datetime.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00018 {\cf21 #ifndef _HH_DATETIME_H_}\par
00019 {\cf21 #define _HH_DATETIME_H_}\par
00020 \par
00021 {\cf21 #include <stdint.h>}\par
00022 \par
00023 {\cf21 #define YEAR_FIELD_LEN 5}\par
00024 {\cf21 #define MONTH_FIELD_LEN 3}\par
00025 {\cf21 #define DAY_FIELD_LEN 3}\par
00026 {\cf21 #define HOUR_FIELD_LEN 3}\par
00027 {\cf21 #define MINUTE_FIELD_LEN 3}\par
00028 {\cf21 #define SECOND_FIELD_LEN 3}\par
00029 {\cf21 #define HUNDREDTHS_OF_A_SECOND_FIELD_LEN 3}\par
00030 \par
00038 {\cf17 typedef} {\cf17 struct }dec_datetime\par
00039 \{\par
00040   {\cf18 char} year[YEAR_FIELD_LEN];\par
00041   {\cf18 char} month[MONTH_FIELD_LEN];\par
00042   {\cf18 char} day[HOUR_FIELD_LEN];\par
00043   {\cf18 char} hour[HOUR_FIELD_LEN];\par
00044   {\cf18 char} minute[MINUTE_FIELD_LEN];\par
00045   {\cf18 char} second[SECOND_FIELD_LEN];\par
00046   {\cf18 char} hundredths_of_a_second[HUNDREDTHS_OF_A_SECOND_FIELD_LEN];\par
00047   uint8_t time_zone_offset;\par
00048 \} dec_datetime;\par
00049 \par
00057 {\cf17 typedef} {\cf17 struct }dir_datetime\par
00058 \{\par
00059   uint8_t year; \par
00060   uint8_t month;\par
00061   uint8_t day;\par
00062   uint8_t hour;\par
00063   uint8_t minute;\par
00064   uint8_t second;\par
00065   uint8_t time_zone_offset;\par
00066 \} dir_datetime;\par
00067 \par
00074 {\cf18 void} print_dec_datetime (dec_datetime dt);\par
00075 \par
00082 {\cf18 void} print_dir_datetime (dir_datetime dt);\par
00083 \par
00084 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/directory.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "directory.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_directory_records} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_record_to_directory} ({\b directory} *d, {\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory_record} ({\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_directory} (FILE *fptr, {\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_STARTING_NUM_RECORDS} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b DIR_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_record_to_directory\:directory.c}
{\xe \v directory.c\:add_record_to_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_record_to_directory ({\b directory} * d, {\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }}\par
{
Definition at line {\b 69} of file {\b directory.c}.}\par
}
{\xe \v create_directory\:directory.c}
{\xe \v directory.c\:create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, a directory has {\f2 DIR_STARTING_NUM_RECORDS}  records. \par
}{
Definition at line {\b 32} of file {\b directory.c}.}\par
}
{\xe \v destroy_directory\:directory.c}
{\xe \v directory.c\:destroy_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }}\par
{
Definition at line {\b 53} of file {\b directory.c}.}\par
}
{\xe \v print_directory\:directory.c}
{\xe \v directory.c\:print_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }}\par
{
Definition at line {\b 123} of file {\b directory.c}.}\par
}
{\xe \v print_directory_record\:directory.c}
{\xe \v directory.c\:print_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory_record ({\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }}\par
{
Definition at line {\b 83} of file {\b directory.c}.}\par
}
{\xe \v process_directory\:directory.c}
{\xe \v directory.c\:process_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_directory (FILE * fptr, {\b directory} * d)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 135} of file {\b directory.c}.}\par
}
{\xe \v resize_directory_records\:directory.c}
{\xe \v directory.c\:resize_directory_records}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_directory_records ({\b directory} * d){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the size of a given directory's {\f2 records}  attribute by a factor of {\f2 DIR_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 100} of file {\b directory.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v DIR_RECORDS_GROWTH_RATE\:directory.c}
{\xe \v directory.c\:DIR_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b directory.c}.}\par
}
{\xe \v DIR_STARTING_NUM_RECORDS\:directory.c}
{\xe \v directory.c\:DIR_STARTING_NUM_RECORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t DIR_STARTING_NUM_RECORDS = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b directory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory.c\par \pard\plain 
{\tc\tcl2 \v src/directory.c}
{\xe \v src/directory.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "directory.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <stdio.h>}\par
00020 {\cf21 #include <stdlib.h>}\par
00021 \par
00022 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_STARTING_NUM_RECORDS = 10;\par
00023 {\cf17 static} {\cf17 const} {\cf18 size_t} DIR_RECORDS_GROWTH_RATE = 2;\par
00024 \par
00029 {\cf17 static} int8_t resize_directory_records (directory *d);\par
00030 \par
00031 int8_t\par
00032 create_directory (directory *d)\par
00033 \{\par
00034   d->records = malloc ({\cf17 sizeof} (directory_record) * DIR_STARTING_NUM_RECORDS);\par
00035   {\cf19 if} (d->records == NULL)\par
00036     \{\par
00037       perror ({\cf22 "ERROR: Failed to allocate memory for directory."});\par
00038       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00039     \}\par
00040 \par
00041   d->size = DIR_STARTING_NUM_RECORDS;\par
00042   d->current_record = 0;\par
00043 \par
00044   {\cf19 for} ({\cf18 size_t} i = 0; i < DIR_STARTING_NUM_RECORDS; i++)\par
00045     \{\par
00046       d->records[i].file_identifier = NULL;\par
00047     \}\par
00048 \par
00049   {\cf19 return} 0;\par
00050 \}\par
00051 \par
00052 {\cf18 void}\par
00053 destroy_directory (directory *d)\par
00054 \{\par
00055   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00056     \{\par
00057       {\cf19 if} (d->records[i].file_identifier == NULL)\par
00058         {\cf19 continue};\par
00059 \par
00060       free (d->records[i].file_identifier);\par
00061       d->records[i].file_identifier = NULL;\par
00062     \}\par
00063 \par
00064   free (d->records);\par
00065   d->records = NULL;\par
00066 \}\par
00067 \par
00068 int8_t\par
00069 add_record_to_directory (directory *d, directory_record *r)\par
00070 \{\par
00071   {\cf19 if} (d->current_record >= d->size)\par
00072     \{\par
00073       {\cf19 if} (resize_directory_records (d) != 0)\par
00074         {\cf19 return} -1;\par
00075     \}\par
00076 \par
00077   d->records[d->current_record] = *r;\par
00078   d->current_record++;\par
00079   {\cf19 return} 0;\par
00080 \}\par
00081 \par
00082 {\cf18 void}\par
00083 print_directory_record (directory_record *r)\par
00084 \{\par
00085   printf ({\cf22 "Record length: %02X\\n"}, r->record_length);\par
00086   printf ({\cf22 "Extended attribute record length: %02X\\n"},\par
00087           r->extended_attribute_record_length);\par
00088   printf ({\cf22 "Location of extent: %08X\\n"}, r->location_of_extent);\par
00089   printf ({\cf22 "Data length: %08X\\n"}, r->data_length);\par
00090   print_dir_datetime (r->recording_datetime);\par
00091   print_file_flags (&r->file_flags);\par
00092   printf ({\cf22 "File unit size: %02X\\n"}, r->file_unit_size);\par
00093   printf ({\cf22 "Interleave gap size: %02X\\n"}, r->interleave_gap_size);\par
00094   printf ({\cf22 "Volume sequence number: %04X\\n"}, r->volume_sequence_number);\par
00095   printf ({\cf22 "File identifier length: %02X\\n"}, r->file_identifier_length);\par
00096   printf ({\cf22 "File identifier: %s\\n"}, r->file_identifier);\par
00097 \}\par
00098 \par
00099 int8_t\par
00100 resize_directory_records (directory *d)\par
00101 \{\par
00102   {\cf18 size_t} new_size = d->size * DIR_RECORDS_GROWTH_RATE;\par
00103   directory_record *new_records = (directory_record *)realloc (\par
00104       d->records, sizeof (directory_record) * new_size);\par
00105   {\cf19 if} (new_records == NULL)\par
00106     \{\par
00107       perror ({\cf22 "ERROR: failed to reallocate memory for the directory records."});\par
00108       destroy_directory (d);\par
00109       {\cf19 return} -1;\par
00110     \}\par
00111 \par
00112   d->records = new_records;\par
00113   {\cf19 for} ({\cf18 size_t} i = d->size; i < new_size; i++)\par
00114     \{\par
00115       d->records[i].file_identifier = NULL;\par
00116     \}\par
00117 \par
00118   d->size = new_size;\par
00119   {\cf19 return} 0;\par
00120 \}\par
00121 \par
00122 {\cf18 void}\par
00123 print_directory (directory *d)\par
00124 \{\par
00125   printf ({\cf22 "Number of records: %zu\\n"}, d->current_record + 1);\par
00126   {\cf19 for} ({\cf18 size_t} i = 0; i < d->current_record; i++)\par
00127     \{\par
00128       printf ({\cf22 "!!! Record #%zu\\n"}, i + 1);\par
00129       print_directory_record (&d->records[i]);\par
00130       puts ({\cf22 "-------------------------------"});\par
00131     \}\par
00132 \}\par
00133 \par
00134 int8_t\par
00135 process_directory (FILE *fptr, directory *d)\par
00136 \{\par
00137   uint8_t single_byte;\par
00138   {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00139     {\cf19 return} HH_FREAD_ERROR;\par
00140 \par
00141   {\cf19 do}\par
00142     \{\par
00143       directory_record dr;\par
00144       dr.record_length = single_byte;\par
00145 \par
00146       {\cf19 if} ((read_single_uint8 (fptr, &dr.extended_attribute_record_length) != 0)\par
00147           || (read_both_endian_data_uint32 (fptr, &dr.location_of_extent) != 0)\par
00148           || (read_both_endian_data_uint32 (fptr, &dr.data_length) != 0)\par
00149           || (read_dir_datetime (fptr, &dr.recording_datetime) != 0))\par
00150         \{\par
00151           {\cf19 return} HH_FREAD_ERROR;\par
00152         \}\par
00153 \par
00154       dr.file_flags = create_file_flags ();\par
00155       read_file_flags (fptr, &dr.file_flags);\par
00156 \par
00157       {\cf19 if} (read_single_uint8 (fptr, &dr.file_unit_size) != 0\par
00158           || read_single_uint8 (fptr, &dr.interleave_gap_size) != 0)\par
00159         \{\par
00160           {\cf19 return} HH_FREAD_ERROR;\par
00161         \}\par
00162 \par
00163       {\cf19 if} (read_both_endian_data_uint16 (fptr, &dr.volume_sequence_number) != 0)\par
00164         {\cf19 return} HH_FREAD_ERROR;\par
00165 \par
00166       {\cf19 if} (read_single_uint8 (fptr, &dr.file_identifier_length) != 0)\par
00167         \{\par
00168           {\cf19 return} HH_FREAD_ERROR;\par
00169         \}\par
00170       dr.file_identifier_length++;\par
00171 \par
00172       dr.file_identifier\par
00173           = ({\cf18 char} *)calloc (dr.file_identifier_length, sizeof ({\cf18 char}));\par
00174       {\cf18 size_t} bytes_read = fread (dr.file_identifier, sizeof ({\cf18 char}),\par
00175                                  dr.file_identifier_length - 1, fptr);\par
00176       dr.file_identifier[dr.file_identifier_length - 1] = {\cf23 '\\0'};\par
00177       {\cf19 if} (bytes_read != {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1))\par
00178         \{\par
00179           handle_fread_error (bytes_read,\par
00180                               {\cf17 sizeof} ({\cf18 char}) * (dr.file_identifier_length - 1));\par
00181           {\cf19 return} HH_FREAD_ERROR;\par
00182         \}\par
00183 \par
00184       {\cf19 if} (add_record_to_directory (d, &dr) != 0)\par
00185         \{\par
00186           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00187         \}\par
00188 \par
00189       {\cf19 if} (dr.file_identifier_length % 2 != 0) {\cf20 // handle padding field}\par
00190         fseek (fptr, 1, SEEK_CUR);\par
00191 \par
00192       {\cf19 if} (read_single_uint8 (fptr, &single_byte) != 0)\par
00193         {\cf19 return} HH_FREAD_ERROR;\par
00194     \}\par
00195   {\cf19 while} (single_byte != 0);\par
00196 \par
00197   {\cf19 return} 0;\par
00198 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/directory.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/directory.h}
{\xe \v src/directory.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include "file_flags.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b directory_record}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b directory.h} - the {\f2 directory}  and {\f2 {\b directory_record}}  datatypes and their associated functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b directory}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of directory records which together make a single directory. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_record_to_directory} ({\b directory} *d, {\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory} ({\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_directory_record} ({\b directory_record} *r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_directory} (FILE *fptr, {\b directory} *d)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_record_to_directory\:directory.h}
{\xe \v directory.h\:add_record_to_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_record_to_directory ({\b directory} * d, {\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a directory record to the given directory, adjusting the size of said directory's array of records as needed. }}\par
{
Definition at line {\b 69} of file {\b directory.c}.}\par
}
{\xe \v create_directory\:directory.h}
{\xe \v directory.h\:create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, a directory has {\f2 DIR_STARTING_NUM_RECORDS}  records. \par
}{
Definition at line {\b 32} of file {\b directory.c}.}\par
}
{\xe \v destroy_directory\:directory.h}
{\xe \v directory.h\:destroy_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys all the directory records within a given directory before then destroying the directory itself. }}\par
{
Definition at line {\b 53} of file {\b directory.c}.}\par
}
{\xe \v print_directory\:directory.h}
{\xe \v directory.h\:print_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory ({\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory to stdout in a human-readable form. }}\par
{
Definition at line {\b 123} of file {\b directory.c}.}\par
}
{\xe \v print_directory_record\:directory.h}
{\xe \v directory.h\:print_directory_record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_directory_record ({\b directory_record} * r)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a given directory record to the stdout in a human-readable form. }}\par
{
Definition at line {\b 83} of file {\b directory.c}.}\par
}
{\xe \v process_directory\:directory.h}
{\xe \v directory.h\:process_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_directory (FILE * fptr, {\b directory} * d)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directory records for every sub-directory and file in a given directory, filling out each data field of said record using the data found in the file pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 135} of file {\b directory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
directory.h\par \pard\plain 
{\tc\tcl2 \v src/directory.h}
{\xe \v src/directory.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_DIRECTORY_H_}\par
00022 {\cf21 #define _HH_DIRECTORY_H_}\par
00023 \par
00024 {\cf21 #include "datetime.h"}\par
00025 {\cf21 #include "file_flags.h"}\par
00026 \par
00027 {\cf21 #include <stdint.h>}\par
00028 {\cf21 #include <stdio.h>}\par
00029 {\cf21 #include <stdlib.h>}\par
00030 \par
00038 {\cf17 typedef} {\cf17 struct }directory_record\par
00039 \{\par
00040   uint8_t record_length;\par
00041   uint8_t extended_attribute_record_length;\par
00042   uint32_t location_of_extent;\par
00043   uint32_t data_length;\par
00044   dir_datetime recording_datetime;\par
00045   file_flags file_flags;\par
00047   uint8_t file_unit_size;\par
00049   uint8_t interleave_gap_size;\par
00050   uint16_t volume_sequence_number;\par
00051   uint8_t file_identifier_length;\par
00052   {\cf18 char} *file_identifier;\par
00053 \} directory_record;\par
00054 \par
00060 {\cf17 typedef} {\cf17 struct }directory\par
00061 \{\par
00062   directory_record *records;\par
00063   {\cf18 size_t} size;           \par
00064   {\cf18 size_t} current_record; \par
00065 \} directory;\par
00066 \par
00071 int8_t create_directory (directory *d);\par
00072 \par
00077 {\cf18 void} destroy_directory (directory *d);\par
00078 \par
00083 int8_t add_record_to_directory (directory *d, directory_record *r);\par
00084 \par
00088 {\cf18 void} print_directory (directory *d);\par
00089 \par
00093 {\cf18 void} print_directory_record (directory_record *r);\par
00094 \par
00100 int8_t process_directory (FILE *fptr, directory *d);\par
00101 \par
00102 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/errors.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "errors.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b improper_usage_error} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an improper usage error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fopen_error} (char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fread_error} (size_t actual, size_t expected_bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_unknown_command_line_argument_error} (char *arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CALLOC_FAILED_ERR_MSG_FMT} = "ERROR: unable to calloc string of size %zu.\\n"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed calloc error message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b FOPEN_FAILED_ERR_MSG_FMT} = "ERROR: unable to open output file, %s\\n."\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fopen_error\:errors.c}
{\xe \v errors.c\:fopen_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fopen_error (char * filename)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }}\par
{
Definition at line {\b 28} of file {\b errors.c}.}\par
}
{\xe \v handle_fread_error\:errors.c}
{\xe \v errors.c\:handle_fread_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fread_error (size_t actual, size_t expected_bytes)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }}\par
{
Definition at line {\b 34} of file {\b errors.c}.}\par
}
{\xe \v handle_unknown_command_line_argument_error\:errors.c}
{\xe \v errors.c\:handle_unknown_command_line_argument_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_unknown_command_line_argument_error (char * arg)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }}\par
{
Definition at line {\b 42} of file {\b errors.c}.}\par
}
{\xe \v improper_usage_error\:errors.c}
{\xe \v errors.c\:improper_usage_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void improper_usage_error (void )}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an improper usage error. }}\par
{
Definition at line {\b 12} of file {\b errors.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CALLOC_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:CALLOC_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CALLOC_FAILED_ERR_MSG_FMT = "ERROR: unable to calloc string of size %zu.\\n"}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed calloc error message. }}\par
{
Definition at line {\b 6} of file {\b errors.c}.}\par
}
{\xe \v FOPEN_FAILED_ERR_MSG_FMT\:errors.c}
{\xe \v errors.c\:FOPEN_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* FOPEN_FAILED_ERR_MSG_FMT = "ERROR: unable to open output file, %s\\n."}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }}\par
{
Definition at line {\b 8} of file {\b errors.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
errors.c\par \pard\plain 
{\tc\tcl2 \v src/errors.c}
{\xe \v src/errors.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "errors.h"}\par
00002 \par
00003 {\cf21 #include <stdbool.h>}\par
00004 {\cf21 #include <stdlib.h>}\par
00005 \par
00006 {\cf17 const} {\cf18 char} *CALLOC_FAILED_ERR_MSG_FMT\par
00007     = {\cf22 "ERROR: unable to calloc string of size %zu.\\n"};\par
00008 {\cf17 const} {\cf18 char} *FOPEN_FAILED_ERR_MSG_FMT\par
00009     = {\cf22 "ERROR: unable to open output file, %s\\n."};\par
00010 \par
00011 {\cf18 void}\par
00012 improper_usage_error ({\cf18 void})\par
00013 \{\par
00014   {\cf18 bool} windows;\par
00015 {\cf21 #ifdef __WIN32}\par
00016   windows = {\cf17 true};\par
00017 {\cf21 #else}\par
00018   windows = {\cf17 false};\par
00019 {\cf21 #endif}\par
00020   puts ({\cf22 "ERROR: Improper usage!"});\par
00021   printf ({\cf22 "try: %s HARVEST.DAT\\n"},\par
00022           !windows ? {\cf22 "$ ./HarvesterHarvester"} : {\cf22 "HarvesterHarvester.exe"});\par
00023 \par
00024   exit (1);\par
00025 \}\par
00026 \par
00027 {\cf18 void}\par
00028 fopen_error ({\cf18 char} *filename)\par
00029 \{\par
00030   printf ({\cf22 "ERROR: Unable to open file, %s.\\n"}, filename);\par
00031 \}\par
00032 \par
00033 HH_ERRORS\par
00034 handle_fread_error ({\cf18 size_t} actual, {\cf18 size_t} expected_bytes)\par
00035 \{\par
00036   printf ({\cf22 "ERROR: Only read %zu byte(s), expected %zu.\\n"}, actual,\par
00037           expected_bytes);\par
00038   {\cf19 return} HH_FREAD_ERROR;\par
00039 \}\par
00040 \par
00041 {\cf18 void}\par
00042 handle_unknown_command_line_argument_error ({\cf18 char} *arg)\par
00043 \{\par
00044   {\cf18 bool} windows;\par
00045 {\cf21 #ifdef __WIN32}\par
00046   windows = {\cf17 true};\par
00047 {\cf21 #else}\par
00048   windows = {\cf17 false};\par
00049 {\cf21 #endif}\par
00050   printf ({\cf22 "ERROR: unknown command-line argument, %s.\\n"}, arg);\par
00051   printf ({\cf22 "Run %s --help for a list of command-line arguments.\\n"},\par
00052           !windows ? {\cf22 "./HarvesterHarvester"} : {\cf22 "HarvesterHarvester.exe"});\par
00053   exit (1);\par
00054 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/errors.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/errors.h}
{\xe \v src/errors.h}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b HH_ERRORS} \{ {\b HH_FOPEN_ERROR} = -1
, {\b HH_FREAD_ERROR} = -2
, {\b HH_PT_RESIZE_ERROR} = -3
, {\b HH_MEM_ALLOC_ERROR} = -4
, {\b HH_CREATE_OUTPUT_DIR_ERROR} = -5
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b errors.h} - a wrapper for all of hh's potential errors. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b improper_usage_error} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an improper usage error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fopen_error} (char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HH_ERRORS} {\b handle_fread_error} (size_t actual, size_t expected_bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_unknown_command_line_argument_error} (char *arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CALLOC_FAILED_ERR_MSG_FMT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed calloc error message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b FOPEN_FAILED_ERR_MSG_FMT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v HH_ERRORS\:errors.h}
{\xe \v errors.h\:HH_ERRORS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b HH_ERRORS}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b errors.h} - a wrapper for all of hh's potential errors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An enum containing all the possible errors hh could throw. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v HH_FOPEN_ERROR\:errors.h}
{\xe \v errors.h\:HH_FOPEN_ERROR}
{\qr HH_FOPEN_ERROR{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\cell }{\cell }{\row }
{\xe \v HH_FREAD_ERROR\:errors.h}
{\xe \v errors.h\:HH_FREAD_ERROR}
{\qr HH_FREAD_ERROR{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{\cell }{\row }
{\xe \v HH_PT_RESIZE_ERROR\:errors.h}
{\xe \v errors.h\:HH_PT_RESIZE_ERROR}
{\qr HH_PT_RESIZE_ERROR{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Path table resize error. \par
}\cell }{\row }
{\xe \v HH_MEM_ALLOC_ERROR\:errors.h}
{\xe \v errors.h\:HH_MEM_ALLOC_ERROR}
{\qr HH_MEM_ALLOC_ERROR{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v HH_CREATE_OUTPUT_DIR_ERROR\:errors.h}
{\xe \v errors.h\:HH_CREATE_OUTPUT_DIR_ERROR}
{\qr HH_CREATE_OUTPUT_DIR_ERROR{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 22} of file {\b errors.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fopen_error\:errors.h}
{\xe \v errors.h\:fopen_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fopen_error (char * filename)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fopen error. }}\par
{
Definition at line {\b 28} of file {\b errors.c}.}\par
}
{\xe \v handle_fread_error\:errors.h}
{\xe \v errors.h\:handle_fread_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HH_ERRORS} handle_fread_error (size_t actual, size_t expected_bytes)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an fread error. }}\par
{
Definition at line {\b 34} of file {\b errors.c}.}\par
}
{\xe \v handle_unknown_command_line_argument_error\:errors.h}
{\xe \v errors.h\:handle_unknown_command_line_argument_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_unknown_command_line_argument_error (char * arg)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an unknown command line argument error. }}\par
{
Definition at line {\b 42} of file {\b errors.c}.}\par
}
{\xe \v improper_usage_error\:errors.h}
{\xe \v errors.h\:improper_usage_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void improper_usage_error (void )}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws an improper usage error. }}\par
{
Definition at line {\b 12} of file {\b errors.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CALLOC_FAILED_ERR_MSG_FMT\:errors.h}
{\xe \v errors.h\:CALLOC_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CALLOC_FAILED_ERR_MSG_FMT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed calloc error message. }}\par
{
Definition at line {\b 6} of file {\b errors.c}.}\par
}
{\xe \v FOPEN_FAILED_ERR_MSG_FMT\:errors.h}
{\xe \v errors.h\:FOPEN_FAILED_ERR_MSG_FMT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* FOPEN_FAILED_ERR_MSG_FMT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Format string for failed fopen error message. }}\par
{
Definition at line {\b 8} of file {\b errors.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
errors.h\par \pard\plain 
{\tc\tcl2 \v src/errors.h}
{\xe \v src/errors.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_ERRORS_H_}\par
00016 {\cf21 #define _HH_ERRORS_H_}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <stdio.h>}\par
00020 \par
00022 {\cf17 typedef} {\cf17 enum} HH_ERRORS\par
00023 \{\par
00024   HH_FOPEN_ERROR = -1,\par
00025   HH_FREAD_ERROR = -2,\par
00027   HH_PT_RESIZE_ERROR = -3,\par
00028   HH_MEM_ALLOC_ERROR = -4,\par
00029   HH_CREATE_OUTPUT_DIR_ERROR = -5\par
00030 \} HH_ERRORS;\par
00031 \par
00033 {\cf17 extern} {\cf17 const} {\cf18 char} *CALLOC_FAILED_ERR_MSG_FMT;\par
00034 \par
00036 {\cf17 extern} {\cf17 const} {\cf18 char} *FOPEN_FAILED_ERR_MSG_FMT;\par
00037 \par
00039 {\cf18 void} improper_usage_error ({\cf18 void});\par
00040 \par
00042 {\cf18 void} fopen_error ({\cf18 char} *filename);\par
00043 \par
00045 HH_ERRORS handle_fread_error ({\cf18 size_t} actual, {\cf18 size_t} expected_bytes);\par
00046 \par
00048 {\cf18 void} handle_unknown_command_line_argument_error ({\cf18 char} *arg);\par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/extractor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "extractor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "output.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file} (FILE *fptr, {\b directory_record} *dr, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_directory} (FILE *fptr, const uint16_t block_size, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directories_and_extract_data_from_path_file} (FILE *fptr, uint16_t block_size, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_directories_and_extract_data_from_path_file\:extractor.c}
{\xe \v extractor.c\:create_directories_and_extract_data_from_path_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directories_and_extract_data_from_path_file (FILE * fptr, uint16_t block_size, struct {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper for {\f2 extract_directory}  and, therefore also, {\f2 extract_file}  which handles the extraction of every file and subdirectory using a given path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i block_size} \cell }{logical block size (in big endian form). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b extract_directory()} \par
{\b extract_file()} \par
}}}{
Definition at line {\b 127} of file {\b extractor.c}.}\par
}
{\xe \v extract_directory\:extractor.c}
{\xe \v extractor.c\:extract_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_directory (FILE * fptr, const uint16_t block_size, const char * path)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }}\par
{
Definition at line {\b 89} of file {\b extractor.c}.}\par
}
{\xe \v extract_file\:extractor.c}
{\xe \v extractor.c\:extract_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file (FILE * fptr, struct {\b directory_record} * dr, const char * path)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions return zero on success, non-zero on failure. Extracts a file using its respective {\f2 {\b directory_record}}  and data pointed to by {\f2 fptr} , outputting it to the location denoted by {\f2 path} . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 file_identifier}  terminates with a {\f2 ;}  character followed by the file ID number in ASCII coded decimal ({\f2 1} ). See: {\f2 https://wiki.osdev.org/ISO_9660#Directories}\par
Just use the default/existing filename. It'll be incorrect, but probably not worth stoping execution over. Users could just manually remove the {\f2 ;1}  part; the data itself should be fine.\par
}{
Definition at line {\b 26} of file {\b extractor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
extractor.c\par \pard\plain 
{\tc\tcl2 \v src/extractor.c}
{\xe \v src/extractor.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "extractor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "options.h"}\par
00018 {\cf21 #include "output.h"}\par
00019 {\cf21 #include "utils.h"}\par
00020 \par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <stdio.h>}\par
00023 {\cf21 #include <string.h>}\par
00024 \par
00025 int8_t\par
00026 extract_file (FILE *fptr, directory_record *dr, {\cf17 const} {\cf18 char} *path)\par
00027 \{\par
00033   {\cf18 char} *actual_filename = strtok (dr->file_identifier, ({\cf17 const} {\cf18 char} *){\cf22 ";"});\par
00034   {\cf19 if} (actual_filename == NULL)\par
00035     \{\par
00042       actual_filename = dr->file_identifier;\par
00043     \}\par
00044 \par
00045   printf ({\cf22 "Extracting file: %s\\n"}, actual_filename);\par
00046 \par
00047   {\cf20 // +1 for the null terminator, +1 for `/` between dir and filename}\par
00048   {\cf18 size_t} filename_length = strlen (path) + strlen (actual_filename) + 2;\par
00049 \par
00050   {\cf18 char} *output_filename = ({\cf18 char} *)calloc (filename_length, {\cf17 sizeof} ({\cf18 char}));\par
00051   {\cf19 if} (output_filename == NULL)\par
00052     \{\par
00053       fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT, filename_length);\par
00054       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00055     \}\par
00056 \par
00057   strcpy (output_filename, path);\par
00058   strcat (output_filename, &OP_PATH_SEPARATOR);\par
00059   strcat (output_filename, actual_filename);\par
00060 \par
00061   FILE *output_file = fopen (output_filename, {\cf22 "wb"});\par
00062   {\cf19 if} (output_file == NULL)\par
00063     \{\par
00064       fprintf (stderr, FOPEN_FAILED_ERR_MSG_FMT, output_filename);\par
00065       free (output_filename);\par
00066       {\cf19 return} HH_FOPEN_ERROR;\par
00067     \}\par
00068 \par
00069   {\cf20 // `j` must be in hex, otherwise `data_length` can be treated as an int value}\par
00070   {\cf19 for} (uint32_t j = 0x0; j < dr->data_length; j++)\par
00071     \{\par
00072       uint8_t byte;\par
00073       {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00074         \{\par
00075           fclose (output_file);\par
00076           free (output_filename);\par
00077           {\cf19 return} HH_FREAD_ERROR;\par
00078         \}\par
00079 \par
00080       fwrite (&{\cf18 byte}, {\cf17 sizeof} (uint8_t), 1, output_file);\par
00081     \}\par
00082 \par
00083   fclose (output_file);\par
00084   free (output_filename);\par
00085   {\cf19 return} 0;\par
00086 \}\par
00087 \par
00088 int8_t\par
00089 extract_directory (FILE *fptr, {\cf17 const} uint16_t block_size, {\cf17 const} {\cf18 char} *path)\par
00090 \{\par
00091   directory dir;\par
00092   create_directory (&dir);\par
00093   process_directory (fptr, &dir);\par
00094 \par
00095   printf ({\cf22 "Extracting directory: %s\\n"}, path);\par
00096 \par
00097   {\cf19 for} ({\cf18 size_t} i = 0x0; i < dir.current_record; i++)\par
00098     \{\par
00099       directory_record curr_file = dir.records[i];\par
00100 \par
00101       {\cf19 if} (curr_file.file_flags.subdirectory)\par
00102         \{\par
00103           {\cf19 continue};\par
00104         \}\par
00105       {\cf19 else} {\cf19 if} (OP_DEBUG_MODE\par
00106                && curr_file.data_length > OP_DEBUG_FILE_SIZE_LIMIT)\par
00107         \{\par
00108           printf ({\cf22 "[DEBUG_MODE] Skipping file, %s.\\n"},\par
00109                   curr_file.file_identifier);\par
00110           {\cf19 continue};\par
00111         \}\par
00112 \par
00113       fseek (fptr, curr_file.location_of_extent * block_size, SEEK_SET);\par
00114 \par
00115       {\cf19 if} (extract_file (fptr, &curr_file, path) != 0)\par
00116         \{\par
00117           destroy_directory (&dir);\par
00118           {\cf19 return} -1;\par
00119         \}\par
00120     \}\par
00121 \par
00122   destroy_directory (&dir);\par
00123   {\cf19 return} 0;\par
00124 \}\par
00125 \par
00126 int8_t\par
00127 create_directories_and_extract_data_from_path_file (FILE *fptr,\par
00128                                                     uint16_t block_size,\par
00129                                                     path_table *pt)\par
00130 \{\par
00131   {\cf19 for} ({\cf18 size_t} i = pt->current_entry - 1; i > 0; --i)\par
00132     \{\par
00133       path_table_entry curr_dir = pt->entries[i];\par
00134       path_table_entry target_dir = curr_dir;\par
00135 \par
00136       {\cf20 // supports 10 levels of directories which is probably overkill.}\par
00137       {\cf17 const} uint32_t PATH_MAX_LEN\par
00138           = ((curr_dir.directory_identifier_length + 1) * 10)\par
00139             + (strlen (OP_OUTPUT_DIR) + 1) + (strlen (CURRENT_DISK_NAME) + 1)\par
00140             + 1;\par
00141       {\cf18 char} *path = calloc (PATH_MAX_LEN, {\cf17 sizeof} ({\cf18 char}));\par
00142       {\cf19 if} (path == NULL)\par
00143         \{\par
00144           fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT, PATH_MAX_LEN);\par
00145           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00146         \}\par
00147 \par
00148       strcat (path, curr_dir.directory_identifier);\par
00149 \par
00150       {\cf19 do}\par
00151         \{\par
00152           uint16_t index\par
00153               = change_endianness_uint16 (curr_dir.parent_directory_number);\par
00154 \par
00155           {\cf20 // parent_directory_number is 1-based}\par
00156           curr_dir = pt->entries[index - 1];\par
00157 \par
00158           {\cf19 if} (prepend_path_string (path,\par
00159                                    ({\cf17 const} {\cf18 char} *)curr_dir.directory_identifier)\par
00160               != 0)\par
00161             \{\par
00162               free (path);\par
00163               {\cf19 return} -1;\par
00164             \}\par
00165         \}\par
00166       {\cf19 while} (curr_dir.parent_directory_number > 0x0100);\par
00167 \par
00168       {\cf19 if} (create_output_directory (path) != 0)\par
00169         {\cf19 return} -1;\par
00170 \par
00171       fseek (fptr, block_size * target_dir.location_of_extent, SEEK_SET);\par
00172 \par
00173       {\cf19 if} (extract_directory (fptr, block_size, path) != 0)\par
00174         {\cf19 return} -1;\par
00175 \par
00176       free (path);\par
00177     \}\par
00178 \par
00179   {\cf19 return} 0;\par
00180 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/extractor.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/extractor.h}
{\xe \v src/extractor.h}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "directory.h"}\par
{\f2 #include "path_table.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_file} (FILE *fptr, struct {\b directory_record} *dr, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b extract_directory} (FILE *fptr, const uint16_t block_size, const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_directories_and_extract_data_from_path_file} (FILE *fptr, uint16_t block_size, struct {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_directories_and_extract_data_from_path_file\:extractor.h}
{\xe \v extractor.h\:create_directories_and_extract_data_from_path_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_directories_and_extract_data_from_path_file (FILE * fptr, uint16_t block_size, struct {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates directories for every directory in a given path table and then extracts all of its files. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper for {\f2 extract_directory}  and, therefore also, {\f2 extract_file}  which handles the extraction of every file and subdirectory using a given path table.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i block_size} \cell }{logical block size (in big endian form). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b extract_directory()} \par
{\b extract_file()} \par
}}}{
Definition at line {\b 127} of file {\b extractor.c}.}\par
}
{\xe \v extract_directory\:extractor.h}
{\xe \v extractor.h\:extract_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_directory (FILE * fptr, const uint16_t block_size, const char * path)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a directory and then extracts every file in said directory. }}\par
{
Definition at line {\b 89} of file {\b extractor.c}.}\par
}
{\xe \v extract_file\:extractor.h}
{\xe \v extractor.h\:extract_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t extract_file (FILE * fptr, struct {\b directory_record} * dr, const char * path)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b extractor.h} - container for all file extraction functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions return zero on success, non-zero on failure. Extracts a file using its respective {\f2 {\b directory_record}}  and data pointed to by {\f2 fptr} , outputting it to the location denoted by {\f2 path} . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 file_identifier}  terminates with a {\f2 ;}  character followed by the file ID number in ASCII coded decimal ({\f2 1} ). See: {\f2 https://wiki.osdev.org/ISO_9660#Directories}\par
Just use the default/existing filename. It'll be incorrect, but probably not worth stoping execution over. Users could just manually remove the {\f2 ;1}  part; the data itself should be fine.\par
}{
Definition at line {\b 26} of file {\b extractor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
extractor.h\par \pard\plain 
{\tc\tcl2 \v src/extractor.h}
{\xe \v src/extractor.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00019 {\cf21 #ifndef _HH_EXTRACTOR_H_}\par
00020 {\cf21 #define _HH_EXTRACTOR_H_}\par
00021 \par
00022 {\cf21 #include "directory.h"}\par
00023 {\cf21 #include "path_table.h"}\par
00024 \par
00025 {\cf21 #include <stdint.h>}\par
00026 {\cf21 #include <stdio.h>}\par
00027 \par
00032 int8_t extract_file (FILE *fptr, {\cf17 struct} directory_record *dr,\par
00033                      {\cf17 const} {\cf18 char} *path);\par
00034 \par
00036 int8_t extract_directory (FILE *fptr, {\cf17 const} uint16_t block_size,\par
00037                           {\cf17 const} {\cf18 char} *path);\par
00038 \par
00049 int8_t create_directories_and_extract_data_from_path_file (\par
00050     FILE *fptr, uint16_t block_size, {\cf17 struct} path_table *pt);\par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_flags.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "file_flags.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b create_file_flags} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_file_flags} ({\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_file_flags\:file_flags.c}
{\xe \v file_flags.c\:create_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} create_file_flags (void )}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }}\par
{
Definition at line {\b 19} of file {\b file_flags.c}.}\par
}
{\xe \v print_file_flags\:file_flags.c}
{\xe \v file_flags.c\:print_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_file_flags ({\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }}\par
{
Definition at line {\b 31} of file {\b file_flags.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags.c\par \pard\plain 
{\tc\tcl2 \v src/file_flags.c}
{\xe \v src/file_flags.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "file_flags.h"}\par
00015 \par
00016 {\cf21 #include <stdio.h>}\par
00017 \par
00018 file_flags\par
00019 create_file_flags ({\cf18 void})\par
00020 \{\par
00021   file_flags ff;\par
00022   ff.hidden = {\cf17 false};\par
00023   ff.subdirectory = {\cf17 false};\par
00024   ff.associated_file = {\cf17 false};\par
00025   ff.extended_attribute_record_contains_owner_and_group_permissions = {\cf17 false};\par
00026   ff.final_directory_record = {\cf17 false};\par
00027   {\cf19 return} ff;\par
00028 \}\par
00029 \par
00030 {\cf18 void}\par
00031 print_file_flags (file_flags *ff)\par
00032 \{\par
00033   printf ({\cf22 "\\tHidden: %d\\n"}, ff->hidden);\par
00034   printf ({\cf22 "\\tSubdirectory: %d\\n"}, ff->subdirectory);\par
00035   printf ({\cf22 "\\tAssociated file: %d\\n"}, ff->associated_file);\par
00036   printf (\par
00037       {\cf22 "\\tExtended attrib. record contains owner and group permissions: %d\\n"},\par
00038       ff->extended_attribute_record_contains_owner_and_group_permissions);\par
00039   printf ({\cf22 "\\tFinal directory record: %d\\n"}, ff->final_directory_record);\par
00040 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_flags.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_flags.h}
{\xe \v src/file_flags.h}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b file_flags}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b file_flags.h} - {\b file_flags} data type and its associated functions. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_flags} {\b create_file_flags} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_file_flags} ({\b file_flags} *ff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_file_flags\:file_flags.h}
{\xe \v file_flags.h\:create_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_flags} create_file_flags (void )}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\f2 {\b file_flags}} , initializing all values to false. }}\par
{
Definition at line {\b 19} of file {\b file_flags.c}.}\par
}
{\xe \v print_file_flags\:file_flags.h}
{\xe \v file_flags.h\:print_file_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_file_flags ({\b file_flags} * ff)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given instance of {\f2 {\b file_flags}}  to stdout in a human-readable form. }}\par
{
Definition at line {\b 31} of file {\b file_flags.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
file_flags.h\par \pard\plain 
{\tc\tcl2 \v src/file_flags.h}
{\xe \v src/file_flags.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_FILE_FLAGS_H_}\par
00016 {\cf21 #define _HH_FILE_FLAGS_H_}\par
00017 \par
00018 {\cf21 #include <stdbool.h>}\par
00019 {\cf21 #include <stdint.h>}\par
00020 \par
00027 {\cf17 typedef} {\cf17 struct }file_flags\par
00028 \{\par
00029   {\cf18 bool} hidden;\par
00030   {\cf18 bool} subdirectory;\par
00031   {\cf18 bool} associated_file; \par
00032   {\cf18 bool} extended_attribute_record_contains_owner_and_group_permissions;\par
00037   {\cf18 bool} final_directory_record;\par
00038 \} file_flags;\par
00039 \par
00041 file_flags create_file_flags ({\cf18 void});\par
00042 \par
00047 {\cf18 void} print_file_flags (file_flags *ff);\par
00048 \par
00049 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/hh.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "hh.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "extractor.h"}\par
{\f2 #include "index_file.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "path_table.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include "volume_descriptor.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b setup_extractor} (FILE **fptr, char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_DAT_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b batch_process_DAT_files} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_new_dat_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v batch_process_DAT_files\:hh.c}
{\xe \v hh.c\:batch_process_DAT_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t batch_process_DAT_files (void )}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 180} of file {\b hh.c}.}\par
}
{\xe \v main\:hh.c}
{\xe \v hh.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b hh.c}.}\par
}
{\xe \v process_DAT_file\:hh.c}
{\xe \v hh.c\:process_DAT_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_DAT_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is accomplished by first processing the volume descriptor header (checking that this is indeed a primary volume descriptor after it does so) and the volume descriptor data. Once complete, it updates the {\f2 CURRENT_DISK_NAME}  variable using the appropriate data. Finally, it constructs a path table, a extracts every file from the given DAT file to the {\f2 OP_OUTPUT_DIR} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to a DAT file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660} \par
{\b process_volume_descriptor_header()} \par
{\b process_volume_descriptor_data()} \par
{\b create_path_table()} \par
{\b process_type_l_path_table()} \par
{\b extract_directory()} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 95} of file {\b hh.c}.}\par
}
{\xe \v process_new_dat_files\:hh.c}
{\xe \v hh.c\:process_new_dat_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_new_dat_files (void )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These {\f2 .DAT}  files are not ISO 9660 file systems, rather they're some proprietary format. These files can be processed by reading the associated {\f2 INDEX.00#}  file, which contains all the filenames, paths, and location of data for files stored in these new {\f2 .DAT}  files. For those curious, this is why adding {\f2 HARVEST2.DAT}  is unnecessary and therefore not mentioned in the README.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int8_t zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 306} of file {\b hh.c}.}\par
}
{\xe \v setup_extractor\:hh.c}
{\xe \v hh.c\:setup_extractor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t setup_extractor (FILE ** fptr, char * filename)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\f2 FILE *}  for the given {\f2 filename} , handling error messages as needed, while also checking the end-user's operating system and updating {\f2 OP_PATH_SEPARATOR} . The caller is responsible for closing the file pointer when they're finished with it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to the file associated with the given filename \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{the path to a DAT file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 76} of file {\b hh.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hh.c\par \pard\plain 
{\tc\tcl2 \v src/hh.c}
{\xe \v src/hh.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "hh.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "extractor.h"}\par
00017 {\cf21 #include "index_file.h"}\par
00018 {\cf21 #include "options.h"}\par
00019 {\cf21 #include "path_table.h"}\par
00020 {\cf21 #include "utils.h"}\par
00021 {\cf21 #include "volume_descriptor.h"}\par
00022 \par
00023 {\cf21 #include <stdbool.h>}\par
00024 {\cf21 #include <stdint.h>}\par
00025 {\cf21 #include <stdio.h>}\par
00026 {\cf21 #include <stdlib.h>}\par
00027 {\cf21 #include <string.h>}\par
00028 \par
00029 {\cf21 #ifdef _WIN32}\par
00030 {\cf21 #include <windows.h>}\par
00031 {\cf21 #else}\par
00032 {\cf21 #include <dirent.h>}\par
00033 {\cf21 #endif}\par
00034 \par
00035 {\cf18 int}\par
00036 main ({\cf18 int} argc, {\cf18 char} **argv)\par
00037 \{\par
00038   FILE *fptr = NULL;\par
00039 \par
00040   {\cf19 if} (argc >= 2)\par
00041     handle_command_line_args (argc, argv);\par
00042 \par
00043   {\cf19 if} (OP_BATCH_PROCESS && !OP_SKIP_DAT_PROCESSING)\par
00044     \{\par
00045       {\cf19 if} (batch_process_DAT_files () != 0)\par
00046         exit (1);\par
00047     \}\par
00048   {\cf19 else} {\cf19 if} (!OP_SKIP_DAT_PROCESSING)\par
00049     \{\par
00050       {\cf19 if} (setup_extractor (&fptr, argv[argc - 1]) != 0)\par
00051         exit (1);\par
00052 \par
00053       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00054         exit (1);\par
00055 \par
00056       fclose (fptr);\par
00057     \}\par
00058 \par
00059   {\cf20 /*}\par
00060 {\cf20    * TODO: Next steps:}\par
00061 {\cf20    * [] navigate to each output dir ("DISK1", "DISK2", etc.)}\par
00062 {\cf20    *    [] Path is just `output/DISK#/`}\par
00063 {\cf20    * [] load the *.IDX file and use it to read the *.DAT files.}\par
00064 {\cf20    * [] extract files from those new *.DAT files into the directory they're}\par
00065 {\cf20    *    already in.}\par
00066 {\cf20    */}\par
00067   {\cf19 if} (process_new_dat_files () != 0)\par
00068     \{\par
00069       exit (1);\par
00070     \}\par
00071 \par
00072   {\cf19 return} 0;\par
00073 \}\par
00074 \par
00075 int8_t\par
00076 setup_extractor (FILE **fptr, {\cf18 char} *filename)\par
00077 \{\par
00078   *fptr = fopen (filename, {\cf22 "rb"});\par
00079   {\cf19 if} (*fptr == NULL)\par
00080     \{\par
00081       fopen_error (filename);\par
00082       {\cf19 return} HH_FOPEN_ERROR;\par
00083     \}\par
00084 \par
00085 {\cf21 #ifdef _WIN32}\par
00086   OP_PATH_SEPARATOR = {\cf23 '\\\\'};\par
00087 {\cf21 #else}\par
00088   OP_PATH_SEPARATOR = {\cf23 '/'};\par
00089 {\cf21 #endif}\par
00090 \par
00091   {\cf19 return} 0;\par
00092 \}\par
00093 \par
00094 int8_t\par
00095 process_DAT_file (FILE *fptr)\par
00096 \{\par
00097   {\cf20 /*}\par
00098 {\cf20    * First 32k (up to 0x8000) stores the `system area` of the disk.}\par
00099 {\cf20    * Unused by HARVEST.DAT, HARVEST3.DAT, HARVEST4.DAT.}\par
00100 {\cf20    * See: https://wiki.osdev.org/ISO_9660#System_Area}\par
00101 {\cf20    */}\par
00102   fseek (fptr, 0x8000, SEEK_SET);\par
00103 \par
00104   volume_descriptor vd;\par
00105   {\cf19 if} (process_volume_descriptor_header (fptr, &vd) != 0)\par
00106     {\cf19 return} -1;\par
00107 \par
00108   {\cf20 // Verify that this is a primary volume descriptor}\par
00109   {\cf19 if} (vd.type_code != 0x01)\par
00110     \{\par
00111       puts ({\cf22 "Error: Unexpected volume descriptor type code."});\par
00112       printf ({\cf22 "\\tExpected %02x, got %02x.\\n"}, 0x01, vd.type_code);\par
00113       {\cf19 return} -1;\par
00114     \}\par
00115 \par
00116   {\cf19 if} (process_volume_descriptor_data (fptr, &vd.data) != 0)\par
00117     {\cf19 return} -1;\par
00118 \par
00119   {\cf18 size_t} current_disk_name_length = strcspn (vd.data.volume_identifier, {\cf22 " "});\par
00120   CURRENT_DISK_NAME = vd.data.volume_identifier;\par
00121   CURRENT_DISK_NAME[current_disk_name_length] = {\cf23 '\\0'};\par
00122 \par
00123   {\cf20 // TODO: print the volume descriptor header/data to some file/log.}\par
00124 \par
00125   {\cf20 // logical block size, in big endian form}\par
00126   {\cf17 const} uint16_t block_size_be\par
00127       = change_endianness_uint16 (vd.data.logical_block_size);\par
00128 \par
00129   {\cf20 // move to beginning of type-l path table}\par
00130   fseek (fptr, block_size_be * vd.data.type_l_path_table_location, SEEK_SET);\par
00131 \par
00132   path_table pt;\par
00133   {\cf19 if} (create_path_table (&pt) != 0)\par
00134     {\cf19 return} -1;\par
00135 \par
00136   {\cf19 if} (process_type_l_path_table (fptr, &pt) != 0)\par
00137     \{\par
00138       destroy_path_table (&pt);\par
00139       {\cf19 return} -1;\par
00140     \}\par
00141 \par
00142   {\cf19 if} (create_directories_and_extract_data_from_path_file (fptr, block_size_be,\par
00143                                                           &pt)\par
00144       != 0)\par
00145     \{\par
00146       destroy_path_table (&pt);\par
00147       {\cf19 return} -1;\par
00148     \}\par
00149 \par
00150   {\cf20 // handle root directory}\par
00151   fseek (fptr, block_size_be * pt.entries[0].location_of_extent, SEEK_SET);\par
00152 \par
00153   {\cf18 char} *path = calloc (strlen (OP_OUTPUT_DIR) + current_disk_name_length + 2,\par
00154                        {\cf17 sizeof} ({\cf18 char}));\par
00155   {\cf19 if} (path == NULL)\par
00156     \{\par
00157       fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT,\par
00158                strlen (OP_OUTPUT_DIR) + current_disk_name_length + 2);\par
00159       destroy_path_table (&pt);\par
00160       {\cf19 return} -1;\par
00161     \}\par
00162 \par
00163   strcpy (path, OP_OUTPUT_DIR);\par
00164   strcat (path, {\cf22 "/"});\par
00165   strcat (path, CURRENT_DISK_NAME);\par
00166 \par
00167   {\cf19 if} (extract_directory (fptr, block_size_be, path) != 0)\par
00168     \{\par
00169       free (path);\par
00170       destroy_path_table (&pt);\par
00171       {\cf19 return} -1;\par
00172     \}\par
00173 \par
00174   free (path);\par
00175   destroy_path_table (&pt);\par
00176   {\cf19 return} 0;\par
00177 \}\par
00178 \par
00179 int8_t\par
00180 batch_process_DAT_files ()\par
00181 \{\par
00182   {\cf17 const} {\cf18 char} *OPEN_INPUT_DIR_ERR_MSG_FMT\par
00183       = {\cf22 "ERROR: Error opening input directory, %s.\\n"};\par
00184   {\cf17 const} uint8_t DAT_FILENAME_LEN = strlen ({\cf22 "HARVESTX.DAT"});\par
00185   {\cf18 char} *filename;\par
00186 \par
00187 {\cf21 #ifdef _WIN32}\par
00188   WIN32_FIND_DATAA file_data;\par
00189   HANDLE hFind;\par
00190   {\cf18 char} search_path[256];\par
00191   strcpy (search_path, OP_INPUT_DIR);\par
00192   strcat (search_path, {\cf22 "\\\\*"});\par
00193 \par
00194   hFind = FindFirstFileA (search_path, &file_data);\par
00195   {\cf19 if} (hFind == INVALID_HANDLE_VALUE)\par
00196     \{\par
00197       fprintf (stderr, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00198       {\cf19 return} -1;\par
00199     \}\par
00200 \par
00201   {\cf19 do}\par
00202     \{\par
00203       {\cf19 if} (strcmp (file_data.cFileName, {\cf22 "."}) == 0\par
00204           || strcmp (file_data.cFileName, {\cf22 ".."}) == 0\par
00205           || !is_string_dat_file (file_data.cFileName))\par
00206         \{\par
00207           {\cf19 continue};\par
00208         \}\par
00209 \par
00210       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00211                          {\cf17 sizeof} ({\cf18 char}));\par
00212       {\cf19 if} (filename == NULL)\par
00213         \{\par
00214           fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT,\par
00215                    strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2);\par
00216           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00217         \}\par
00218 \par
00219       strcpy (filename, OP_INPUT_DIR);\par
00220       strcat (filename, &OP_PATH_SEPARATOR);\par
00221       strcat (filename, file_data.cFileName);\par
00222 \par
00223       FILE *fptr = NULL;\par
00224       {\cf19 if} (setup_extractor (&fptr, filename) != 0)\par
00225         \{\par
00226           free (filename);\par
00227           FindClose (hFind);\par
00228           {\cf19 return} HH_FOPEN_ERROR;\par
00229         \}\par
00230 \par
00231       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00232         \{\par
00233           fclose (fptr);\par
00234           free (filename);\par
00235           FindClose (hFind);\par
00236           {\cf19 return} -1;\par
00237         \}\par
00238 \par
00239       fclose (fptr);\par
00240       free (filename);\par
00241     \}\par
00242   {\cf19 while} (FindNextFileA (hFind, &file_data) != 0);\par
00243 \par
00244   FindClose (hFind);\par
00245 {\cf21 #else}\par
00246   {\cf17 struct }dirent *entry;\par
00247   DIR *dir;\par
00248   dir = opendir (OP_INPUT_DIR);\par
00249   {\cf19 if} (dir == NULL)\par
00250     \{\par
00251       fprintf (stderr, OPEN_INPUT_DIR_ERR_MSG_FMT, OP_INPUT_DIR);\par
00252       {\cf19 return} -1;\par
00253     \}\par
00254 \par
00255   {\cf19 while} ((entry = readdir (dir)) != NULL)\par
00256     \{\par
00257       {\cf19 if} (strcmp (entry->d_name, {\cf22 "."}) == 0 || strcmp (entry->d_name, {\cf22 ".."}) == 0\par
00258           || !is_string_dat_file (entry->d_name))\par
00259         \{\par
00260           {\cf19 continue};\par
00261         \}\par
00262 \par
00263       filename = calloc (strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2,\par
00264                          {\cf17 sizeof} ({\cf18 char}));\par
00265       {\cf19 if} (filename == NULL)\par
00266         \{\par
00267           fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT,\par
00268                    strlen (OP_INPUT_DIR) + DAT_FILENAME_LEN + 2);\par
00269           {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00270         \}\par
00271 \par
00272       strcpy (filename, OP_INPUT_DIR);\par
00273       strcat (filename, &OP_PATH_SEPARATOR);\par
00274       strcat (filename, entry->d_name);\par
00275 \par
00276       FILE *fptr = NULL;\par
00277       {\cf19 if} (setup_extractor (&fptr, filename) != 0)\par
00278         \{\par
00279           free (filename);\par
00280           closedir (dir);\par
00281           {\cf19 return} HH_FOPEN_ERROR;\par
00282         \}\par
00283 \par
00284       {\cf19 if} (process_DAT_file (fptr) != 0)\par
00285         \{\par
00286           fclose (fptr);\par
00287           free (filename);\par
00288           closedir (dir);\par
00289           {\cf19 return} -1;\par
00290         \}\par
00291 \par
00292       fclose (fptr);\par
00293       free (filename);\par
00294     \}\par
00295 \par
00296   closedir (dir);\par
00297 {\cf21 #endif}\par
00298   {\cf19 return} 0;\par
00299 \}\par
00300 \par
00301 {\cf20 /*}\par
00302 {\cf20  *  We DO need a more flexible/non-hardcoded solution as we don't necessarily}\par
00303 {\cf20  *  know which DAT files the end user extracted in the first place.}\par
00304 {\cf20  */}\par
00305 int8_t\par
00306 process_new_dat_files ({\cf18 void})\par
00307 \{\par
00308   {\cf17 const} uint32_t file_path_len = 3 + strlen (OP_OUTPUT_DIR) + strlen ({\cf22 "DISK#"})\par
00309                                  + strlen ({\cf22 "HARVEST2.DAT"});\par
00310   {\cf18 char} *interior_dat_file_path = calloc (file_path_len, {\cf17 sizeof} ({\cf18 char}));\par
00311   {\cf19 if} (interior_dat_file_path == NULL)\par
00312     \{\par
00313       fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT, file_path_len);\par
00314       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00315     \}\par
00316 \par
00317   {\cf20 // for subdir in OP_OUTPUT_DIR}\par
00318   strcpy (interior_dat_file_path, OP_OUTPUT_DIR);\par
00319   strcat (interior_dat_file_path, &OP_PATH_SEPARATOR);\par
00320   strcat (interior_dat_file_path, {\cf22 "DISK1"}); {\cf20 // replace w/ subdir name}\par
00321   strcat (interior_dat_file_path, &OP_PATH_SEPARATOR);\par
00322   {\cf20 // probably need to figure out a  good solution for storing these filenames}\par
00323   {\cf20 // for the files that we are expecting.}\par
00324   strcat (interior_dat_file_path, {\cf22 "INDEX.001"});\par
00325 \par
00326   FILE *fptr = NULL;\par
00327   {\cf19 if} (setup_extractor (&fptr, interior_dat_file_path) != 0)\par
00328     \{\par
00329       free (interior_dat_file_path);\par
00330       {\cf19 return} HH_FOPEN_ERROR;\par
00331     \}\par
00332 \par
00333   index_file idx_file;\par
00334   {\cf19 if} (create_index_file (&idx_file) != 0)\par
00335     \{\par
00336       fclose (fptr);\par
00337       free (interior_dat_file_path);\par
00338       {\cf19 return} -1;\par
00339     \}\par
00340 \par
00341   {\cf19 if} (process_index_file (fptr, &idx_file) != 0)\par
00342     \{\par
00343       destroy_index_file (&idx_file);\par
00344       fclose (fptr);\par
00345       free (interior_dat_file_path);\par
00346       {\cf19 return} -1;\par
00347     \}\par
00348 \par
00349   destroy_index_file (&idx_file);\par
00350   fclose (fptr);\par
00351   free (interior_dat_file_path);\par
00352   {\cf19 return} 0;\par
00353 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/hh.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/hh.h}
{\xe \v src/hh.h}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b setup_extractor} (FILE **fptr, char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b process_DAT_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b batch_process_DAT_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b process_new_dat_files} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v batch_process_DAT_files\:hh.h}
{\xe \v hh.h\:batch_process_DAT_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t batch_process_DAT_files (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes all the {\f2 .DAT}  files found in {\f2 OP_INPUT_DIR} , one at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 180} of file {\b hh.c}.}\par
}
{\xe \v process_DAT_file\:hh.h}
{\xe \v hh.h\:process_DAT_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t process_DAT_file (FILE * fptr){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes a DAT file pointed to by the given {\f2 FILE *} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is accomplished by first processing the volume descriptor header (checking that this is indeed a primary volume descriptor after it does so) and the volume descriptor data. Once complete, it updates the {\f2 CURRENT_DISK_NAME}  variable using the appropriate data. Finally, it constructs a path table, a extracts every file from the given DAT file to the {\f2 OP_OUTPUT_DIR} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to a DAT file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://wiki.osdev.org/ISO_9660} \par
{\b process_volume_descriptor_header()} \par
{\b process_volume_descriptor_data()} \par
{\b create_path_table()} \par
{\b process_type_l_path_table()} \par
{\b extract_directory()} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 95} of file {\b hh.c}.}\par
}
{\xe \v process_new_dat_files\:hh.h}
{\xe \v hh.h\:process_new_dat_files}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t process_new_dat_files (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process all the new {\f2 .DAT}  files created by {\f2 process_DAT_file} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These {\f2 .DAT}  files are not ISO 9660 file systems, rather they're some proprietary format. These files can be processed by reading the associated {\f2 INDEX.00#}  file, which contains all the filenames, paths, and location of data for files stored in these new {\f2 .DAT}  files. For those curious, this is why adding {\f2 HARVEST2.DAT}  is unnecessary and therefore not mentioned in the README.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int8_t zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 306} of file {\b hh.c}.}\par
}
{\xe \v setup_extractor\:hh.h}
{\xe \v hh.h\:setup_extractor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int8_t setup_extractor (FILE ** fptr, char * filename){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b hh.h} - the main interface to interact with HarvesterHarvester }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\f2 FILE *}  for the given {\f2 filename} , handling error messages as needed, while also checking the end-user's operating system and updating {\f2 OP_PATH_SEPARATOR} . The caller is responsible for closing the file pointer when they're finished with it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fptr} \cell }{a file pointer to the file associated with the given filename \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{the path to a DAT file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 76} of file {\b hh.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hh.h\par \pard\plain 
{\tc\tcl2 \v src/hh.h}
{\xe \v src/hh.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00017 {\cf21 #ifndef _HARVESTER_HARVESTER_H_}\par
00018 {\cf21 #define _HARVESTER_HARVESTER_H_}\par
00019 \par
00020 {\cf21 #include <stdint.h>}\par
00021 {\cf21 #include <stdio.h>}\par
00022 \par
00033 {\cf17 static} int8_t setup_extractor (FILE **fptr, {\cf18 char} *filename);\par
00034 \par
00053 {\cf17 static} int8_t process_DAT_file (FILE *fptr);\par
00054 \par
00060 {\cf17 static} int8_t batch_process_DAT_files ({\cf18 void});\par
00061 \par
00073 {\cf17 static} int8_t process_new_dat_files ({\cf18 void});\par
00074 \par
00075 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/index_file.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "index_file.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_indicies} ({\b index_file} *idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 {\b index_file}} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b destroy_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_index_file} (FILE *fptr, {\b index_file} *idxf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_index_entry} ({\b index_entry} *idxe)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_entry_to_index_file} ({\b index_file} *file, {\b index_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_STARTING_NUM_INDICIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b IDX_RECORDS_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_index_file\:index_file.c}
{\xe \v index_file.c\:add_entry_to_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_index_file ({\b index_file} * file, {\b index_entry} * entry)}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 139} of file {\b index_file.c}.}\par
}
{\xe \v create_index_file\:index_file.c}
{\xe \v index_file.c\:create_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 33} of file {\b index_file.c}.}\par
}
{\xe \v destroy_index_file\:index_file.c}
{\xe \v index_file.c\:destroy_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t destroy_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 50} of file {\b index_file.c}.}\par
}
{\xe \v print_index_entry\:index_file.c}
{\xe \v index_file.c\:print_index_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_index_entry ({\b index_entry} * idxe)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }}\par
{
Definition at line {\b 129} of file {\b index_file.c}.}\par
}
{\xe \v process_index_file\:index_file.c}
{\xe \v index_file.c\:process_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_index_file (FILE * fptr, {\b index_file} * idxf)}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every entry is 0x94 bytes apart, the part we're most concerned about is the last 16 bytes. Currently treating unknown data in between as junk. If you have any idea what this data might be used for, please feel free to make changes.\par
}{
Definition at line {\b 57} of file {\b index_file.c}.}\par
}
{\xe \v resize_indicies\:index_file.c}
{\xe \v index_file.c\:resize_indicies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_indicies ({\b index_file} * idx){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grows a given {\f2 {\b index_file}} 's {\f2 entries}  attribute by {\f2 IDX_RECORDS_GROWTH_RATE} . }}\par
{
Definition at line {\b 155} of file {\b index_file.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDX_RECORDS_GROWTH_RATE\:index_file.c}
{\xe \v index_file.c\:IDX_RECORDS_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_RECORDS_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b index_file.c}.}\par
}
{\xe \v IDX_STARTING_NUM_INDICIES\:index_file.c}
{\xe \v index_file.c\:IDX_STARTING_NUM_INDICIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t IDX_STARTING_NUM_INDICIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b index_file.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file.c\par \pard\plain 
{\tc\tcl2 \v src/index_file.c}
{\xe \v src/index_file.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "index_file.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "options.h"}\par
00018 {\cf21 #include "utils.h"}\par
00019 \par
00020 {\cf21 #include <stdlib.h>}\par
00021 {\cf21 #include <string.h>}\par
00022 \par
00023 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_STARTING_NUM_INDICIES = 10;\par
00024 {\cf17 static} {\cf17 const} {\cf18 size_t} IDX_RECORDS_GROWTH_RATE = 2;\par
00025 \par
00030 {\cf17 static} int8_t resize_indicies (index_file *idx);\par
00031 \par
00032 int8_t\par
00033 create_index_file (index_file *i)\par
00034 \{\par
00035   i->indicies = malloc (IDX_STARTING_NUM_INDICIES * {\cf17 sizeof} (index_entry));\par
00036   {\cf19 if} (i->indicies == NULL)\par
00037     \{\par
00038       fprintf (stderr, {\cf22 "ERROR: unable to malloc array of %zu indicies."},\par
00039                IDX_STARTING_NUM_INDICIES * {\cf17 sizeof} (index_entry));\par
00040       {\cf19 return} -1;\par
00041     \}\par
00042 \par
00043   i->size = IDX_STARTING_NUM_INDICIES;\par
00044   i->current_index = 0;\par
00045 \par
00046   {\cf19 return} 0;\par
00047 \}\par
00048 \par
00049 int8_t\par
00050 destroy_index_file (index_file *i)\par
00051 \{\par
00052   free (i->indicies);\par
00053   {\cf19 return} 0;\par
00054 \}\par
00055 \par
00056 int8_t\par
00057 process_index_file (FILE *fptr, index_file *idxf)\par
00058 \{\par
00059   {\cf19 while} (!peek_eof (fptr))\par
00060     \{\par
00061       index_entry entry;\par
00062       entry.entry_start = ftell (fptr);\par
00063 \par
00064       fseek (fptr, 0x5, SEEK_CUR); {\cf20 // skip `XFLE#`}\par
00065 \par
00066       {\cf19 if} (!peek_char_is (fptr, {\cf23 ':'}))\par
00067         \{\par
00068           fprintf (stderr, {\cf22 "ERROR: Unexpected character in index file. "}\par
00069                            {\cf22 "Aborting processing.\\n"});\par
00070           {\cf19 return} -1;\par
00071         \}\par
00072 \par
00073       {\cf19 if} (read_string (fptr, entry.full_path, (uint8_t)FULL_PATH_MAX_LEN) != 0)\par
00074         {\cf19 return} HH_FREAD_ERROR;\par
00075 \par
00076       uint8_t len = strlen (entry.full_path);\par
00077       {\cf18 char} *last_word = entry.full_path;\par
00078       {\cf19 for} (uint8_t i = 0; i < len; i++)\par
00079         \{\par
00080           {\cf19 if} (entry.full_path[i] == {\cf23 '\\\\'})\par
00081             \{\par
00082               last_word = entry.full_path + i + 1;\par
00083               entry.full_path[i] = OP_PATH_SEPARATOR;\par
00084             \}\par
00085         \}\par
00086       strcpy (entry.filename, last_word);\par
00087 \par
00094       fseek (fptr, entry.entry_start + (0x94 - 0x10), SEEK_SET);\par
00095 \par
00096       {\cf20 /* clang-format off */}\par
00097       {\cf19 if} ((read_little_endian_data_uint32_t (fptr, &entry.file_start) != 0)\par
00098           || (read_little_endian_data_uint32_t (fptr, &entry.file_offset) != 0))\par
00099         \{\par
00100           {\cf19 return} HH_FREAD_ERROR;\par
00101         \}\par
00102       {\cf20 /* clang-format on */}\par
00103 \par
00104       fseek (fptr, 0x4, SEEK_CUR); {\cf20 // Skip zeros}\par
00105 \par
00106       {\cf20 // Very unnecessary, but we might as well double check our data}\par
00107       uint32_t value;\par
00108       {\cf19 if} (read_little_endian_data_uint32_t (fptr, &value) != 0)\par
00109         {\cf19 return} HH_FREAD_ERROR;\par
00110 \par
00111       {\cf19 if} (entry.file_offset != value)\par
00112         \{\par
00113           fprintf (stderr, {\cf22 "ERROR: Expected %08X, got %08X.\\n"},\par
00114                    entry.file_offset, value);\par
00115           {\cf19 return} -1;\par
00116         \}\par
00117 \par
00118       print_index_entry (&entry);\par
00119       {\cf19 if} (add_entry_to_index_file (idxf, &entry) != 0)\par
00120         \{\par
00121           {\cf19 return} -1;\par
00122         \}\par
00123     \}\par
00124 \par
00125   {\cf19 return} 0;\par
00126 \}\par
00127 \par
00128 {\cf18 void}\par
00129 print_index_entry (index_entry *idxe)\par
00130 \{\par
00131   printf ({\cf22 "Entry start: %08X\\n"}, idxe->entry_start);\par
00132   printf ({\cf22 "Full path: %s\\n"}, idxe->full_path);\par
00133   printf ({\cf22 "Filename: %s\\n"}, idxe->filename);\par
00134   printf ({\cf22 "File start: %08X\\n"}, idxe->file_start);\par
00135   printf ({\cf22 "File offset: %08X\\n"}, idxe->file_offset);\par
00136 \}\par
00137 \par
00138 int8_t\par
00139 add_entry_to_index_file (index_file *file, index_entry *entry)\par
00140 \{\par
00141   {\cf19 if} (file->current_index >= file->size)\par
00142     \{\par
00143       {\cf19 if} (resize_indicies (file) != 0)\par
00144         \{\par
00145           {\cf19 return} -1;\par
00146         \}\par
00147     \}\par
00148 \par
00149   file->indicies[file->current_index] = *entry;\par
00150   file->current_index++;\par
00151   {\cf19 return} 0;\par
00152 \}\par
00153 \par
00154 int8_t\par
00155 resize_indicies (index_file *idx)\par
00156 \{\par
00157   {\cf18 size_t} new_size = idx->size * IDX_RECORDS_GROWTH_RATE;\par
00158   index_entry *new_indicies = (index_entry *)realloc (\par
00159       idx->indicies, new_size * sizeof (index_entry));\par
00160   {\cf19 if} (new_indicies == NULL)\par
00161     \{\par
00162       fprintf (stderr, {\cf22 "ERROR: unable to ralloc index from size %zu to %zu.\\n"},\par
00163                idx->size, new_size);\par
00164       destroy_index_file (idx);\par
00165       {\cf19 return} -1;\par
00166     \}\par
00167 \par
00168   idx->indicies = new_indicies;\par
00169   idx->size = new_size;\par
00170   {\cf19 return} 0;\par
00171 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/index_file.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/index_file.h}
{\xe \v src/index_file.h}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_entry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entry of the associated {\f2 {\b index_file}} . }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_file}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the indicies within an {\f2 INDEX.00#}  file. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FULL_PATH_MAX_LEN}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b index_file.h} - {\b index_file} datatype and its associated functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILENAME_MAX_LEN}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b destroy_index_file} ({\b index_file} *i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_index_file} (FILE *fptr, {\b index_file} *idxf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_index_entry} ({\b index_entry} *idxe)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b add_entry_to_index_file} ({\b index_file} *file, {\b index_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILENAME_MAX_LEN\:index_file.h}
{\xe \v index_file.h\:FILENAME_MAX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILENAME_MAX_LEN\~ 32}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b index_file.h}.}\par
}
{\xe \v FULL_PATH_MAX_LEN\:index_file.h}
{\xe \v index_file.h\:FULL_PATH_MAX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FULL_PATH_MAX_LEN\~ 128}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b index_file.h} - {\b index_file} datatype and its associated functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for processing Harvester's {\f2 INDEX.00#}  files. \par
Both the {\b index_file} datatype and the functions contained herein are based on my own observations from studying the {\f2 INDEX.00#}  files and their associated {\f2 .DAT}  files in a hexeditor. \par
Through these observations alone, I believe we have enough data to successfully extract files, however, it's worth noting that there is a fair bit of data that we're ignoring here. \par
Between the {\f2 filename}  and {\f2 file_start} , there's occasionally some data, but I can't for the life of me seem to figure out what it's used for. It could be random garbage generated by whatever program created these {\f2 .DAT} /{\f2 INDEX.00#}  files, or they could be file flags, or perhaps even some sort of primative checksum; I'm not sure. \par
If you have any idea what this data might be used for, feel free to make whatever changes are needed! Both of these are probably too large, but better to be safe than sorry. \par
}{
Definition at line {\b 39} of file {\b index_file.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_index_file\:index_file.h}
{\xe \v index_file.h\:add_entry_to_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_index_file ({\b index_file} * file, {\b index_entry} * entry)}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given {\f2 {\b index_entry}}  to a {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 139} of file {\b index_file.c}.}\par
}
{\xe \v create_index_file\:index_file.h}
{\xe \v index_file.h\:create_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes an {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 33} of file {\b index_file.c}.}\par
}
{\xe \v destroy_index_file\:index_file.h}
{\xe \v index_file.h\:destroy_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t destroy_index_file ({\b index_file} * i)}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys a given {\f2 {\b index_file}} . }}\par
{
Definition at line {\b 50} of file {\b index_file.c}.}\par
}
{\xe \v print_index_entry\:index_file.h}
{\xe \v index_file.h\:print_index_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_index_entry ({\b index_entry} * idxe)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all the attributes of a given {\f2 {\b index_entry}}  in a human-readable form. }}\par
{
Definition at line {\b 129} of file {\b index_file.c}.}\par
}
{\xe \v process_index_file\:index_file.h}
{\xe \v index_file.h\:process_index_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_index_file (FILE * fptr, {\b index_file} * idxf)}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data from a given file, creating {\f2 {\b index_entry}} s for every entry in said file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every entry is 0x94 bytes apart, the part we're most concerned about is the last 16 bytes. Currently treating unknown data in between as junk. If you have any idea what this data might be used for, please feel free to make changes.\par
}{
Definition at line {\b 57} of file {\b index_file.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
index_file.h\par \pard\plain 
{\tc\tcl2 \v src/index_file.h}
{\xe \v src/index_file.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00032 {\cf21 #ifndef _HH_INDEX_FILE_H_}\par
00033 {\cf21 #define _HH_INDEX_FILE_H_}\par
00034 \par
00035 {\cf21 #include <stdint.h>}\par
00036 {\cf21 #include <stdio.h>}\par
00037 \par
00039 {\cf21 #define FULL_PATH_MAX_LEN 128}\par
00040 {\cf21 #define FILENAME_MAX_LEN 32}\par
00041 \par
00043 {\cf17 typedef} {\cf17 struct }index_entry\par
00044 \{\par
00045   uint32_t entry_start;\par
00046   {\cf18 char} full_path[FULL_PATH_MAX_LEN];\par
00047   {\cf18 char} filename[FILENAME_MAX_LEN];\par
00048   uint32_t file_start;\par
00049   uint32_t file_offset;\par
00050 \} index_entry;\par
00051 \par
00053 {\cf17 typedef} {\cf17 struct }index_file\par
00054 \{\par
00055   index_entry *indicies;\par
00056   {\cf18 size_t} size;          \par
00057   {\cf18 size_t} current_index; \par
00058 \} index_file;\par
00059 \par
00061 int8_t create_index_file (index_file *i);\par
00062 \par
00064 int8_t destroy_index_file (index_file *i);\par
00065 \par
00070 int8_t process_index_file (FILE *fptr, index_file *idxf);\par
00071 \par
00076 {\cf18 void} print_index_entry (index_entry *idxe);\par
00077 \par
00079 int8_t add_entry_to_index_file (index_file *file, index_entry *entry);\par
00080 \par
00081 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "log.h"}\par
{\f2 #include "errors.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BYTES_TO_READ}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_hex_data} (unsigned char *buffer, const uint8_t BUFFER_LEN)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_some_data_from_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BYTES_TO_READ\:log.c}
{\xe \v log.c\:BYTES_TO_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BYTES_TO_READ\~ 32}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b log.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_hex_data\:log.c}
{\xe \v log.c\:print_hex_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_hex_data (unsigned char * buffer, const uint8_t BUFFER_LEN)}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs hex data from a given {\f2 buffer}  to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Formats said data to add spaces between bytes, tabs after after every four bytes, and a new line after every 16 bytes.\par
TODO: These values are currently hardcoded in, but they likely should be moved to {\b options.h} in the future. \par
}{
Definition at line {\b 26} of file {\b log.c}.}\par
}
{\xe \v print_some_data_from_file\:log.c}
{\xe \v log.c\:print_some_data_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_some_data_from_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this function can safely fail without affecting normal operations, this doesn't return any errors, despite possibly having a fread error during normal usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b log.h} - wrapper for stdout functions. \par
}{
Definition at line {\b 50} of file {\b log.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
log.c\par \pard\plain 
{\tc\tcl2 \v src/log.c}
{\xe \v src/log.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "log.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 \par
00025 {\cf18 void}\par
00026 print_hex_data ({\cf18 unsigned} {\cf18 char} *buffer, {\cf17 const} uint8_t BUFFER_LEN)\par
00027 \{\par
00028   {\cf19 for} (uint8_t i = 0; i < BUFFER_LEN; i++)\par
00029     \{\par
00030       printf ({\cf22 " %02x"}, buffer[i]);\par
00031       {\cf19 if} ((i != 0) && (i % 4 == 3))\par
00032         \{\par
00033           printf ({\cf22 "\\t"});\par
00034         \}\par
00035       {\cf19 if} ((i != 0) && (i % 16 == 15))\par
00036         \{\par
00037           puts ({\cf22 ""});\par
00038         \}\par
00039     \}\par
00040   puts ({\cf22 ""});\par
00041 \}\par
00042 \par
00043 {\cf21 #define BYTES_TO_READ 32}\par
00049 {\cf18 void}\par
00050 print_some_data_from_file (FILE *fptr)\par
00051 \{\par
00052   {\cf18 unsigned} {\cf18 char} buffer[BYTES_TO_READ];\par
00053   {\cf18 size_t} bytes_read = fread (buffer, {\cf17 sizeof} (buffer[0]), BYTES_TO_READ, fptr);\par
00054   {\cf19 if} (bytes_read != BYTES_TO_READ)\par
00055     \{\par
00056       handle_fread_error (bytes_read, BYTES_TO_READ);\par
00057       {\cf19 return};\par
00058     \}\par
00059 \par
00060   print_hex_data (buffer, BYTES_TO_READ);\par
00061   fseek (fptr, -BYTES_TO_READ, SEEK_CUR);\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/log.h}
{\xe \v src/log.h}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_some_data_from_file} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b log.h} - wrapper for stdout functions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_some_data_from_file\:log.h}
{\xe \v log.h\:print_some_data_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_some_data_from_file (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b log.h} - wrapper for stdout functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As evidenced by the single function below, this file is rather underutilized at the moment. In the future this should host functions related to printing data out to log files, hence the name. Prints the next {\f2 BYTES_TO_READ}  many bytes to the stdout, formatted in order to be easy to read. Useful for debugging. Note that {\f2 BYTES_TO_READ}  is defined in {\f2 {\b log.c}} .\par
{\b log.h} - wrapper for stdout functions. \par
}{
Definition at line {\b 50} of file {\b log.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
log.h\par \pard\plain 
{\tc\tcl2 \v src/log.h}
{\xe \v src/log.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_LOG_H_}\par
00022 {\cf21 #define _HH_LOG_H_}\par
00023 \par
00024 {\cf21 #include <stdint.h>}\par
00025 {\cf21 #include <stdio.h>}\par
00026 \par
00032 {\cf18 void} print_some_data_from_file (FILE *fptr);\par
00033 \par
00034 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/options.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "options.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_out_list_of_command_line_arguments} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_flag} (char *f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_command_line_args} (int argc, char **argv)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_BATCH_PROCESS} = true\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_DAT_PROCESSING} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip {\f2 .DAT}  file processing and go directly to processing {\f2 INDEX.00#}  files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_DEBUG_MODE} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_INPUT_DIR} = (char *)"dat-files"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_OUTPUT_DIR} = (char *)"output"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OP_PATH_SEPARATOR} = '/'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OP_DEBUG_FILE_SIZE_LIMIT} = 0xF00000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b CURRENT_DISK_NAME} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b VERSION_NUMBER_STR} [9] = "00.00.00"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_command_line_args\:options.c}
{\xe \v options.c\:handle_command_line_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_command_line_args (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }}\par
{
Definition at line {\b 43} of file {\b options.c}.}\par
}
{\xe \v print_out_list_of_command_line_arguments\:options.c}
{\xe \v options.c\:print_out_list_of_command_line_arguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_out_list_of_command_line_arguments (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a list of supported command-line arugments to stdout. }}\par
{
Definition at line {\b 73} of file {\b options.c}.}\par
}
{\xe \v process_flag\:options.c}
{\xe \v options.c\:process_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process_flag (char * f){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes options beginning with {\f2 -}  character, called flags. }}\par
{
Definition at line {\b 88} of file {\b options.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CURRENT_DISK_NAME\:options.c}
{\xe \v options.c\:CURRENT_DISK_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CURRENT_DISK_NAME = NULL}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not really an option, should be moved elsewhere. Stored here for the sake of convenience.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b volume_descriptor_data} \par
}}}{
Definition at line {\b 32} of file {\b options.c}.}\par
}
{\xe \v OP_BATCH_PROCESS\:options.c}
{\xe \v options.c\:OP_BATCH_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_BATCH_PROCESS = true}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Currently also home to some global variables until I figure out a better place for them to be stored. If true, batch process all the files in {\f2 OP_INPUT_DIR} . \par
}{
Definition at line {\b 23} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_FILE_SIZE_LIMIT\:options.c}
{\xe \v options.c\:OP_DEBUG_FILE_SIZE_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0xF00000 = 15 MiB }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. \par
}{
Definition at line {\b 29} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_MODE\:options.c}
{\xe \v options.c\:OP_DEBUG_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_DEBUG_MODE = false}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }}\par
{
Definition at line {\b 25} of file {\b options.c}.}\par
}
{\xe \v OP_INPUT_DIR\:options.c}
{\xe \v options.c\:OP_INPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_INPUT_DIR = (char *)"dat-files"}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./dat-files/} . \par
}{
Definition at line {\b 26} of file {\b options.c}.}\par
}
{\xe \v OP_OUTPUT_DIR\:options.c}
{\xe \v options.c\:OP_OUTPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_OUTPUT_DIR = (char *)"output"}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./output/} . \par
}{
Definition at line {\b 27} of file {\b options.c}.}\par
}
{\xe \v OP_PATH_SEPARATOR\:options.c}
{\xe \v options.c\:OP_PATH_SEPARATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OP_PATH_SEPARATOR = '/'}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on the user's operating system. {\f2 \\\\}  for Windows, {\f2 /}  for *nix. \par
}{
Definition at line {\b 28} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_DAT_PROCESSING\:options.c}
{\xe \v options.c\:OP_SKIP_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_DAT_PROCESSING = false}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip {\f2 .DAT}  file processing and go directly to processing {\f2 INDEX.00#}  files. }}\par
{
Definition at line {\b 24} of file {\b options.c}.}\par
}
{\xe \v VERSION_NUMBER_STR\:options.c}
{\xe \v options.c\:VERSION_NUMBER_STR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char VERSION_NUMBER_STR[9] = "00.00.00"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b options.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
options.c\par \pard\plain 
{\tc\tcl2 \v src/options.c}
{\xe \v src/options.c}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "options.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "utils.h"}\par
00017 \par
00018 {\cf21 #include <stdio.h>}\par
00019 {\cf21 #include <stdlib.h>}\par
00020 {\cf21 #include <string.h>}\par
00021 \par
00022 {\cf20 /* Option defaults */}\par
00023 {\cf18 bool} OP_BATCH_PROCESS = {\cf17 true};\par
00024 {\cf18 bool} OP_SKIP_DAT_PROCESSING = {\cf17 false};\par
00025 {\cf18 bool} OP_DEBUG_MODE = {\cf17 false};\par
00026 {\cf18 char} *OP_INPUT_DIR = ({\cf18 char} *){\cf22 "dat-files"};\par
00027 {\cf18 char} *OP_OUTPUT_DIR = ({\cf18 char} *){\cf22 "output"};\par
00028 {\cf18 char} OP_PATH_SEPARATOR = {\cf23 '/'};\par
00029 uint32_t OP_DEBUG_FILE_SIZE_LIMIT = 0xF00000; \par
00030 \par
00031 {\cf20 /* Global defaults */}\par
00032 {\cf18 char} *CURRENT_DISK_NAME = NULL;\par
00033 \par
00034 {\cf20 // TODO: update me when finished}\par
00035 {\cf17 static} {\cf17 const} {\cf18 char} VERSION_NUMBER_STR[9] = {\cf22 "00.00.00"};\par
00036 \par
00038 {\cf17 static} {\cf18 void} print_out_list_of_command_line_arguments ({\cf18 void});\par
00040 {\cf17 static} {\cf18 void} process_flag ({\cf18 char} *f);\par
00041 \par
00042 {\cf18 void}\par
00043 handle_command_line_args ({\cf18 int} argc, {\cf18 char} **argv)\par
00044 \{\par
00045   {\cf18 int} i;\par
00046   {\cf19 for} (i = 1; i < argc; i++)\par
00047     \{\par
00048       {\cf19 if} (argv[i][0] == {\cf23 '-'})\par
00049         \{\par
00050           process_flag (argv[i]);\par
00051         \}\par
00052       {\cf19 else}\par
00053         \{\par
00054           {\cf19 break};\par
00055         \}\par
00056     \}\par
00057 \par
00058   {\cf19 if} (i == argc)\par
00059     {\cf19 return};\par
00060 \par
00061   {\cf19 if} (is_string_dat_file (argv[argc - 1]))\par
00062     \{\par
00063       {\cf20 // just processing the user-provided file @ the user-provided path}\par
00064       OP_BATCH_PROCESS = {\cf17 false};\par
00065     \}\par
00066   {\cf19 else}\par
00067     \{\par
00068       handle_unknown_command_line_argument_error (argv[argc - 1]);\par
00069     \}\par
00070 \}\par
00071 \par
00072 {\cf18 void}\par
00073 print_out_list_of_command_line_arguments ({\cf18 void})\par
00074 \{\par
00075   printf (\par
00076       {\cf22 "HarvesterHarvester (HH) Version %s Copyright (C) 2024 IcePanorama\\n"},\par
00077       VERSION_NUMBER_STR);\par
00078   puts ({\cf22 "Usage: main \{options (optional)\} \{path/to/\}[DAT FILE].DAT"});\par
00079   puts ({\cf22 "Command-line arguments:"});\par
00080   puts ({\cf22 "\\t--debug: enables debug mode, skips extracting large files."});\par
00081   puts ({\cf22 "\\t--help: displays list of command line arguments."});\par
00082   puts ({\cf22 "\\t--single: outputs all files into a single directory "}\par
00083         {\cf22 "(default=output/)."});\par
00084   puts ({\cf22 "\\t--version: prints out the version number."});\par
00085 \}\par
00086 \par
00087 {\cf18 void}\par
00088 process_flag ({\cf18 char} *f)\par
00089 \{\par
00090   {\cf19 if} (strcmp (f, {\cf22 "--debug"}) == 0)\par
00091     \{\par
00092       OP_DEBUG_MODE = {\cf17 true};\par
00093     \}\par
00094   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--help"}) == 0)\par
00095     \{\par
00096       print_out_list_of_command_line_arguments ();\par
00097       exit (0);\par
00098     \}\par
00099   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "-i"}) == 0)\par
00100     \{\par
00101       OP_SKIP_DAT_PROCESSING = {\cf17 true};\par
00102     \}\par
00103   {\cf19 else} {\cf19 if} (strcmp (f, {\cf22 "--version"}) == 0)\par
00104     \{\par
00105       printf ({\cf22 "HarvesterHarvester v%s\\n"}, VERSION_NUMBER_STR);\par
00106       exit (0);\par
00107     \}\par
00108   {\cf19 else}\par
00109     \{\par
00110       handle_unknown_command_line_argument_error (f);\par
00111     \}\par
00112 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/options.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/options.h}
{\xe \v src/options.h}
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle_command_line_args} (int argc, char **argv)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_BATCH_PROCESS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_SKIP_DAT_PROCESSING}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip {\f2 .DAT}  file processing and go directly to processing {\f2 INDEX.00#}  files. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b OP_DEBUG_MODE}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OP_DEBUG_FILE_SIZE_LIMIT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_INPUT_DIR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b OP_OUTPUT_DIR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OP_PATH_SEPARATOR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b CURRENT_DISK_NAME}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v handle_command_line_args\:options.h}
{\xe \v options.h\:handle_command_line_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void handle_command_line_args (int argc, char ** argv)}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes command-line arguments, setting options as needed. }}\par
{
Definition at line {\b 43} of file {\b options.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CURRENT_DISK_NAME\:options.h}
{\xe \v options.h\:CURRENT_DISK_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CURRENT_DISK_NAME{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current disk name as denoted by the {\f2 volume_identifier}  in {\f2 {\b volume_descriptor_data}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not really an option, should be moved elsewhere. Stored here for the sake of convenience.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b volume_descriptor_data} \par
}}}{
Definition at line {\b 32} of file {\b options.c}.}\par
}
{\xe \v OP_BATCH_PROCESS\:options.h}
{\xe \v options.h\:OP_BATCH_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_BATCH_PROCESS{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b options.h} - container for all of hh's options. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Currently also home to some global variables until I figure out a better place for them to be stored. If true, batch process all the files in {\f2 OP_INPUT_DIR} . \par
}{
Definition at line {\b 23} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_FILE_SIZE_LIMIT\:options.h}
{\xe \v options.h\:OP_DEBUG_FILE_SIZE_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OP_DEBUG_FILE_SIZE_LIMIT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum size of files to be skipped if {\f2 OP_DEBUG_MODE}  is true. \par
}{
Definition at line {\b 29} of file {\b options.c}.}\par
}
{\xe \v OP_DEBUG_MODE\:options.h}
{\xe \v options.h\:OP_DEBUG_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_DEBUG_MODE{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Skips files larger than {\f2 OP_DEBUG_FILE_SIZE_LIMIT}  if true. }}\par
{
Definition at line {\b 25} of file {\b options.c}.}\par
}
{\xe \v OP_INPUT_DIR\:options.h}
{\xe \v options.h\:OP_INPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_INPUT_DIR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to batch process files from if {\f2 OP_BATCH_PROCESS}  is true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./dat-files/} . \par
}{
Definition at line {\b 26} of file {\b options.c}.}\par
}
{\xe \v OP_OUTPUT_DIR\:options.h}
{\xe \v options.h\:OP_OUTPUT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* OP_OUTPUT_DIR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directory where hh will try to output extracted files to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is {\f2 ./output/} . \par
}{
Definition at line {\b 27} of file {\b options.c}.}\par
}
{\xe \v OP_PATH_SEPARATOR\:options.h}
{\xe \v options.h\:OP_PATH_SEPARATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OP_PATH_SEPARATOR{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Character used to separate directory/file names in a path string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on the user's operating system. {\f2 \\\\}  for Windows, {\f2 /}  for *nix. \par
}{
Definition at line {\b 28} of file {\b options.c}.}\par
}
{\xe \v OP_SKIP_DAT_PROCESSING\:options.h}
{\xe \v options.h\:OP_SKIP_DAT_PROCESSING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OP_SKIP_DAT_PROCESSING{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If true, skip {\f2 .DAT}  file processing and go directly to processing {\f2 INDEX.00#}  files. }}\par
{
Definition at line {\b 24} of file {\b options.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
options.h\par \pard\plain 
{\tc\tcl2 \v src/options.h}
{\xe \v src/options.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00020 {\cf21 #ifndef _HH_OPTIONS_H_}\par
00021 {\cf21 #define _HH_OPTIONS_H_}\par
00022 \par
00023 {\cf21 #include <stdbool.h>}\par
00024 {\cf21 #include <stdint.h>}\par
00025 \par
00027 {\cf17 extern} {\cf18 bool} OP_BATCH_PROCESS;\par
00028 \par
00033 {\cf17 extern} {\cf18 bool} OP_SKIP_DAT_PROCESSING;\par
00034 \par
00036 {\cf17 extern} {\cf18 bool} OP_DEBUG_MODE;\par
00037 \par
00039 {\cf17 extern} uint32_t OP_DEBUG_FILE_SIZE_LIMIT;\par
00040 \par
00045 {\cf17 extern} {\cf18 char} *OP_INPUT_DIR;\par
00046 \par
00051 {\cf17 extern} {\cf18 char} *OP_OUTPUT_DIR;\par
00052 \par
00057 {\cf17 extern} {\cf18 char} OP_PATH_SEPARATOR;\par
00058 \par
00066 {\cf17 extern} {\cf18 char} *CURRENT_DISK_NAME;\par
00067 \par
00069 {\cf18 void} handle_command_line_args ({\cf18 int} argc, {\cf18 char} **argv);\par
00070 \par
00071 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/output.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "output.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include "utils.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_output_directory} (char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_output_directory\:output.c}
{\xe \v output.c\:create_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_output_directory (char * path)}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an output directory at the given path if it doesn't already exist.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 28} of file {\b output.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output.c\par \pard\plain 
{\tc\tcl2 \v src/output.c}
{\xe \v src/output.c}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "output.h"}\par
00015 {\cf21 #include "errors.h"}\par
00016 {\cf21 #include "options.h"}\par
00017 {\cf21 #include "utils.h"}\par
00018 \par
00019 {\cf21 #include <stdio.h>}\par
00020 {\cf21 #include <stdlib.h>}\par
00021 {\cf21 #include <string.h>}\par
00022 {\cf21 #include <sys/stat.h>}\par
00023 {\cf21 #ifdef _WIN32}\par
00024 {\cf21 #include <direct.h>}\par
00025 {\cf21 #endif}\par
00026 \par
00027 int8_t\par
00028 create_output_directory ({\cf18 char} *path)\par
00029 \{\par
00030   {\cf19 if} (CURRENT_DISK_NAME != NULL)\par
00031     \{\par
00032       {\cf19 if} (prepend_path_string (path, CURRENT_DISK_NAME) != 0)\par
00033         {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00034     \}\par
00035 \par
00036   {\cf19 if} (prepend_path_string (path, OP_OUTPUT_DIR) != 0)\par
00037     {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00038 \par
00039   {\cf18 char} *tmp = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00040   {\cf19 if} (tmp == NULL)\par
00041     \{\par
00042       fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT, strlen (path) + 2);\par
00043       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00044     \}\par
00045 \par
00046   strcpy (tmp, path);\par
00047   {\cf18 char} *token = strtok (tmp, &OP_PATH_SEPARATOR);\par
00048 \par
00049   {\cf18 char} *dir = calloc (strlen (path) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00050   {\cf19 if} (dir == NULL)\par
00051     \{\par
00052       fprintf (stderr, CALLOC_FAILED_ERR_MSG_FMT, strlen (path) + 2);\par
00053       free (tmp);\par
00054       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00055     \}\par
00056 \par
00057   {\cf19 while} (token != NULL)\par
00058     \{\par
00059       strcat (dir, token);\par
00060 \par
00061       {\cf19 if} (!directory_exists (dir))\par
00062         \{\par
00063           {\cf20 // TODO: test on Windows}\par
00064           {\cf18 int} status;\par
00065 {\cf21 #ifdef _WIN32}\par
00066           status = _mkdir (dir);\par
00067 {\cf21 #else}\par
00068           status = mkdir (dir, 0700);\par
00069 {\cf21 #endif}\par
00070           {\cf19 if} (status != 0)\par
00071             \{\par
00072               fprintf (stderr,\par
00073                        {\cf22 "ERROR: failed to create the following output "}\par
00074                        {\cf22 "directory, %s\\n."},\par
00075                        path);\par
00076               free (dir);\par
00077               free (tmp);\par
00078               {\cf19 return} HH_CREATE_OUTPUT_DIR_ERROR;\par
00079             \}\par
00080         \}\par
00081 \par
00082       strcat (dir, &OP_PATH_SEPARATOR);\par
00083       token = strtok (NULL, &OP_PATH_SEPARATOR);\par
00084     \}\par
00085 \par
00086   free (dir);\par
00087   free (tmp);\par
00088   {\cf19 return} 0;\par
00089 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/output.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/output.h}
{\xe \v src/output.h}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_output_directory} (char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_output_directory\:output.h}
{\xe \v output.h\:create_output_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_output_directory (char * path)}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b output.h} - container for functions related to the output directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an output directory at the given path if it doesn't already exist.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
zero on success, non-zero on failure. \par
}}}{
Definition at line {\b 28} of file {\b output.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output.h\par \pard\plain 
{\tc\tcl2 \v src/output.h}
{\xe \v src/output.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_OUTPUT_H_}\par
00016 {\cf21 #define _HH_OUTPUT_H_}\par
00017 \par
00018 {\cf21 #include <stdbool.h>}\par
00019 {\cf21 #include <stdint.h>}\par
00020 \par
00026 int8_t create_output_directory ({\cf18 char} *path);\par
00027 \par
00028 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/path_table.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "path_table.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b resize_path_table_entries} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_path_table_entry} ({\b path_table_entry} *e)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a {\b path_table_entry} to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int8_t {\b add_entry_to_path_table} ({\b path_table} *pt, {\b path_table_entry} *entry)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 {\b path_table_entry}}  to the given {\f2 {\b path_table}} 's list of {\f2 entries} , resizing it as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_type_l_path_table} (FILE *fptr, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_STARTING_NUM_ENTRIES} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b PT_GROWTH_RATE} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_entry_to_path_table\:path_table.c}
{\xe \v path_table.c\:add_entry_to_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t add_entry_to_path_table ({\b path_table} * pt, {\b path_table_entry} * entry){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\f2 {\b path_table_entry}}  to the given {\f2 {\b path_table}} 's list of {\f2 entries} , resizing it as needed. }}\par
{
Definition at line {\b 66} of file {\b path_table.c}.}\par
}
{\xe \v create_path_table\:path_table.c}
{\xe \v path_table.c\:create_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, {\f2 entries}  is given a size of {\f2 PT_STARTING_NUM_ENTRIES} . Note that {\f2 PT_STARTING_NUM_ENTRIES}  is defined in {\f2 {\b path_table.c}} . \par
}{
Definition at line {\b 29} of file {\b path_table.c}.}\par
}
{\xe \v destroy_path_table\:path_table.c}
{\xe \v path_table.c\:destroy_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }}\par
{
Definition at line {\b 50} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table\:path_table.c}
{\xe \v path_table.c\:print_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }}\par
{
Definition at line {\b 104} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table_entry\:path_table.c}
{\xe \v path_table.c\:print_path_table_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table_entry ({\b path_table_entry} * e){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a {\b path_table_entry} to the stdout in a human-readable form. }}\par
{
Definition at line {\b 114} of file {\b path_table.c}.}\par
}
{\xe \v process_type_l_path_table\:path_table.c}
{\xe \v path_table.c\:process_type_l_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_type_l_path_table (FILE * fptr, {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 126} of file {\b path_table.c}.}\par
}
{\xe \v resize_path_table_entries\:path_table.c}
{\xe \v path_table.c\:resize_path_table_entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t resize_path_table_entries ({\b path_table} * pt){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes a given {\f2 path_tables}  list of entries by a factor of {\f2 PT_GROWTH_RATE} . }}\par
{
Definition at line {\b 80} of file {\b path_table.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PT_GROWTH_RATE\:path_table.c}
{\xe \v path_table.c\:PT_GROWTH_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_GROWTH_RATE = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b path_table.c}.}\par
}
{\xe \v PT_STARTING_NUM_ENTRIES\:path_table.c}
{\xe \v path_table.c\:PT_STARTING_NUM_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t PT_STARTING_NUM_ENTRIES = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b path_table.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table.c\par \pard\plain 
{\tc\tcl2 \v src/path_table.c}
{\xe \v src/path_table.c}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "path_table.h"}\par
00002 {\cf21 #include "data_reader.h"}\par
00003 {\cf21 #include "errors.h"}\par
00004 \par
00005 {\cf21 #include <stdint.h>}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 \par
00009 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_STARTING_NUM_ENTRIES = 10;\par
00010 {\cf17 static} {\cf17 const} {\cf18 size_t} PT_GROWTH_RATE = 2;\par
00011 \par
00016 {\cf17 static} int8_t resize_path_table_entries (path_table *pt);\par
00017 \par
00019 {\cf17 static} {\cf18 void} print_path_table_entry (path_table_entry *e);\par
00020 \par
00025 {\cf17 static} int8_t add_entry_to_path_table (path_table *pt,\par
00026                                        path_table_entry *entry);\par
00027 \par
00028 int8_t\par
00029 create_path_table (path_table *pt)\par
00030 \{\par
00031   pt->entries = malloc ({\cf17 sizeof} (path_table_entry) * PT_STARTING_NUM_ENTRIES);\par
00032   {\cf19 if} (pt->entries == NULL)\par
00033     \{\par
00034       perror ({\cf22 "ERROR: Failed to allocate memory for path table."});\par
00035       {\cf19 return} -1;\par
00036     \}\par
00037 \par
00038   pt->size = PT_STARTING_NUM_ENTRIES;\par
00039   pt->current_entry = 0;\par
00040 \par
00041   {\cf19 for} ({\cf18 size_t} i = 0; i < PT_STARTING_NUM_ENTRIES; i++)\par
00042     \{\par
00043       pt->entries[i].directory_identifier = NULL;\par
00044     \}\par
00045 \par
00046   {\cf19 return} 0;\par
00047 \}\par
00048 \par
00049 {\cf18 void}\par
00050 destroy_path_table (path_table *pt)\par
00051 \{\par
00052   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->size; i++)\par
00053     \{\par
00054       {\cf19 if} (pt->entries[i].directory_identifier == NULL)\par
00055         {\cf19 continue};\par
00056 \par
00057       free (pt->entries[i].directory_identifier);\par
00058       pt->entries[i].directory_identifier = NULL;\par
00059     \}\par
00060 \par
00061   free (pt->entries);\par
00062   pt->entries = NULL;\par
00063 \}\par
00064 \par
00065 int8_t\par
00066 add_entry_to_path_table (path_table *pt, path_table_entry *entry)\par
00067 \{\par
00068   {\cf19 if} (pt->current_entry >= pt->size)\par
00069     \{\par
00070       {\cf19 if} (resize_path_table_entries (pt) != 0)\par
00071         {\cf19 return} HH_PT_RESIZE_ERROR;\par
00072     \}\par
00073 \par
00074   pt->entries[pt->current_entry] = *entry;\par
00075   pt->current_entry++;\par
00076   {\cf19 return} 0;\par
00077 \}\par
00078 \par
00079 int8_t\par
00080 resize_path_table_entries (path_table *pt)\par
00081 \{\par
00082   {\cf18 size_t} new_size = (size_t)(pt->size * PT_GROWTH_RATE);\par
00083   path_table_entry *new_entries = (path_table_entry *)realloc (\par
00084       pt->entries, sizeof (path_table_entry) * new_size);\par
00085   {\cf19 if} (new_entries == NULL)\par
00086     \{\par
00087       fprintf (stderr, {\cf22 "ERROR: Ralloc failed for `entries` of size %zu.\\n"},\par
00088                new_size);\par
00089       destroy_path_table (pt);\par
00090       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00091     \}\par
00092 \par
00093   pt->entries = new_entries;\par
00094   {\cf19 for} ({\cf18 size_t} i = pt->size; i < new_size; i++)\par
00095     \{\par
00096       pt->entries[i].directory_identifier = NULL;\par
00097     \}\par
00098 \par
00099   pt->size = new_size;\par
00100   {\cf19 return} 0;\par
00101 \}\par
00102 \par
00103 {\cf18 void}\par
00104 print_path_table (path_table *pt)\par
00105 \{\par
00106   {\cf19 for} ({\cf18 size_t} i = 0; i < pt->current_entry; i++)\par
00107     \{\par
00108       printf ({\cf22 "Entry %zu:\\n"}, i + 1);\par
00109       print_path_table_entry (&pt->entries[i]);\par
00110     \}\par
00111 \}\par
00112 \par
00113 {\cf18 void}\par
00114 print_path_table_entry (path_table_entry *e)\par
00115 \{\par
00116   printf ({\cf22 "\\tDirectory identifier length: %02X\\n"},\par
00117           e->directory_identifier_length);\par
00118   printf ({\cf22 "\\tExtended attribute record length: %02X\\n"},\par
00119           e->extended_attribute_record_length);\par
00120   printf ({\cf22 "\\tLocation of extant: %08X\\n"}, e->location_of_extent);\par
00121   printf ({\cf22 "\\tParent directory number: %04X\\n"}, e->parent_directory_number);\par
00122   printf ({\cf22 "\\tDirectory identifier: %s\\n"}, e->directory_identifier);\par
00123 \}\par
00124 \par
00125 int8_t\par
00126 process_type_l_path_table (FILE *fptr, path_table *pt)\par
00127 \{\par
00128   uint8_t dir_identifier_length;\par
00129   {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00130     {\cf19 return} HH_FREAD_ERROR;\par
00131 \par
00132   {\cf19 do}\par
00133     \{\par
00134       path_table_entry curr;\par
00135       curr.directory_identifier_length = dir_identifier_length;\par
00136 \par
00137       {\cf19 if} (curr.directory_identifier_length != 1)\par
00138         curr.directory_identifier_length += 1;\par
00139 \par
00140       {\cf20 /* clang-format off */}\par
00141       {\cf19 if} ((read_single_uint8 (fptr, &curr.extended_attribute_record_length) != 0)\par
00142           || (read_little_endian_data_uint32_t (fptr, &curr.location_of_extent) != 0)\par
00143           || (read_little_endian_data_uint16_t (fptr, &curr.parent_directory_number)) != 0)\par
00144         \{\par
00145           {\cf19 return} HH_FREAD_ERROR;\par
00146         \}\par
00147       {\cf20 /* clang-format on */}\par
00148 \par
00149       curr.directory_identifier\par
00150           = ({\cf18 char} *)calloc (curr.directory_identifier_length, sizeof ({\cf18 char}));\par
00151 \par
00152       {\cf19 if} (curr.directory_identifier_length != 1)\par
00153         \{\par
00154           {\cf18 size_t} bytes_read\par
00155               = fread (curr.directory_identifier, sizeof ({\cf18 char}),\par
00156                        curr.directory_identifier_length - 1, fptr);\par
00157           curr.directory_identifier[curr.directory_identifier_length - 1]\par
00158               = {\cf23 '\\0'};\par
00159           {\cf19 if} (bytes_read\par
00160               != {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1))\par
00161             \{\par
00162               handle_fread_error (\par
00163                   bytes_read,\par
00164                   {\cf17 sizeof} ({\cf18 char}) * (curr.directory_identifier_length - 1));\par
00165               {\cf19 return} HH_FREAD_ERROR;\par
00166             \}\par
00167         \}\par
00168       {\cf19 else}\par
00169         \{\par
00170           fseek (fptr, 1, SEEK_CUR);\par
00171         \}\par
00172 \par
00173       {\cf19 if} (add_entry_to_path_table (pt, &curr) != 0)\par
00174         {\cf19 return} HH_PT_RESIZE_ERROR;\par
00175 \par
00176       {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00177         {\cf19 return} HH_FREAD_ERROR;\par
00178 \par
00179       {\cf19 if} (dir_identifier_length == 0) {\cf20 // handle padding field}\par
00180         \{\par
00181           {\cf19 if} (read_single_uint8 (fptr, &dir_identifier_length) != 0)\par
00182             {\cf19 return} HH_FREAD_ERROR;\par
00183         \}\par
00184     \}\par
00185   {\cf19 while} (dir_identifier_length != 0);\par
00186 \par
00187   {\cf19 return} 0;\par
00188 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/path_table.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/path_table.h}
{\xe \v src/path_table.h}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b path_table_entry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b path_table.h} - the {\f2 {\b path_table}}  and {\f2 {\b path_table_entry}}  data types and their related functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b path_table}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A collection of path_table_entries. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b create_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_path_table} ({\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_type_l_path_table} (FILE *fptr, {\b path_table} *pt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_path_table\:path_table.h}
{\xe \v path_table.h\:create_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t create_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b path_table}} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, {\f2 entries}  is given a size of {\f2 PT_STARTING_NUM_ENTRIES} . Note that {\f2 PT_STARTING_NUM_ENTRIES}  is defined in {\f2 {\b path_table.c}} . \par
}{
Definition at line {\b 29} of file {\b path_table.c}.}\par
}
{\xe \v destroy_path_table\:path_table.h}
{\xe \v path_table.h\:destroy_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the given {\f2 {\b path_table}} , freeing any and all memory alloc'd for {\f2 entries} . }}\par
{
Definition at line {\b 50} of file {\b path_table.c}.}\par
}
{\xe \v print_path_table\:path_table.h}
{\xe \v path_table.h\:print_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_path_table ({\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given path table out to the stdout, formatting it into a human-readible form. }}\par
{
Definition at line {\b 104} of file {\b path_table.c}.}\par
}
{\xe \v process_type_l_path_table\:path_table.h}
{\xe \v path_table.h\:process_type_l_path_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_type_l_path_table (FILE * fptr, {\b path_table} * pt)}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b path_table}}  as a Type-L {\f2 {\b path_table}} , using the data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 126} of file {\b path_table.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
path_table.h\par \pard\plain 
{\tc\tcl2 \v src/path_table.h}
{\xe \v src/path_table.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00021 {\cf21 #ifndef _HH_PATH_TABLE_H_}\par
00022 {\cf21 #define _HH_PATH_TABLE_H_}\par
00023 \par
00024 {\cf21 #include <stdint.h>}\par
00025 {\cf21 #include <stdio.h>}\par
00026 \par
00032 {\cf17 typedef} {\cf17 struct }path_table_entry\par
00033 \{\par
00034   uint8_t directory_identifier_length;\par
00035   uint8_t extended_attribute_record_length;\par
00036   uint32_t location_of_extent;\par
00037   uint16_t parent_directory_number; \par
00038   {\cf18 char} *directory_identifier;\par
00039 \} path_table_entry;\par
00040 \par
00042 {\cf17 typedef} {\cf17 struct }path_table\par
00043 \{\par
00044   path_table_entry *entries;\par
00045   {\cf18 size_t} size;          \par
00046   {\cf18 size_t} current_entry; \par
00047 \} path_table;\par
00048 \par
00054 int8_t create_path_table (path_table *pt);\par
00055 \par
00060 {\cf18 void} destroy_path_table (path_table *pt);\par
00061 \par
00066 {\cf18 void} print_path_table (path_table *pt);\par
00067 \par
00072 int8_t process_type_l_path_table (FILE *fptr, path_table *pt);\par
00073 \par
00074 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utils.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include "options.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b prepend_path_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b prepend_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string_dat_file} (char *str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directory_exists} (const char *dir)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b file_exists} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_char_is} (FILE *fptr, uint8_t expected_ch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_eof} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b change_endianness_uint16} (uint16_t value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_endianness_uint16\:utils.c}
{\xe \v utils.c\:change_endianness_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t change_endianness_uint16 (uint16_t value)}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps a {\f2 uint16_t}  from little endian to big endian or vice-versa. \par
}{
Definition at line {\b 140} of file {\b utils.c}.}\par
}
{\xe \v directory_exists\:utils.c}
{\xe \v utils.c\:directory_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool directory_exists (const char * dir)}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 dir}  is a string containing the path to said directory. \par
}{
Definition at line {\b 88} of file {\b utils.c}.}\par
}
{\xe \v file_exists\:utils.c}
{\xe \v utils.c\:file_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_exists (const char * filename)}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 filename}  is a string containing the path to said file. \par
}{
Definition at line {\b 100} of file {\b utils.c}.}\par
}
{\xe \v is_string_dat_file\:utils.c}
{\xe \v utils.c\:is_string_dat_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_string_dat_file (char * str)}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }}\par
{
Definition at line {\b 77} of file {\b utils.c}.}\par
}
{\xe \v peek_char_is\:utils.c}
{\xe \v utils.c\:peek_char_is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_char_is (FILE * fptr, uint8_t expected_ch)}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On error, returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . \par
}{
Definition at line {\b 113} of file {\b utils.c}.}\par
}
{\xe \v peek_eof\:utils.c}
{\xe \v utils.c\:peek_eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_eof (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is sort of a hacky solution. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker.\par
TODO: implement better err handling. \par
}{
Definition at line {\b 131} of file {\b utils.c}.}\par
}
{\xe \v prepend_path_string\:utils.c}
{\xe \v utils.c\:prepend_path_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t prepend_path_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }}\par
{
Definition at line {\b 31} of file {\b utils.c}.}\par
}
{\xe \v prepend_string\:utils.c}
{\xe \v utils.c\:prepend_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void prepend_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }}\par
{
Definition at line {\b 56} of file {\b utils.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.c\par \pard\plain 
{\tc\tcl2 \v src/utils.c}
{\xe \v src/utils.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "utils.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 {\cf21 #include "options.h"}\par
00018 \par
00019 {\cf21 #include <stdlib.h>}\par
00020 {\cf21 #include <string.h>}\par
00021 {\cf21 #include <sys/stat.h>}\par
00022 \par
00023 {\cf21 #ifdef _WIN32}\par
00024 {\cf21 #include <direct.h>}\par
00025 {\cf21 #include <windows.h>}\par
00026 {\cf21 #else}\par
00027 {\cf21 #include <unistd.h>}\par
00028 {\cf21 #endif}\par
00029 \par
00030 int8_t\par
00031 prepend_path_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00032 \{\par
00033   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00034       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00035     \{\par
00036       {\cf19 return} 0;\par
00037     \}\par
00038 \par
00039   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00040   {\cf19 if} (tmp == NULL)\par
00041     \{\par
00042       perror ({\cf22 "ERROR: unable to calloc tmp string"});\par
00043       {\cf19 return} HH_MEM_ALLOC_ERROR;\par
00044     \}\par
00045 \par
00046   strcpy (tmp, str);\par
00047   strcpy (str, prefix);\par
00048   strcat (str, &OP_PATH_SEPARATOR);\par
00049   strcat (str, tmp);\par
00050   free (tmp);\par
00051 \par
00052   {\cf19 return} 0;\par
00053 \}\par
00054 \par
00055 {\cf18 void}\par
00056 prepend_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix)\par
00057 \{\par
00058   {\cf19 if} (strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 ""}) == 0\par
00059       || strcmp (prefix, ({\cf17 const} {\cf18 char} *){\cf22 "\\1"}) == 0)\par
00060     \{\par
00061       {\cf19 return};\par
00062     \}\par
00063 \par
00064   {\cf18 char} *tmp = calloc (strlen (str) + strlen (prefix) + 2, {\cf17 sizeof} ({\cf18 char}));\par
00065   {\cf19 if} (tmp == NULL)\par
00066     \{\par
00067       perror ({\cf22 "ERROR: unable to calloc tmp string"});\par
00068       exit (1);\par
00069     \}\par
00070   strcpy (tmp, str);\par
00071   strcpy (str, prefix);\par
00072   strcat (str, tmp);\par
00073   free (tmp);\par
00074 \}\par
00075 \par
00076 {\cf18 bool}\par
00077 is_string_dat_file ({\cf18 char} *str)\par
00078 \{\par
00079   {\cf17 const} {\cf18 char} *EXPECTED_EXTENSION = {\cf22 ".DAT"};\par
00080   {\cf17 const} uint8_t EXTENSION_LEN = 5; {\cf20 // +1 for null terminator}\par
00081 \par
00082   {\cf18 size_t} len = strlen (str) + 1;\par
00083   {\cf19 return} (len > EXTENSION_LEN\par
00084           && strcmp (str + (len - EXTENSION_LEN), EXPECTED_EXTENSION) == 0);\par
00085 \}\par
00086 \par
00087 {\cf18 bool}\par
00088 directory_exists ({\cf17 const} {\cf18 char} *dir)\par
00089 \{\par
00090 {\cf21 #ifdef _WIN32}\par
00091   {\cf17 struct }_stat st;\par
00092   {\cf19 return} (_stat (dir, &st) == 0 && (st.st_mode & _S_IFDIR));\par
00093 {\cf21 #else}\par
00094   {\cf17 struct }stat st;\par
00095   {\cf19 return} (stat (dir, &st) == 0 && S_ISDIR (st.st_mode));\par
00096 {\cf21 #endif}\par
00097 \}\par
00098 \par
00099 {\cf18 bool}\par
00100 file_exists ({\cf17 const} {\cf18 char} *filename)\par
00101 \{\par
00102 {\cf21 #ifdef _WIN32}\par
00103   DWORD attribs = GetFileAttributes (filename);\par
00104   {\cf19 return} attribs != INVALID_FILE_ATTRIBUTES\par
00105          && !(attribs & FILE_ATTRIBUTE_DIRECTORY);\par
00106 {\cf21 #else}\par
00107   {\cf19 return} access (filename, F_OK) != -1;\par
00108 {\cf21 #endif}\par
00109 \}\par
00110 \par
00112 {\cf18 bool}\par
00113 peek_char_is (FILE *fptr, uint8_t expected_ch)\par
00114 \{\par
00115   uint8_t byte;\par
00116   {\cf19 if} (read_single_uint8 (fptr, &{\cf18 byte}) != 0)\par
00117     \{\par
00118       {\cf19 return} {\cf17 false};\par
00119     \}\par
00120   {\cf19 else} {\cf19 if} ({\cf18 byte} == expected_ch)\par
00121     \{\par
00122       {\cf19 return} {\cf17 true};\par
00123     \}\par
00124 \par
00125   fseek (fptr, -1, SEEK_CUR);\par
00126   {\cf19 return} {\cf17 false};\par
00127 \}\par
00128 \par
00130 {\cf18 bool}\par
00131 peek_eof (FILE *fptr)\par
00132 \{\par
00133   uint8_t value;\par
00134   {\cf18 size_t} bytes_read = fread (&value, {\cf17 sizeof} (uint8_t), 1, fptr);\par
00135   fseek (fptr, -1, SEEK_CUR);\par
00136   {\cf19 return} bytes_read == 0;\par
00137 \}\par
00138 \par
00139 uint16_t\par
00140 change_endianness_uint16 (uint16_t value)\par
00141 \{\par
00142   {\cf19 return} (value << 8) | (value >> 8);\par
00143 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/utils.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/utils.h}
{\xe \v src/utils.h}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "file_flags.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b change_endianness_uint16} (uint16_t value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b prepend_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b prepend_path_string} (char *str, const char *prefix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string_dat_file} (char *str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directory_exists} (const char *dir)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b file_exists} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_char_is} (FILE *fptr, uint8_t expected_ch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b peek_eof} (FILE *fptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_endianness_uint16\:utils.h}
{\xe \v utils.h\:change_endianness_uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t change_endianness_uint16 (uint16_t value)}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b utils.h} - a collection of utility functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps a {\f2 uint16_t}  from little endian to big endian or vice-versa. \par
}{
Definition at line {\b 140} of file {\b utils.c}.}\par
}
{\xe \v directory_exists\:utils.h}
{\xe \v utils.h\:directory_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool directory_exists (const char * dir)}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given directory exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 dir}  is a string containing the path to said directory. \par
}{
Definition at line {\b 88} of file {\b utils.c}.}\par
}
{\xe \v file_exists\:utils.h}
{\xe \v utils.h\:file_exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool file_exists (const char * filename)}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given file exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 filename}  is a string containing the path to said file. \par
}{
Definition at line {\b 100} of file {\b utils.c}.}\par
}
{\xe \v is_string_dat_file\:utils.h}
{\xe \v utils.h\:is_string_dat_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_string_dat_file (char * str)}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string ends in {\f2 .DAT} . }}\par
{
Definition at line {\b 77} of file {\b utils.c}.}\par
}
{\xe \v peek_char_is\:utils.h}
{\xe \v utils.h\:peek_char_is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_char_is (FILE * fptr, uint8_t expected_ch)}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file matches {\f2 expected_ch} . \par
}{
Definition at line {\b 113} of file {\b utils.c}.}\par
}
{\xe \v peek_eof\:utils.h}
{\xe \v utils.h\:peek_eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool peek_eof (FILE * fptr)}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the next character in the file is an EOF marker.\par
TODO: implement better err handling. \par
}{
Definition at line {\b 131} of file {\b utils.c}.}\par
}
{\xe \v prepend_path_string\:utils.h}
{\xe \v utils.h\:prepend_path_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t prepend_path_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string, adding an {\f2 OP_PATH_SEPARATOR}  between the two of them. }}\par
{
Definition at line {\b 31} of file {\b utils.c}.}\par
}
{\xe \v prepend_string\:utils.h}
{\xe \v utils.h\:prepend_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void prepend_string (char * str, const char * prefix)}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepends a given {\f2 prefix}  onto a given string. }}\par
{
Definition at line {\b 56} of file {\b utils.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.h\par \pard\plain 
{\tc\tcl2 \v src/utils.h}
{\xe \v src/utils.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00015 {\cf21 #ifndef _HH_UTILS_H_}\par
00016 {\cf21 #define _HH_UTILS_H_}\par
00017 \par
00018 {\cf21 #include "file_flags.h"}\par
00019 \par
00020 {\cf21 #include <stdbool.h>}\par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <stdio.h>}\par
00023 \par
00025 uint16_t change_endianness_uint16 (uint16_t value);\par
00026 \par
00028 {\cf18 void} prepend_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix);\par
00029 \par
00034 int8_t prepend_path_string ({\cf18 char} *str, {\cf17 const} {\cf18 char} *prefix);\par
00035 \par
00037 {\cf18 bool} is_string_dat_file ({\cf18 char} *str);\par
00038 \par
00043 {\cf18 bool} directory_exists ({\cf17 const} {\cf18 char} *dir);\par
00044 \par
00049 {\cf18 bool} file_exists ({\cf17 const} {\cf18 char} *filename);\par
00050 \par
00052 {\cf18 bool} peek_char_is (FILE *fptr, uint8_t expected_ch);\par
00053 \par
00055 {\cf18 bool} peek_eof (FILE *fptr);\par
00056 \par
00057 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/volume_descriptor.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "volume_descriptor.h"}\par
{\f2 #include "data_reader.h"}\par
{\f2 #include "errors.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_volume_descriptor} ({\b volume_descriptor} *vd, uint8_t type_code, uint8_t version)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_header} ({\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_data} ({\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_header} (FILE *fptr, {\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_data} (FILE *fptr, {\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_volume_descriptor\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:create_volume_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_volume_descriptor ({\b volume_descriptor} * vd, uint8_t type_code, uint8_t version)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }}\par
{
Definition at line {\b 22} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_data ({\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }}\par
{
Definition at line {\b 40} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:print_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_header ({\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The header includes every field except for {\f2 data} , which can be printed using the {\f2 {\b print_volume_descriptor_data()}}  function. \par
}{
Definition at line {\b 32} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_data\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_data (FILE * fptr, {\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 99} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_header\:volume_descriptor.c}
{\xe \v volume_descriptor.c\:process_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_header (FILE * fptr, {\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 81} of file {\b volume_descriptor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor.c\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.c}
{\xe \v src/volume_descriptor.c}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00014 {\cf21 #include "volume_descriptor.h"}\par
00015 {\cf21 #include "data_reader.h"}\par
00016 {\cf21 #include "errors.h"}\par
00017 \par
00018 {\cf21 #include <stdint.h>}\par
00019 {\cf21 #include <string.h>}\par
00020 \par
00021 {\cf18 void}\par
00022 create_volume_descriptor (volume_descriptor *vd, uint8_t type_code,\par
00023                           uint8_t version)\par
00024 \{\par
00025   vd->type_code = type_code;\par
00026   strncpy (vd->identifier, {\cf22 "CD001"}, sizeof (vd->identifier));\par
00027   vd->identifier[{\cf17 sizeof} (vd->identifier) - 1] = {\cf23 '\\0'};\par
00028   vd->version = version;\par
00029 \}\par
00030 \par
00031 {\cf18 void}\par
00032 print_volume_descriptor_header (volume_descriptor *vd)\par
00033 \{\par
00034   printf ({\cf22 "Volume descriptor type code: %02x\\n"}, vd->type_code);\par
00035   printf ({\cf22 "Volume descriptor identifier: %s\\n"}, vd->identifier);\par
00036   printf ({\cf22 "Volume descriptor version: %02x\\n"}, vd->version);\par
00037 \}\par
00038 \par
00039 {\cf18 void}\par
00040 print_volume_descriptor_data (volume_descriptor_data *vdd)\par
00041 \{\par
00042   printf ({\cf22 "System identifier: %s\\n"}, vdd->system_identifier);\par
00043   printf ({\cf22 "Volume identifier: %s\\n"}, vdd->volume_identifier);\par
00044   printf ({\cf22 "Vol space size: %08X\\n"}, vdd->volume_space_size);\par
00045   printf ({\cf22 "Vol set size: %04X\\n"}, vdd->volume_set_size);\par
00046   printf ({\cf22 "Vol sequence size: %04X\\n"}, vdd->volume_sequence_number);\par
00047   printf ({\cf22 "Logical block size: %04X\\n"}, vdd->logical_block_size);\par
00048   printf ({\cf22 "Path table size: %08X\\n"}, vdd->path_table_size);\par
00049   printf ({\cf22 "Type-L path table location: %08X\\n"},\par
00050           vdd->type_l_path_table_location);\par
00051   printf ({\cf22 "Optional Type-L path table location: %08X\\n"},\par
00052           vdd->optional_type_l_path_table_location);\par
00053   printf ({\cf22 "Type-M path table location: %08X\\n"},\par
00054           vdd->type_m_path_table_location);\par
00055   printf ({\cf22 "Optional Type-M path table location: %08X\\n"},\par
00056           vdd->optional_type_m_path_table_location);\par
00057   printf ({\cf22 "Volume set identifier: %s\\n"}, vdd->volume_set_identifier);\par
00058   printf ({\cf22 "Publisher identifier: %s\\n"}, vdd->publisher_identifier);\par
00059   printf ({\cf22 "Data preparer identifier: %s\\n"}, vdd->data_preparer_identifier);\par
00060   printf ({\cf22 "Application identifier: %s\\n"}, vdd->application_identifier);\par
00061   printf ({\cf22 "Copyright file identifier: %s\\n"}, vdd->copyright_file_identifier);\par
00062   printf ({\cf22 "Abstract file identifier: %s\\n"}, vdd->abstract_file_identifier);\par
00063   printf ({\cf22 "Bibliographic file identifier: %s\\n"},\par
00064           vdd->bibliographic_file_identifier);\par
00065   printf ({\cf22 "Volume creation date and time: "});\par
00066   print_dec_datetime (vdd->volume_creation_date_and_time);\par
00067   printf ({\cf22 "Volume modification date and time: "});\par
00068   print_dec_datetime (vdd->volume_modification_date_and_time);\par
00069   printf ({\cf22 "Volume expiration date and time: "});\par
00070   print_dec_datetime (vdd->volume_expiration_date_and_time);\par
00071   printf ({\cf22 "Volume effective date and time: "});\par
00072   print_dec_datetime (vdd->volume_effective_date_and_time);\par
00073   printf ({\cf22 "File structure version: %02X\\n"}, vdd->file_structure_version);\par
00074   printf ({\cf22 "DAT file creation software identifier: %s\\n"},\par
00075           vdd->DAT_file_creation_software_identifier);\par
00076   printf ({\cf22 "DAT file creation software version number: %s\\n"},\par
00077           vdd->DAT_file_creation_software_version_number);\par
00078 \}\par
00079 \par
00080 int8_t\par
00081 process_volume_descriptor_header (FILE *fptr, volume_descriptor *vd)\par
00082 \{\par
00083   uint8_t descriptor_type;\par
00084   {\cf19 if} (read_single_uint8 (fptr, &descriptor_type) != 0)\par
00085     {\cf19 return} HH_FREAD_ERROR;\par
00086 \par
00087   fseek (fptr, 5, SEEK_CUR);\par
00088 \par
00089   uint8_t descriptor_ver;\par
00090   {\cf19 if} (read_single_uint8 (fptr, &descriptor_ver) != 0)\par
00091     {\cf19 return} HH_FREAD_ERROR;\par
00092 \par
00093   create_volume_descriptor (vd, descriptor_type, descriptor_ver);\par
00094 \par
00095   {\cf19 return} 0;\par
00096 \}\par
00097 \par
00098 int8_t\par
00099 process_volume_descriptor_data (FILE *fptr, volume_descriptor_data *vdd)\par
00100 \{\par
00101   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00102 \par
00103   {\cf19 if} ((read_string (fptr, vdd->system_identifier, SYSTEM_IDENTIFIER_LEN) != 0)\par
00104       || (read_string (fptr, vdd->volume_identifier, VOLUME_IDENTIFIER_LEN)\par
00105           != 0))\par
00106     \{\par
00107       {\cf19 return} HH_FREAD_ERROR;\par
00108     \}\par
00109 \par
00110   fseek (fptr, 8, SEEK_CUR); {\cf20 // Unused field}\par
00111 \par
00112   {\cf19 if} (read_both_endian_data_uint32 (fptr, &vdd->volume_space_size) != 0)\par
00113     {\cf19 return} HH_FREAD_ERROR;\par
00114 \par
00115   fseek (fptr, 32, SEEK_CUR); {\cf20 // Unused field}\par
00116 \par
00117   {\cf20 /* clang-format off */}\par
00118   {\cf19 if} ((read_both_endian_data_uint16 (fptr, &vdd->volume_set_size) != 0)\par
00119       || (read_both_endian_data_uint16 (fptr, &vdd->volume_sequence_number) != 0)\par
00120       || (read_both_endian_data_uint16 (fptr, &vdd->logical_block_size) != 0))\par
00121   \{\par
00122     {\cf19 return} HH_FREAD_ERROR;\par
00123   \}\par
00124   {\cf20 /* clang-format on */}\par
00125 \par
00126   {\cf19 if} ((read_both_endian_data_uint32 (fptr, &vdd->path_table_size) != 0)\par
00127       || (read_little_endian_data_uint32_t (fptr,\par
00128                                             &vdd->type_l_path_table_location)\par
00129           != 0)\par
00130       || (read_little_endian_data_uint32_t (\par
00131               fptr, &vdd->optional_type_l_path_table_location)\par
00132           != 0)\par
00133       || (read_little_endian_data_uint32_t (fptr,\par
00134                                             &vdd->type_m_path_table_location)\par
00135           != 0)\par
00136       || (read_little_endian_data_uint32_t (\par
00137               fptr, &vdd->optional_type_m_path_table_location)\par
00138           != 0))\par
00139     \{\par
00140       {\cf19 return} HH_FREAD_ERROR;\par
00141     \}\par
00142 \par
00143   {\cf19 if} (read_array_uint8 (fptr, vdd->root_directory_entry,\par
00144                         ROOT_DIRECTORY_ENTRY_LEN)\par
00145       != 0)\par
00146     \{\par
00147       {\cf19 return} HH_FREAD_ERROR;\par
00148     \}\par
00149 \par
00150   {\cf20 /* clang-format off */}\par
00151   {\cf19 if} ((read_string (fptr, vdd->volume_set_identifier, VOLUME_SET_IDENTIFIER_LEN) != 0)\par
00152       || (read_string (fptr, vdd->publisher_identifier, PUBLISHER_IDENTIFIER_LEN) != 0)\par
00153       || (read_string (fptr, vdd->data_preparer_identifier, DATA_PREPARER_IDENTIFIER_LEN) != 0)\par
00154       || (read_string (fptr, vdd->application_identifier, APPLICATION_IDENTIFIER_LEN) != 0)\par
00155       || (read_string (fptr, vdd->copyright_file_identifier, COPYRIGHT_FILE_IDENTIFIER_LEN) != 0)\par
00156       || (read_string (fptr, vdd->abstract_file_identifier, ABSTRACT_FILE_IDENTIFIER_LEN) != 0)\par
00157       || (read_string (fptr, vdd->bibliographic_file_identifier, BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN) != 0))\par
00158   \{\par
00159     {\cf19 return} HH_FREAD_ERROR;\par
00160   \}\par
00161   {\cf20 /* clang-format on */}\par
00162 \par
00163   {\cf19 if} ((read_dec_datetime (fptr, &vdd->volume_creation_date_and_time) != 0)\par
00164       || (read_dec_datetime (fptr, &vdd->volume_modification_date_and_time)\par
00165           != 0)\par
00166       || (read_dec_datetime (fptr, &vdd->volume_expiration_date_and_time) != 0)\par
00167       || (read_dec_datetime (fptr, &vdd->volume_effective_date_and_time) != 0))\par
00168     \{\par
00169       {\cf19 return} HH_FREAD_ERROR;\par
00170     \}\par
00171 \par
00172   {\cf19 if} (read_single_uint8 (fptr, &vdd->file_structure_version) != 0)\par
00173     {\cf19 return} HH_FREAD_ERROR;\par
00174 \par
00175   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00176 \par
00177   read_string (fptr, vdd->DAT_file_creation_software_identifier,\par
00178                DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN);\par
00179 \par
00180   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00181 \par
00182   read_string (fptr, vdd->DAT_file_creation_software_version_number,\par
00183                DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN);\par
00184 \par
00185   fseek (fptr, 1, SEEK_CUR); {\cf20 // Unused byte}\par
00186 \par
00187   fseek (fptr, 0x1EC, SEEK_CUR); {\cf20 // Unknown data (492 bytes)}\par
00188 \par
00189   fseek (fptr, 0x28D, SEEK_CUR); {\cf20 // Reserved by ISO}\par
00190 \par
00191   {\cf19 return} 0;\par
00192 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/volume_descriptor.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.h}
{\xe \v src/volume_descriptor.h}
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datetime.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b volume_descriptor_data}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The data section of a primary volume descriptor. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b volume_descriptor}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A volume descriptor. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSTEM_IDENTIFIER_LEN}\~ 33\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b volume_descriptor.h} - the {\f2 {\b volume_descriptor}}  and {\f2 {\b volume_descriptor_data}}  data types and their related functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VOLUME_IDENTIFIER_LEN}\~ 33\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ROOT_DIRECTORY_ENTRY_LEN}\~ 34\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VOLUME_SET_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PUBLISHER_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATA_PREPARER_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APPLICATION_IDENTIFIER_LEN}\~ 129\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COPYRIGHT_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ABSTRACT_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}\~ 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}\~ 11\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_volume_descriptor} ({\b volume_descriptor} *vd, uint8_t type, uint8_t version)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_header} ({\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_volume_descriptor_data} ({\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_header} (FILE *fptr, {\b volume_descriptor} *vd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b process_volume_descriptor_data} (FILE *fptr, {\b volume_descriptor_data} *vdd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ABSTRACT_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:ABSTRACT_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ABSTRACT_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b volume_descriptor.h}.}\par
}
{\xe \v APPLICATION_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:APPLICATION_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APPLICATION_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b volume_descriptor.h}.}\par
}
{\xe \v BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b volume_descriptor.h}.}\par
}
{\xe \v COPYRIGHT_FILE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:COPYRIGHT_FILE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COPYRIGHT_FILE_IDENTIFIER_LEN\~ 38}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN\~ 9}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN\~ 11}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b volume_descriptor.h}.}\par
}
{\xe \v DATA_PREPARER_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:DATA_PREPARER_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATA_PREPARER_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b volume_descriptor.h}.}\par
}
{\xe \v PUBLISHER_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:PUBLISHER_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PUBLISHER_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b volume_descriptor.h}.}\par
}
{\xe \v ROOT_DIRECTORY_ENTRY_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:ROOT_DIRECTORY_ENTRY_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ROOT_DIRECTORY_ENTRY_LEN\~ 34}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b volume_descriptor.h}.}\par
}
{\xe \v SYSTEM_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:SYSTEM_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSTEM_IDENTIFIER_LEN\~ 33}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b volume_descriptor.h} - the {\f2 {\b volume_descriptor}}  and {\f2 {\b volume_descriptor_data}}  data types and their related functions. }}\par
{
Definition at line {\b 26} of file {\b volume_descriptor.h}.}\par
}
{\xe \v VOLUME_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:VOLUME_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VOLUME_IDENTIFIER_LEN\~ 33}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b volume_descriptor.h}.}\par
}
{\xe \v VOLUME_SET_IDENTIFIER_LEN\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:VOLUME_SET_IDENTIFIER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VOLUME_SET_IDENTIFIER_LEN\~ 129}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b volume_descriptor.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_volume_descriptor\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:create_volume_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_volume_descriptor ({\b volume_descriptor} * vd, uint8_t type, uint8_t version)}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a given {\f2 {\b volume_descriptor}}  using the provided {\f2 type}  and {\f2 version}  data. }}\par
{
Definition at line {\b 22} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_data\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:print_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_data ({\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the given {\f2 {\b volume_descriptor_data}}  to the stdout in a human-readable form. }}\par
{
Definition at line {\b 40} of file {\b volume_descriptor.c}.}\par
}
{\xe \v print_volume_descriptor_header\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:print_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_volume_descriptor_header ({\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the header section of a given {\f2 {\b volume_descriptor}}  in a human-readable form to stdout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The header includes every field except for {\f2 data} , which can be printed using the {\f2 {\b print_volume_descriptor_data()}}  function. \par
}{
Definition at line {\b 32} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_data\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:process_volume_descriptor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_data (FILE * fptr, {\b volume_descriptor_data} * vdd)}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the given {\f2 {\b volume_descriptor_data}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 99} of file {\b volume_descriptor.c}.}\par
}
{\xe \v process_volume_descriptor_header\:volume_descriptor.h}
{\xe \v volume_descriptor.h\:process_volume_descriptor_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t process_volume_descriptor_header (FILE * fptr, {\b volume_descriptor} * vd)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes the header of a given {\f2 {\b volume_descriptor}}  using data pointed to by {\f2 fptr} . }}\par
{
Definition at line {\b 81} of file {\b volume_descriptor.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
volume_descriptor.h\par \pard\plain 
{\tc\tcl2 \v src/volume_descriptor.h}
{\xe \v src/volume_descriptor.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //  Copyright (C) 2024  IcePanorama}\par
00002 {\cf20 //  This file is a part of HarvesterHarvester.}\par
00003 {\cf20 //  HarvesterHarvester is free software: you can redistribute it and/or modify}\par
00004 {\cf20 //  it under the terms of the GNU General Public License as published by the}\par
00005 {\cf20 //  Free Software Foundation, either version 3 of the License, or (at your}\par
00006 {\cf20 //  option) any later version.}\par
00007 {\cf20 //  This program is distributed in the hope that it will be useful, but WITHOUT}\par
00008 {\cf20 //  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or}\par
00009 {\cf20 //  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for}\par
00010 {\cf20 //  more details.}\par
00011 {\cf20 //}\par
00012 {\cf20 //  You should have received a copy of the GNU General Public License along}\par
00013 {\cf20 //  with this program.  If not, see <https://www.gnu.org/licenses/>.}\par
00018 {\cf21 #ifndef _HH_VOLUME_DESCRIPTOR_H_}\par
00019 {\cf21 #define _HH_VOLUME_DESCRIPTOR_H_}\par
00020 \par
00021 {\cf21 #include "datetime.h"}\par
00022 \par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stdio.h>}\par
00025 \par
00026 {\cf21 #define SYSTEM_IDENTIFIER_LEN 33}\par
00027 {\cf21 #define VOLUME_IDENTIFIER_LEN 33}\par
00028 {\cf21 #define ROOT_DIRECTORY_ENTRY_LEN 34}\par
00029 {\cf21 #define VOLUME_SET_IDENTIFIER_LEN 129}\par
00030 {\cf21 #define PUBLISHER_IDENTIFIER_LEN 129}\par
00031 {\cf21 #define DATA_PREPARER_IDENTIFIER_LEN 129}\par
00032 {\cf21 #define APPLICATION_IDENTIFIER_LEN 129}\par
00033 {\cf21 #define COPYRIGHT_FILE_IDENTIFIER_LEN 38}\par
00034 {\cf21 #define ABSTRACT_FILE_IDENTIFIER_LEN 38}\par
00035 {\cf21 #define BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN 38}\par
00036 {\cf21 #define DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN 9}\par
00037 {\cf21 #define DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN 11}\par
00038 \par
00044 {\cf17 typedef} {\cf17 struct }volume_descriptor_data\par
00045 \{\par
00046   {\cf18 char} system_identifier[SYSTEM_IDENTIFIER_LEN];\par
00047   {\cf18 char} volume_identifier[VOLUME_IDENTIFIER_LEN];\par
00048   uint32_t volume_space_size;\par
00049   uint16_t volume_set_size;\par
00050   uint16_t volume_sequence_number;\par
00051   uint16_t logical_block_size;\par
00052   uint32_t path_table_size;\par
00053   uint32_t type_l_path_table_location;\par
00054   uint32_t optional_type_l_path_table_location;\par
00055   uint32_t type_m_path_table_location;\par
00056   uint32_t optional_type_m_path_table_location;\par
00057   uint8_t root_directory_entry[ROOT_DIRECTORY_ENTRY_LEN];\par
00058   {\cf18 char} volume_set_identifier[VOLUME_SET_IDENTIFIER_LEN];\par
00059   {\cf18 char} publisher_identifier[PUBLISHER_IDENTIFIER_LEN];\par
00060   {\cf18 char} data_preparer_identifier[DATA_PREPARER_IDENTIFIER_LEN];\par
00061   {\cf18 char} application_identifier[APPLICATION_IDENTIFIER_LEN];\par
00062   {\cf18 char} copyright_file_identifier[COPYRIGHT_FILE_IDENTIFIER_LEN];\par
00063   {\cf18 char} abstract_file_identifier[ABSTRACT_FILE_IDENTIFIER_LEN];\par
00064   {\cf18 char} bibliographic_file_identifier[BIBLIOGRAPHIC_FILE_IDENTIFIER_LEN];\par
00065   dec_datetime volume_creation_date_and_time;\par
00066   dec_datetime volume_modification_date_and_time;\par
00067   dec_datetime volume_expiration_date_and_time;\par
00068   dec_datetime volume_effective_date_and_time;\par
00069   uint8_t file_structure_version; \par
00070   {\cf18 char} DAT_file_creation_software_identifier\par
00071       [DAT_FILE_CREATION_SOFTWARE_IDENTIFIER_LEN];\par
00072   {\cf18 char} DAT_file_creation_software_version_number\par
00073       [DAT_FILE_CREATION_SOFTWARE_VERSION_NUMBER_LEN];\par
00074 \} volume_descriptor_data;\par
00075 \par
00081 {\cf17 typedef} {\cf17 struct }volume_descriptor\par
00082 \{\par
00083   uint8_t type_code;\par
00084   {\cf18 char} identifier[6]; \par
00085   uint8_t version;\par
00086   volume_descriptor_data data;\par
00087 \} volume_descriptor;\par
00088 \par
00093 {\cf18 void} create_volume_descriptor (volume_descriptor *vd, uint8_t type,\par
00094                                uint8_t version);\par
00101 {\cf18 void} print_volume_descriptor_header (volume_descriptor *vd);\par
00102 \par
00107 {\cf18 void} print_volume_descriptor_data (volume_descriptor_data *vdd);\par
00108 \par
00113 int8_t process_volume_descriptor_header (FILE *fptr, volume_descriptor *vd);\par
00114 \par
00119 int8_t process_volume_descriptor_data (FILE *fptr,\par
00120                                        volume_descriptor_data *vdd);\par
00121 \par
00122 {\cf21 #endif}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
